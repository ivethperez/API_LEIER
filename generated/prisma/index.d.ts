
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Almacenes
 * 
 */
export type Almacenes = $Result.DefaultSelection<Prisma.$AlmacenesPayload>
/**
 * Model CategoriasProducto
 * 
 */
export type CategoriasProducto = $Result.DefaultSelection<Prisma.$CategoriasProductoPayload>
/**
 * Model Clientes
 * 
 */
export type Clientes = $Result.DefaultSelection<Prisma.$ClientesPayload>
/**
 * Model Compras
 * 
 */
export type Compras = $Result.DefaultSelection<Prisma.$ComprasPayload>
/**
 * Model ImagenesProductos
 * 
 */
export type ImagenesProductos = $Result.DefaultSelection<Prisma.$ImagenesProductosPayload>
/**
 * Model Insumos
 * 
 */
export type Insumos = $Result.DefaultSelection<Prisma.$InsumosPayload>
/**
 * Model Inventario
 * 
 */
export type Inventario = $Result.DefaultSelection<Prisma.$InventarioPayload>
/**
 * Model ListasPrecios
 * 
 */
export type ListasPrecios = $Result.DefaultSelection<Prisma.$ListasPreciosPayload>
/**
 * Model MetodosPago
 * 
 */
export type MetodosPago = $Result.DefaultSelection<Prisma.$MetodosPagoPayload>
/**
 * Model Productos
 * 
 */
export type Productos = $Result.DefaultSelection<Prisma.$ProductosPayload>
/**
 * Model Proveedores
 * 
 */
export type Proveedores = $Result.DefaultSelection<Prisma.$ProveedoresPayload>
/**
 * Model RolesUSuario
 * 
 */
export type RolesUSuario = $Result.DefaultSelection<Prisma.$RolesUSuarioPayload>
/**
 * Model TiposCompra
 * 
 */
export type TiposCompra = $Result.DefaultSelection<Prisma.$TiposCompraPayload>
/**
 * Model UnidadesMedida
 * 
 */
export type UnidadesMedida = $Result.DefaultSelection<Prisma.$UnidadesMedidaPayload>
/**
 * Model Usuarios
 * 
 */
export type Usuarios = $Result.DefaultSelection<Prisma.$UsuariosPayload>
/**
 * Model Ventas
 * 
 */
export type Ventas = $Result.DefaultSelection<Prisma.$VentasPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Almacenes
 * const almacenes = await prisma.almacenes.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Almacenes
   * const almacenes = await prisma.almacenes.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.almacenes`: Exposes CRUD operations for the **Almacenes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Almacenes
    * const almacenes = await prisma.almacenes.findMany()
    * ```
    */
  get almacenes(): Prisma.AlmacenesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoriasProducto`: Exposes CRUD operations for the **CategoriasProducto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriasProductos
    * const categoriasProductos = await prisma.categoriasProducto.findMany()
    * ```
    */
  get categoriasProducto(): Prisma.CategoriasProductoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientes`: Exposes CRUD operations for the **Clientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.clientes.findMany()
    * ```
    */
  get clientes(): Prisma.ClientesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compras`: Exposes CRUD operations for the **Compras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compras
    * const compras = await prisma.compras.findMany()
    * ```
    */
  get compras(): Prisma.ComprasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imagenesProductos`: Exposes CRUD operations for the **ImagenesProductos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImagenesProductos
    * const imagenesProductos = await prisma.imagenesProductos.findMany()
    * ```
    */
  get imagenesProductos(): Prisma.ImagenesProductosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insumos`: Exposes CRUD operations for the **Insumos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insumos
    * const insumos = await prisma.insumos.findMany()
    * ```
    */
  get insumos(): Prisma.InsumosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventario`: Exposes CRUD operations for the **Inventario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventarios
    * const inventarios = await prisma.inventario.findMany()
    * ```
    */
  get inventario(): Prisma.InventarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listasPrecios`: Exposes CRUD operations for the **ListasPrecios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListasPrecios
    * const listasPrecios = await prisma.listasPrecios.findMany()
    * ```
    */
  get listasPrecios(): Prisma.ListasPreciosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metodosPago`: Exposes CRUD operations for the **MetodosPago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetodosPagos
    * const metodosPagos = await prisma.metodosPago.findMany()
    * ```
    */
  get metodosPago(): Prisma.MetodosPagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productos`: Exposes CRUD operations for the **Productos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.productos.findMany()
    * ```
    */
  get productos(): Prisma.ProductosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proveedores`: Exposes CRUD operations for the **Proveedores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedores
    * const proveedores = await prisma.proveedores.findMany()
    * ```
    */
  get proveedores(): Prisma.ProveedoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolesUSuario`: Exposes CRUD operations for the **RolesUSuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolesUSuarios
    * const rolesUSuarios = await prisma.rolesUSuario.findMany()
    * ```
    */
  get rolesUSuario(): Prisma.RolesUSuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tiposCompra`: Exposes CRUD operations for the **TiposCompra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TiposCompras
    * const tiposCompras = await prisma.tiposCompra.findMany()
    * ```
    */
  get tiposCompra(): Prisma.TiposCompraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unidadesMedida`: Exposes CRUD operations for the **UnidadesMedida** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnidadesMedidas
    * const unidadesMedidas = await prisma.unidadesMedida.findMany()
    * ```
    */
  get unidadesMedida(): Prisma.UnidadesMedidaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **Usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.UsuariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ventas`: Exposes CRUD operations for the **Ventas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ventas
    * const ventas = await prisma.ventas.findMany()
    * ```
    */
  get ventas(): Prisma.VentasDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Almacenes: 'Almacenes',
    CategoriasProducto: 'CategoriasProducto',
    Clientes: 'Clientes',
    Compras: 'Compras',
    ImagenesProductos: 'ImagenesProductos',
    Insumos: 'Insumos',
    Inventario: 'Inventario',
    ListasPrecios: 'ListasPrecios',
    MetodosPago: 'MetodosPago',
    Productos: 'Productos',
    Proveedores: 'Proveedores',
    RolesUSuario: 'RolesUSuario',
    TiposCompra: 'TiposCompra',
    UnidadesMedida: 'UnidadesMedida',
    Usuarios: 'Usuarios',
    Ventas: 'Ventas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "almacenes" | "categoriasProducto" | "clientes" | "compras" | "imagenesProductos" | "insumos" | "inventario" | "listasPrecios" | "metodosPago" | "productos" | "proveedores" | "rolesUSuario" | "tiposCompra" | "unidadesMedida" | "usuarios" | "ventas"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Almacenes: {
        payload: Prisma.$AlmacenesPayload<ExtArgs>
        fields: Prisma.AlmacenesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlmacenesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlmacenesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload>
          }
          findFirst: {
            args: Prisma.AlmacenesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlmacenesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload>
          }
          findMany: {
            args: Prisma.AlmacenesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload>[]
          }
          create: {
            args: Prisma.AlmacenesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload>
          }
          createMany: {
            args: Prisma.AlmacenesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlmacenesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload>
          }
          update: {
            args: Prisma.AlmacenesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload>
          }
          deleteMany: {
            args: Prisma.AlmacenesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlmacenesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlmacenesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlmacenesPayload>
          }
          aggregate: {
            args: Prisma.AlmacenesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlmacenes>
          }
          groupBy: {
            args: Prisma.AlmacenesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlmacenesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlmacenesCountArgs<ExtArgs>
            result: $Utils.Optional<AlmacenesCountAggregateOutputType> | number
          }
        }
      }
      CategoriasProducto: {
        payload: Prisma.$CategoriasProductoPayload<ExtArgs>
        fields: Prisma.CategoriasProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriasProductoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriasProductoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload>
          }
          findFirst: {
            args: Prisma.CategoriasProductoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriasProductoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload>
          }
          findMany: {
            args: Prisma.CategoriasProductoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload>[]
          }
          create: {
            args: Prisma.CategoriasProductoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload>
          }
          createMany: {
            args: Prisma.CategoriasProductoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoriasProductoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload>
          }
          update: {
            args: Prisma.CategoriasProductoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload>
          }
          deleteMany: {
            args: Prisma.CategoriasProductoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriasProductoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoriasProductoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriasProductoPayload>
          }
          aggregate: {
            args: Prisma.CategoriasProductoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoriasProducto>
          }
          groupBy: {
            args: Prisma.CategoriasProductoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriasProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriasProductoCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriasProductoCountAggregateOutputType> | number
          }
        }
      }
      Clientes: {
        payload: Prisma.$ClientesPayload<ExtArgs>
        fields: Prisma.ClientesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          findFirst: {
            args: Prisma.ClientesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          findMany: {
            args: Prisma.ClientesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>[]
          }
          create: {
            args: Prisma.ClientesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          createMany: {
            args: Prisma.ClientesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          update: {
            args: Prisma.ClientesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          deleteMany: {
            args: Prisma.ClientesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          aggregate: {
            args: Prisma.ClientesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientes>
          }
          groupBy: {
            args: Prisma.ClientesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientesCountArgs<ExtArgs>
            result: $Utils.Optional<ClientesCountAggregateOutputType> | number
          }
        }
      }
      Compras: {
        payload: Prisma.$ComprasPayload<ExtArgs>
        fields: Prisma.ComprasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComprasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComprasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload>
          }
          findFirst: {
            args: Prisma.ComprasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComprasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload>
          }
          findMany: {
            args: Prisma.ComprasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload>[]
          }
          create: {
            args: Prisma.ComprasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload>
          }
          createMany: {
            args: Prisma.ComprasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComprasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload>
          }
          update: {
            args: Prisma.ComprasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload>
          }
          deleteMany: {
            args: Prisma.ComprasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComprasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComprasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprasPayload>
          }
          aggregate: {
            args: Prisma.ComprasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompras>
          }
          groupBy: {
            args: Prisma.ComprasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComprasGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComprasCountArgs<ExtArgs>
            result: $Utils.Optional<ComprasCountAggregateOutputType> | number
          }
        }
      }
      ImagenesProductos: {
        payload: Prisma.$ImagenesProductosPayload<ExtArgs>
        fields: Prisma.ImagenesProductosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImagenesProductosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImagenesProductosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload>
          }
          findFirst: {
            args: Prisma.ImagenesProductosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImagenesProductosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload>
          }
          findMany: {
            args: Prisma.ImagenesProductosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload>[]
          }
          create: {
            args: Prisma.ImagenesProductosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload>
          }
          createMany: {
            args: Prisma.ImagenesProductosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImagenesProductosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload>
          }
          update: {
            args: Prisma.ImagenesProductosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload>
          }
          deleteMany: {
            args: Prisma.ImagenesProductosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImagenesProductosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImagenesProductosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenesProductosPayload>
          }
          aggregate: {
            args: Prisma.ImagenesProductosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImagenesProductos>
          }
          groupBy: {
            args: Prisma.ImagenesProductosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagenesProductosGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImagenesProductosCountArgs<ExtArgs>
            result: $Utils.Optional<ImagenesProductosCountAggregateOutputType> | number
          }
        }
      }
      Insumos: {
        payload: Prisma.$InsumosPayload<ExtArgs>
        fields: Prisma.InsumosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsumosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsumosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload>
          }
          findFirst: {
            args: Prisma.InsumosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsumosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload>
          }
          findMany: {
            args: Prisma.InsumosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload>[]
          }
          create: {
            args: Prisma.InsumosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload>
          }
          createMany: {
            args: Prisma.InsumosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InsumosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload>
          }
          update: {
            args: Prisma.InsumosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload>
          }
          deleteMany: {
            args: Prisma.InsumosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsumosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsumosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsumosPayload>
          }
          aggregate: {
            args: Prisma.InsumosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsumos>
          }
          groupBy: {
            args: Prisma.InsumosGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsumosGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsumosCountArgs<ExtArgs>
            result: $Utils.Optional<InsumosCountAggregateOutputType> | number
          }
        }
      }
      Inventario: {
        payload: Prisma.$InventarioPayload<ExtArgs>
        fields: Prisma.InventarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          findFirst: {
            args: Prisma.InventarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          findMany: {
            args: Prisma.InventarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>[]
          }
          create: {
            args: Prisma.InventarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          createMany: {
            args: Prisma.InventarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          update: {
            args: Prisma.InventarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          deleteMany: {
            args: Prisma.InventarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarioPayload>
          }
          aggregate: {
            args: Prisma.InventarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventario>
          }
          groupBy: {
            args: Prisma.InventarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventarioCountArgs<ExtArgs>
            result: $Utils.Optional<InventarioCountAggregateOutputType> | number
          }
        }
      }
      ListasPrecios: {
        payload: Prisma.$ListasPreciosPayload<ExtArgs>
        fields: Prisma.ListasPreciosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListasPreciosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListasPreciosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload>
          }
          findFirst: {
            args: Prisma.ListasPreciosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListasPreciosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload>
          }
          findMany: {
            args: Prisma.ListasPreciosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload>[]
          }
          create: {
            args: Prisma.ListasPreciosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload>
          }
          createMany: {
            args: Prisma.ListasPreciosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ListasPreciosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload>
          }
          update: {
            args: Prisma.ListasPreciosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload>
          }
          deleteMany: {
            args: Prisma.ListasPreciosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListasPreciosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListasPreciosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListasPreciosPayload>
          }
          aggregate: {
            args: Prisma.ListasPreciosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListasPrecios>
          }
          groupBy: {
            args: Prisma.ListasPreciosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListasPreciosGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListasPreciosCountArgs<ExtArgs>
            result: $Utils.Optional<ListasPreciosCountAggregateOutputType> | number
          }
        }
      }
      MetodosPago: {
        payload: Prisma.$MetodosPagoPayload<ExtArgs>
        fields: Prisma.MetodosPagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetodosPagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetodosPagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload>
          }
          findFirst: {
            args: Prisma.MetodosPagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetodosPagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload>
          }
          findMany: {
            args: Prisma.MetodosPagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload>[]
          }
          create: {
            args: Prisma.MetodosPagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload>
          }
          createMany: {
            args: Prisma.MetodosPagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MetodosPagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload>
          }
          update: {
            args: Prisma.MetodosPagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload>
          }
          deleteMany: {
            args: Prisma.MetodosPagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetodosPagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MetodosPagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetodosPagoPayload>
          }
          aggregate: {
            args: Prisma.MetodosPagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetodosPago>
          }
          groupBy: {
            args: Prisma.MetodosPagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetodosPagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetodosPagoCountArgs<ExtArgs>
            result: $Utils.Optional<MetodosPagoCountAggregateOutputType> | number
          }
        }
      }
      Productos: {
        payload: Prisma.$ProductosPayload<ExtArgs>
        fields: Prisma.ProductosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload>
          }
          findFirst: {
            args: Prisma.ProductosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload>
          }
          findMany: {
            args: Prisma.ProductosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload>[]
          }
          create: {
            args: Prisma.ProductosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload>
          }
          createMany: {
            args: Prisma.ProductosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload>
          }
          update: {
            args: Prisma.ProductosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload>
          }
          deleteMany: {
            args: Prisma.ProductosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductosPayload>
          }
          aggregate: {
            args: Prisma.ProductosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductos>
          }
          groupBy: {
            args: Prisma.ProductosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductosGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductosCountArgs<ExtArgs>
            result: $Utils.Optional<ProductosCountAggregateOutputType> | number
          }
        }
      }
      Proveedores: {
        payload: Prisma.$ProveedoresPayload<ExtArgs>
        fields: Prisma.ProveedoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProveedoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProveedoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload>
          }
          findFirst: {
            args: Prisma.ProveedoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProveedoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload>
          }
          findMany: {
            args: Prisma.ProveedoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload>[]
          }
          create: {
            args: Prisma.ProveedoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload>
          }
          createMany: {
            args: Prisma.ProveedoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProveedoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload>
          }
          update: {
            args: Prisma.ProveedoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload>
          }
          deleteMany: {
            args: Prisma.ProveedoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProveedoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProveedoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedoresPayload>
          }
          aggregate: {
            args: Prisma.ProveedoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProveedores>
          }
          groupBy: {
            args: Prisma.ProveedoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProveedoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProveedoresCountArgs<ExtArgs>
            result: $Utils.Optional<ProveedoresCountAggregateOutputType> | number
          }
        }
      }
      RolesUSuario: {
        payload: Prisma.$RolesUSuarioPayload<ExtArgs>
        fields: Prisma.RolesUSuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesUSuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesUSuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload>
          }
          findFirst: {
            args: Prisma.RolesUSuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesUSuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload>
          }
          findMany: {
            args: Prisma.RolesUSuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload>[]
          }
          create: {
            args: Prisma.RolesUSuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload>
          }
          createMany: {
            args: Prisma.RolesUSuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolesUSuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload>
          }
          update: {
            args: Prisma.RolesUSuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload>
          }
          deleteMany: {
            args: Prisma.RolesUSuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUSuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolesUSuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesUSuarioPayload>
          }
          aggregate: {
            args: Prisma.RolesUSuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolesUSuario>
          }
          groupBy: {
            args: Prisma.RolesUSuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesUSuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesUSuarioCountArgs<ExtArgs>
            result: $Utils.Optional<RolesUSuarioCountAggregateOutputType> | number
          }
        }
      }
      TiposCompra: {
        payload: Prisma.$TiposCompraPayload<ExtArgs>
        fields: Prisma.TiposCompraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TiposCompraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TiposCompraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload>
          }
          findFirst: {
            args: Prisma.TiposCompraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TiposCompraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload>
          }
          findMany: {
            args: Prisma.TiposCompraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload>[]
          }
          create: {
            args: Prisma.TiposCompraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload>
          }
          createMany: {
            args: Prisma.TiposCompraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TiposCompraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload>
          }
          update: {
            args: Prisma.TiposCompraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload>
          }
          deleteMany: {
            args: Prisma.TiposCompraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TiposCompraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TiposCompraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiposCompraPayload>
          }
          aggregate: {
            args: Prisma.TiposCompraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTiposCompra>
          }
          groupBy: {
            args: Prisma.TiposCompraGroupByArgs<ExtArgs>
            result: $Utils.Optional<TiposCompraGroupByOutputType>[]
          }
          count: {
            args: Prisma.TiposCompraCountArgs<ExtArgs>
            result: $Utils.Optional<TiposCompraCountAggregateOutputType> | number
          }
        }
      }
      UnidadesMedida: {
        payload: Prisma.$UnidadesMedidaPayload<ExtArgs>
        fields: Prisma.UnidadesMedidaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnidadesMedidaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnidadesMedidaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload>
          }
          findFirst: {
            args: Prisma.UnidadesMedidaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnidadesMedidaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload>
          }
          findMany: {
            args: Prisma.UnidadesMedidaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload>[]
          }
          create: {
            args: Prisma.UnidadesMedidaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload>
          }
          createMany: {
            args: Prisma.UnidadesMedidaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnidadesMedidaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload>
          }
          update: {
            args: Prisma.UnidadesMedidaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload>
          }
          deleteMany: {
            args: Prisma.UnidadesMedidaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnidadesMedidaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnidadesMedidaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadesMedidaPayload>
          }
          aggregate: {
            args: Prisma.UnidadesMedidaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnidadesMedida>
          }
          groupBy: {
            args: Prisma.UnidadesMedidaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnidadesMedidaGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnidadesMedidaCountArgs<ExtArgs>
            result: $Utils.Optional<UnidadesMedidaCountAggregateOutputType> | number
          }
        }
      }
      Usuarios: {
        payload: Prisma.$UsuariosPayload<ExtArgs>
        fields: Prisma.UsuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findFirst: {
            args: Prisma.UsuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findMany: {
            args: Prisma.UsuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          create: {
            args: Prisma.UsuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          createMany: {
            args: Prisma.UsuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          update: {
            args: Prisma.UsuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          deleteMany: {
            args: Prisma.UsuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.UsuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuariosCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
      Ventas: {
        payload: Prisma.$VentasPayload<ExtArgs>
        fields: Prisma.VentasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload>
          }
          findFirst: {
            args: Prisma.VentasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload>
          }
          findMany: {
            args: Prisma.VentasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload>[]
          }
          create: {
            args: Prisma.VentasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload>
          }
          createMany: {
            args: Prisma.VentasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VentasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload>
          }
          update: {
            args: Prisma.VentasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload>
          }
          deleteMany: {
            args: Prisma.VentasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VentasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentasPayload>
          }
          aggregate: {
            args: Prisma.VentasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVentas>
          }
          groupBy: {
            args: Prisma.VentasGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentasGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentasCountArgs<ExtArgs>
            result: $Utils.Optional<VentasCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    almacenes?: AlmacenesOmit
    categoriasProducto?: CategoriasProductoOmit
    clientes?: ClientesOmit
    compras?: ComprasOmit
    imagenesProductos?: ImagenesProductosOmit
    insumos?: InsumosOmit
    inventario?: InventarioOmit
    listasPrecios?: ListasPreciosOmit
    metodosPago?: MetodosPagoOmit
    productos?: ProductosOmit
    proveedores?: ProveedoresOmit
    rolesUSuario?: RolesUSuarioOmit
    tiposCompra?: TiposCompraOmit
    unidadesMedida?: UnidadesMedidaOmit
    usuarios?: UsuariosOmit
    ventas?: VentasOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AlmacenesCountOutputType
   */

  export type AlmacenesCountOutputType = {
    Inventario_Inventario_AlmacenActualIdToAlmacenes: number
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes: number
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes: number
  }

  export type AlmacenesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: boolean | AlmacenesCountOutputTypeCountInventario_Inventario_AlmacenActualIdToAlmacenesArgs
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: boolean | AlmacenesCountOutputTypeCountInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesArgs
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: boolean | AlmacenesCountOutputTypeCountInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesArgs
  }

  // Custom InputTypes
  /**
   * AlmacenesCountOutputType without action
   */
  export type AlmacenesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlmacenesCountOutputType
     */
    select?: AlmacenesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlmacenesCountOutputType without action
   */
  export type AlmacenesCountOutputTypeCountInventario_Inventario_AlmacenActualIdToAlmacenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }

  /**
   * AlmacenesCountOutputType without action
   */
  export type AlmacenesCountOutputTypeCountInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }

  /**
   * AlmacenesCountOutputType without action
   */
  export type AlmacenesCountOutputTypeCountInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }


  /**
   * Count Type CategoriasProductoCountOutputType
   */

  export type CategoriasProductoCountOutputType = {
    Productos: number
  }

  export type CategoriasProductoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Productos?: boolean | CategoriasProductoCountOutputTypeCountProductosArgs
  }

  // Custom InputTypes
  /**
   * CategoriasProductoCountOutputType without action
   */
  export type CategoriasProductoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProductoCountOutputType
     */
    select?: CategoriasProductoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriasProductoCountOutputType without action
   */
  export type CategoriasProductoCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductosWhereInput
  }


  /**
   * Count Type ClientesCountOutputType
   */

  export type ClientesCountOutputType = {
    Ventas: number
  }

  export type ClientesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ventas?: boolean | ClientesCountOutputTypeCountVentasArgs
  }

  // Custom InputTypes
  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientesCountOutputType
     */
    select?: ClientesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeCountVentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentasWhereInput
  }


  /**
   * Count Type ComprasCountOutputType
   */

  export type ComprasCountOutputType = {
    Inventario: number
  }

  export type ComprasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventario?: boolean | ComprasCountOutputTypeCountInventarioArgs
  }

  // Custom InputTypes
  /**
   * ComprasCountOutputType without action
   */
  export type ComprasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprasCountOutputType
     */
    select?: ComprasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComprasCountOutputType without action
   */
  export type ComprasCountOutputTypeCountInventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }


  /**
   * Count Type InsumosCountOutputType
   */

  export type InsumosCountOutputType = {
    Compras: number
  }

  export type InsumosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | InsumosCountOutputTypeCountComprasArgs
  }

  // Custom InputTypes
  /**
   * InsumosCountOutputType without action
   */
  export type InsumosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsumosCountOutputType
     */
    select?: InsumosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsumosCountOutputType without action
   */
  export type InsumosCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprasWhereInput
  }


  /**
   * Count Type MetodosPagoCountOutputType
   */

  export type MetodosPagoCountOutputType = {
    Ventas: number
  }

  export type MetodosPagoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ventas?: boolean | MetodosPagoCountOutputTypeCountVentasArgs
  }

  // Custom InputTypes
  /**
   * MetodosPagoCountOutputType without action
   */
  export type MetodosPagoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPagoCountOutputType
     */
    select?: MetodosPagoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MetodosPagoCountOutputType without action
   */
  export type MetodosPagoCountOutputTypeCountVentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentasWhereInput
  }


  /**
   * Count Type ProductosCountOutputType
   */

  export type ProductosCountOutputType = {
    Compras: number
    ImagenesProductos: number
    Inventario: number
    ListasPrecios: number
    Ventas: number
  }

  export type ProductosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | ProductosCountOutputTypeCountComprasArgs
    ImagenesProductos?: boolean | ProductosCountOutputTypeCountImagenesProductosArgs
    Inventario?: boolean | ProductosCountOutputTypeCountInventarioArgs
    ListasPrecios?: boolean | ProductosCountOutputTypeCountListasPreciosArgs
    Ventas?: boolean | ProductosCountOutputTypeCountVentasArgs
  }

  // Custom InputTypes
  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductosCountOutputType
     */
    select?: ProductosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprasWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountImagenesProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagenesProductosWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountInventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountListasPreciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListasPreciosWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountVentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentasWhereInput
  }


  /**
   * Count Type ProveedoresCountOutputType
   */

  export type ProveedoresCountOutputType = {
    Compras: number
  }

  export type ProveedoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | ProveedoresCountOutputTypeCountComprasArgs
  }

  // Custom InputTypes
  /**
   * ProveedoresCountOutputType without action
   */
  export type ProveedoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProveedoresCountOutputType
     */
    select?: ProveedoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProveedoresCountOutputType without action
   */
  export type ProveedoresCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprasWhereInput
  }


  /**
   * Count Type RolesUSuarioCountOutputType
   */

  export type RolesUSuarioCountOutputType = {
    Usuarios: number
  }

  export type RolesUSuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | RolesUSuarioCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * RolesUSuarioCountOutputType without action
   */
  export type RolesUSuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuarioCountOutputType
     */
    select?: RolesUSuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesUSuarioCountOutputType without action
   */
  export type RolesUSuarioCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
  }


  /**
   * Count Type TiposCompraCountOutputType
   */

  export type TiposCompraCountOutputType = {
    Compras: number
  }

  export type TiposCompraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | TiposCompraCountOutputTypeCountComprasArgs
  }

  // Custom InputTypes
  /**
   * TiposCompraCountOutputType without action
   */
  export type TiposCompraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompraCountOutputType
     */
    select?: TiposCompraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TiposCompraCountOutputType without action
   */
  export type TiposCompraCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprasWhereInput
  }


  /**
   * Count Type UnidadesMedidaCountOutputType
   */

  export type UnidadesMedidaCountOutputType = {
    ListasPrecios: number
  }

  export type UnidadesMedidaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ListasPrecios?: boolean | UnidadesMedidaCountOutputTypeCountListasPreciosArgs
  }

  // Custom InputTypes
  /**
   * UnidadesMedidaCountOutputType without action
   */
  export type UnidadesMedidaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedidaCountOutputType
     */
    select?: UnidadesMedidaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnidadesMedidaCountOutputType without action
   */
  export type UnidadesMedidaCountOutputTypeCountListasPreciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListasPreciosWhereInput
  }


  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    Almacenes_Almacenes_UsuarioIdToUsuarios: number
    Almacenes_Almacenes_ModificadoPorToUsuarios: number
    Inventario: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Almacenes_Almacenes_UsuarioIdToUsuarios?: boolean | UsuariosCountOutputTypeCountAlmacenes_Almacenes_UsuarioIdToUsuariosArgs
    Almacenes_Almacenes_ModificadoPorToUsuarios?: boolean | UsuariosCountOutputTypeCountAlmacenes_Almacenes_ModificadoPorToUsuariosArgs
    Inventario?: boolean | UsuariosCountOutputTypeCountInventarioArgs
  }

  // Custom InputTypes
  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountAlmacenes_Almacenes_UsuarioIdToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlmacenesWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountAlmacenes_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlmacenesWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountInventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Almacenes
   */

  export type AggregateAlmacenes = {
    _count: AlmacenesCountAggregateOutputType | null
    _avg: AlmacenesAvgAggregateOutputType | null
    _sum: AlmacenesSumAggregateOutputType | null
    _min: AlmacenesMinAggregateOutputType | null
    _max: AlmacenesMaxAggregateOutputType | null
  }

  export type AlmacenesAvgAggregateOutputType = {
    Id: number | null
    Existencia_bolsas: number | null
    Existencia_kg: number | null
    UsuarioId: number | null
    ModificadoPor: number | null
  }

  export type AlmacenesSumAggregateOutputType = {
    Id: number | null
    Existencia_bolsas: number | null
    Existencia_kg: number | null
    UsuarioId: number | null
    ModificadoPor: number | null
  }

  export type AlmacenesMinAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
    Existencia_bolsas: number | null
    Existencia_kg: number | null
    CreadoFecha: Date | null
    UsuarioId: number | null
    FechaModificacion: Date | null
    ModificadoPor: number | null
  }

  export type AlmacenesMaxAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
    Existencia_bolsas: number | null
    Existencia_kg: number | null
    CreadoFecha: Date | null
    UsuarioId: number | null
    FechaModificacion: Date | null
    ModificadoPor: number | null
  }

  export type AlmacenesCountAggregateOutputType = {
    Id: number
    Code: number
    Nombre: number
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: number
    UsuarioId: number
    FechaModificacion: number
    ModificadoPor: number
    _all: number
  }


  export type AlmacenesAvgAggregateInputType = {
    Id?: true
    Existencia_bolsas?: true
    Existencia_kg?: true
    UsuarioId?: true
    ModificadoPor?: true
  }

  export type AlmacenesSumAggregateInputType = {
    Id?: true
    Existencia_bolsas?: true
    Existencia_kg?: true
    UsuarioId?: true
    ModificadoPor?: true
  }

  export type AlmacenesMinAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
    Existencia_bolsas?: true
    Existencia_kg?: true
    CreadoFecha?: true
    UsuarioId?: true
    FechaModificacion?: true
    ModificadoPor?: true
  }

  export type AlmacenesMaxAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
    Existencia_bolsas?: true
    Existencia_kg?: true
    CreadoFecha?: true
    UsuarioId?: true
    FechaModificacion?: true
    ModificadoPor?: true
  }

  export type AlmacenesCountAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
    Existencia_bolsas?: true
    Existencia_kg?: true
    CreadoFecha?: true
    UsuarioId?: true
    FechaModificacion?: true
    ModificadoPor?: true
    _all?: true
  }

  export type AlmacenesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Almacenes to aggregate.
     */
    where?: AlmacenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Almacenes to fetch.
     */
    orderBy?: AlmacenesOrderByWithRelationInput | AlmacenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlmacenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Almacenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Almacenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Almacenes
    **/
    _count?: true | AlmacenesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlmacenesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlmacenesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlmacenesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlmacenesMaxAggregateInputType
  }

  export type GetAlmacenesAggregateType<T extends AlmacenesAggregateArgs> = {
        [P in keyof T & keyof AggregateAlmacenes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlmacenes[P]>
      : GetScalarType<T[P], AggregateAlmacenes[P]>
  }




  export type AlmacenesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlmacenesWhereInput
    orderBy?: AlmacenesOrderByWithAggregationInput | AlmacenesOrderByWithAggregationInput[]
    by: AlmacenesScalarFieldEnum[] | AlmacenesScalarFieldEnum
    having?: AlmacenesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlmacenesCountAggregateInputType | true
    _avg?: AlmacenesAvgAggregateInputType
    _sum?: AlmacenesSumAggregateInputType
    _min?: AlmacenesMinAggregateInputType
    _max?: AlmacenesMaxAggregateInputType
  }

  export type AlmacenesGroupByOutputType = {
    Id: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date
    UsuarioId: number
    FechaModificacion: Date | null
    ModificadoPor: number | null
    _count: AlmacenesCountAggregateOutputType | null
    _avg: AlmacenesAvgAggregateOutputType | null
    _sum: AlmacenesSumAggregateOutputType | null
    _min: AlmacenesMinAggregateOutputType | null
    _max: AlmacenesMaxAggregateOutputType | null
  }

  type GetAlmacenesGroupByPayload<T extends AlmacenesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlmacenesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlmacenesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlmacenesGroupByOutputType[P]>
            : GetScalarType<T[P], AlmacenesGroupByOutputType[P]>
        }
      >
    >


  export type AlmacenesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
    Existencia_bolsas?: boolean
    Existencia_kg?: boolean
    CreadoFecha?: boolean
    UsuarioId?: boolean
    FechaModificacion?: boolean
    ModificadoPor?: boolean
    Usuarios_Almacenes_UsuarioIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Almacenes_ModificadoPorToUsuarios?: boolean | Almacenes$Usuarios_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs>
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: boolean | Almacenes$Inventario_Inventario_AlmacenActualIdToAlmacenesArgs<ExtArgs>
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: boolean | Almacenes$Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenesArgs<ExtArgs>
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: boolean | Almacenes$Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenesArgs<ExtArgs>
    _count?: boolean | AlmacenesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["almacenes"]>



  export type AlmacenesSelectScalar = {
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
    Existencia_bolsas?: boolean
    Existencia_kg?: boolean
    CreadoFecha?: boolean
    UsuarioId?: boolean
    FechaModificacion?: boolean
    ModificadoPor?: boolean
  }

  export type AlmacenesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Code" | "Nombre" | "Existencia_bolsas" | "Existencia_kg" | "CreadoFecha" | "UsuarioId" | "FechaModificacion" | "ModificadoPor", ExtArgs["result"]["almacenes"]>
  export type AlmacenesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios_Almacenes_UsuarioIdToUsuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
    Usuarios_Almacenes_ModificadoPorToUsuarios?: boolean | Almacenes$Usuarios_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs>
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: boolean | Almacenes$Inventario_Inventario_AlmacenActualIdToAlmacenesArgs<ExtArgs>
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: boolean | Almacenes$Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenesArgs<ExtArgs>
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: boolean | Almacenes$Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenesArgs<ExtArgs>
    _count?: boolean | AlmacenesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AlmacenesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Almacenes"
    objects: {
      Usuarios_Almacenes_UsuarioIdToUsuarios: Prisma.$UsuariosPayload<ExtArgs>
      Usuarios_Almacenes_ModificadoPorToUsuarios: Prisma.$UsuariosPayload<ExtArgs> | null
      Inventario_Inventario_AlmacenActualIdToAlmacenes: Prisma.$InventarioPayload<ExtArgs>[]
      Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes: Prisma.$InventarioPayload<ExtArgs>[]
      Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes: Prisma.$InventarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Code: string
      Nombre: string
      Existencia_bolsas: number
      Existencia_kg: number
      CreadoFecha: Date
      UsuarioId: number
      FechaModificacion: Date | null
      ModificadoPor: number | null
    }, ExtArgs["result"]["almacenes"]>
    composites: {}
  }

  type AlmacenesGetPayload<S extends boolean | null | undefined | AlmacenesDefaultArgs> = $Result.GetResult<Prisma.$AlmacenesPayload, S>

  type AlmacenesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlmacenesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlmacenesCountAggregateInputType | true
    }

  export interface AlmacenesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Almacenes'], meta: { name: 'Almacenes' } }
    /**
     * Find zero or one Almacenes that matches the filter.
     * @param {AlmacenesFindUniqueArgs} args - Arguments to find a Almacenes
     * @example
     * // Get one Almacenes
     * const almacenes = await prisma.almacenes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlmacenesFindUniqueArgs>(args: SelectSubset<T, AlmacenesFindUniqueArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Almacenes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlmacenesFindUniqueOrThrowArgs} args - Arguments to find a Almacenes
     * @example
     * // Get one Almacenes
     * const almacenes = await prisma.almacenes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlmacenesFindUniqueOrThrowArgs>(args: SelectSubset<T, AlmacenesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Almacenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlmacenesFindFirstArgs} args - Arguments to find a Almacenes
     * @example
     * // Get one Almacenes
     * const almacenes = await prisma.almacenes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlmacenesFindFirstArgs>(args?: SelectSubset<T, AlmacenesFindFirstArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Almacenes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlmacenesFindFirstOrThrowArgs} args - Arguments to find a Almacenes
     * @example
     * // Get one Almacenes
     * const almacenes = await prisma.almacenes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlmacenesFindFirstOrThrowArgs>(args?: SelectSubset<T, AlmacenesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Almacenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlmacenesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Almacenes
     * const almacenes = await prisma.almacenes.findMany()
     * 
     * // Get first 10 Almacenes
     * const almacenes = await prisma.almacenes.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const almacenesWithIdOnly = await prisma.almacenes.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AlmacenesFindManyArgs>(args?: SelectSubset<T, AlmacenesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Almacenes.
     * @param {AlmacenesCreateArgs} args - Arguments to create a Almacenes.
     * @example
     * // Create one Almacenes
     * const Almacenes = await prisma.almacenes.create({
     *   data: {
     *     // ... data to create a Almacenes
     *   }
     * })
     * 
     */
    create<T extends AlmacenesCreateArgs>(args: SelectSubset<T, AlmacenesCreateArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Almacenes.
     * @param {AlmacenesCreateManyArgs} args - Arguments to create many Almacenes.
     * @example
     * // Create many Almacenes
     * const almacenes = await prisma.almacenes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlmacenesCreateManyArgs>(args?: SelectSubset<T, AlmacenesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Almacenes.
     * @param {AlmacenesDeleteArgs} args - Arguments to delete one Almacenes.
     * @example
     * // Delete one Almacenes
     * const Almacenes = await prisma.almacenes.delete({
     *   where: {
     *     // ... filter to delete one Almacenes
     *   }
     * })
     * 
     */
    delete<T extends AlmacenesDeleteArgs>(args: SelectSubset<T, AlmacenesDeleteArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Almacenes.
     * @param {AlmacenesUpdateArgs} args - Arguments to update one Almacenes.
     * @example
     * // Update one Almacenes
     * const almacenes = await prisma.almacenes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlmacenesUpdateArgs>(args: SelectSubset<T, AlmacenesUpdateArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Almacenes.
     * @param {AlmacenesDeleteManyArgs} args - Arguments to filter Almacenes to delete.
     * @example
     * // Delete a few Almacenes
     * const { count } = await prisma.almacenes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlmacenesDeleteManyArgs>(args?: SelectSubset<T, AlmacenesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Almacenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlmacenesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Almacenes
     * const almacenes = await prisma.almacenes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlmacenesUpdateManyArgs>(args: SelectSubset<T, AlmacenesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Almacenes.
     * @param {AlmacenesUpsertArgs} args - Arguments to update or create a Almacenes.
     * @example
     * // Update or create a Almacenes
     * const almacenes = await prisma.almacenes.upsert({
     *   create: {
     *     // ... data to create a Almacenes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Almacenes we want to update
     *   }
     * })
     */
    upsert<T extends AlmacenesUpsertArgs>(args: SelectSubset<T, AlmacenesUpsertArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Almacenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlmacenesCountArgs} args - Arguments to filter Almacenes to count.
     * @example
     * // Count the number of Almacenes
     * const count = await prisma.almacenes.count({
     *   where: {
     *     // ... the filter for the Almacenes we want to count
     *   }
     * })
    **/
    count<T extends AlmacenesCountArgs>(
      args?: Subset<T, AlmacenesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlmacenesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Almacenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlmacenesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlmacenesAggregateArgs>(args: Subset<T, AlmacenesAggregateArgs>): Prisma.PrismaPromise<GetAlmacenesAggregateType<T>>

    /**
     * Group by Almacenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlmacenesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlmacenesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlmacenesGroupByArgs['orderBy'] }
        : { orderBy?: AlmacenesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlmacenesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlmacenesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Almacenes model
   */
  readonly fields: AlmacenesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Almacenes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlmacenesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuarios_Almacenes_UsuarioIdToUsuarios<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuarios_Almacenes_ModificadoPorToUsuarios<T extends Almacenes$Usuarios_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Almacenes$Usuarios_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Inventario_Inventario_AlmacenActualIdToAlmacenes<T extends Almacenes$Inventario_Inventario_AlmacenActualIdToAlmacenesArgs<ExtArgs> = {}>(args?: Subset<T, Almacenes$Inventario_Inventario_AlmacenActualIdToAlmacenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes<T extends Almacenes$Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenesArgs<ExtArgs> = {}>(args?: Subset<T, Almacenes$Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes<T extends Almacenes$Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenesArgs<ExtArgs> = {}>(args?: Subset<T, Almacenes$Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Almacenes model
   */
  interface AlmacenesFieldRefs {
    readonly Id: FieldRef<"Almacenes", 'Int'>
    readonly Code: FieldRef<"Almacenes", 'String'>
    readonly Nombre: FieldRef<"Almacenes", 'String'>
    readonly Existencia_bolsas: FieldRef<"Almacenes", 'Int'>
    readonly Existencia_kg: FieldRef<"Almacenes", 'Int'>
    readonly CreadoFecha: FieldRef<"Almacenes", 'DateTime'>
    readonly UsuarioId: FieldRef<"Almacenes", 'Int'>
    readonly FechaModificacion: FieldRef<"Almacenes", 'DateTime'>
    readonly ModificadoPor: FieldRef<"Almacenes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Almacenes findUnique
   */
  export type AlmacenesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * Filter, which Almacenes to fetch.
     */
    where: AlmacenesWhereUniqueInput
  }

  /**
   * Almacenes findUniqueOrThrow
   */
  export type AlmacenesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * Filter, which Almacenes to fetch.
     */
    where: AlmacenesWhereUniqueInput
  }

  /**
   * Almacenes findFirst
   */
  export type AlmacenesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * Filter, which Almacenes to fetch.
     */
    where?: AlmacenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Almacenes to fetch.
     */
    orderBy?: AlmacenesOrderByWithRelationInput | AlmacenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Almacenes.
     */
    cursor?: AlmacenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Almacenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Almacenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Almacenes.
     */
    distinct?: AlmacenesScalarFieldEnum | AlmacenesScalarFieldEnum[]
  }

  /**
   * Almacenes findFirstOrThrow
   */
  export type AlmacenesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * Filter, which Almacenes to fetch.
     */
    where?: AlmacenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Almacenes to fetch.
     */
    orderBy?: AlmacenesOrderByWithRelationInput | AlmacenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Almacenes.
     */
    cursor?: AlmacenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Almacenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Almacenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Almacenes.
     */
    distinct?: AlmacenesScalarFieldEnum | AlmacenesScalarFieldEnum[]
  }

  /**
   * Almacenes findMany
   */
  export type AlmacenesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * Filter, which Almacenes to fetch.
     */
    where?: AlmacenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Almacenes to fetch.
     */
    orderBy?: AlmacenesOrderByWithRelationInput | AlmacenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Almacenes.
     */
    cursor?: AlmacenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Almacenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Almacenes.
     */
    skip?: number
    distinct?: AlmacenesScalarFieldEnum | AlmacenesScalarFieldEnum[]
  }

  /**
   * Almacenes create
   */
  export type AlmacenesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * The data needed to create a Almacenes.
     */
    data: XOR<AlmacenesCreateInput, AlmacenesUncheckedCreateInput>
  }

  /**
   * Almacenes createMany
   */
  export type AlmacenesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Almacenes.
     */
    data: AlmacenesCreateManyInput | AlmacenesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Almacenes update
   */
  export type AlmacenesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * The data needed to update a Almacenes.
     */
    data: XOR<AlmacenesUpdateInput, AlmacenesUncheckedUpdateInput>
    /**
     * Choose, which Almacenes to update.
     */
    where: AlmacenesWhereUniqueInput
  }

  /**
   * Almacenes updateMany
   */
  export type AlmacenesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Almacenes.
     */
    data: XOR<AlmacenesUpdateManyMutationInput, AlmacenesUncheckedUpdateManyInput>
    /**
     * Filter which Almacenes to update
     */
    where?: AlmacenesWhereInput
    /**
     * Limit how many Almacenes to update.
     */
    limit?: number
  }

  /**
   * Almacenes upsert
   */
  export type AlmacenesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * The filter to search for the Almacenes to update in case it exists.
     */
    where: AlmacenesWhereUniqueInput
    /**
     * In case the Almacenes found by the `where` argument doesn't exist, create a new Almacenes with this data.
     */
    create: XOR<AlmacenesCreateInput, AlmacenesUncheckedCreateInput>
    /**
     * In case the Almacenes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlmacenesUpdateInput, AlmacenesUncheckedUpdateInput>
  }

  /**
   * Almacenes delete
   */
  export type AlmacenesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    /**
     * Filter which Almacenes to delete.
     */
    where: AlmacenesWhereUniqueInput
  }

  /**
   * Almacenes deleteMany
   */
  export type AlmacenesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Almacenes to delete
     */
    where?: AlmacenesWhereInput
    /**
     * Limit how many Almacenes to delete.
     */
    limit?: number
  }

  /**
   * Almacenes.Usuarios_Almacenes_ModificadoPorToUsuarios
   */
  export type Almacenes$Usuarios_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }

  /**
   * Almacenes.Inventario_Inventario_AlmacenActualIdToAlmacenes
   */
  export type Almacenes$Inventario_Inventario_AlmacenActualIdToAlmacenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Almacenes.Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes
   */
  export type Almacenes$Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Almacenes.Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes
   */
  export type Almacenes$Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Almacenes without action
   */
  export type AlmacenesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
  }


  /**
   * Model CategoriasProducto
   */

  export type AggregateCategoriasProducto = {
    _count: CategoriasProductoCountAggregateOutputType | null
    _avg: CategoriasProductoAvgAggregateOutputType | null
    _sum: CategoriasProductoSumAggregateOutputType | null
    _min: CategoriasProductoMinAggregateOutputType | null
    _max: CategoriasProductoMaxAggregateOutputType | null
  }

  export type CategoriasProductoAvgAggregateOutputType = {
    Id: number | null
  }

  export type CategoriasProductoSumAggregateOutputType = {
    Id: number | null
  }

  export type CategoriasProductoMinAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
  }

  export type CategoriasProductoMaxAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
  }

  export type CategoriasProductoCountAggregateOutputType = {
    Id: number
    Code: number
    Nombre: number
    _all: number
  }


  export type CategoriasProductoAvgAggregateInputType = {
    Id?: true
  }

  export type CategoriasProductoSumAggregateInputType = {
    Id?: true
  }

  export type CategoriasProductoMinAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
  }

  export type CategoriasProductoMaxAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
  }

  export type CategoriasProductoCountAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
    _all?: true
  }

  export type CategoriasProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriasProducto to aggregate.
     */
    where?: CategoriasProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriasProductos to fetch.
     */
    orderBy?: CategoriasProductoOrderByWithRelationInput | CategoriasProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriasProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriasProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriasProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoriasProductos
    **/
    _count?: true | CategoriasProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriasProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriasProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasProductoMaxAggregateInputType
  }

  export type GetCategoriasProductoAggregateType<T extends CategoriasProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriasProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriasProducto[P]>
      : GetScalarType<T[P], AggregateCategoriasProducto[P]>
  }




  export type CategoriasProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriasProductoWhereInput
    orderBy?: CategoriasProductoOrderByWithAggregationInput | CategoriasProductoOrderByWithAggregationInput[]
    by: CategoriasProductoScalarFieldEnum[] | CategoriasProductoScalarFieldEnum
    having?: CategoriasProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasProductoCountAggregateInputType | true
    _avg?: CategoriasProductoAvgAggregateInputType
    _sum?: CategoriasProductoSumAggregateInputType
    _min?: CategoriasProductoMinAggregateInputType
    _max?: CategoriasProductoMaxAggregateInputType
  }

  export type CategoriasProductoGroupByOutputType = {
    Id: number
    Code: string
    Nombre: string
    _count: CategoriasProductoCountAggregateOutputType | null
    _avg: CategoriasProductoAvgAggregateOutputType | null
    _sum: CategoriasProductoSumAggregateOutputType | null
    _min: CategoriasProductoMinAggregateOutputType | null
    _max: CategoriasProductoMaxAggregateOutputType | null
  }

  type GetCategoriasProductoGroupByPayload<T extends CategoriasProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriasProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasProductoGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasProductoGroupByOutputType[P]>
        }
      >
    >


  export type CategoriasProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
    Productos?: boolean | CategoriasProducto$ProductosArgs<ExtArgs>
    _count?: boolean | CategoriasProductoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriasProducto"]>



  export type CategoriasProductoSelectScalar = {
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
  }

  export type CategoriasProductoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Code" | "Nombre", ExtArgs["result"]["categoriasProducto"]>
  export type CategoriasProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Productos?: boolean | CategoriasProducto$ProductosArgs<ExtArgs>
    _count?: boolean | CategoriasProductoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoriasProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoriasProducto"
    objects: {
      Productos: Prisma.$ProductosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Code: string
      Nombre: string
    }, ExtArgs["result"]["categoriasProducto"]>
    composites: {}
  }

  type CategoriasProductoGetPayload<S extends boolean | null | undefined | CategoriasProductoDefaultArgs> = $Result.GetResult<Prisma.$CategoriasProductoPayload, S>

  type CategoriasProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriasProductoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriasProductoCountAggregateInputType | true
    }

  export interface CategoriasProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoriasProducto'], meta: { name: 'CategoriasProducto' } }
    /**
     * Find zero or one CategoriasProducto that matches the filter.
     * @param {CategoriasProductoFindUniqueArgs} args - Arguments to find a CategoriasProducto
     * @example
     * // Get one CategoriasProducto
     * const categoriasProducto = await prisma.categoriasProducto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriasProductoFindUniqueArgs>(args: SelectSubset<T, CategoriasProductoFindUniqueArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoriasProducto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriasProductoFindUniqueOrThrowArgs} args - Arguments to find a CategoriasProducto
     * @example
     * // Get one CategoriasProducto
     * const categoriasProducto = await prisma.categoriasProducto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriasProductoFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriasProductoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriasProducto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasProductoFindFirstArgs} args - Arguments to find a CategoriasProducto
     * @example
     * // Get one CategoriasProducto
     * const categoriasProducto = await prisma.categoriasProducto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriasProductoFindFirstArgs>(args?: SelectSubset<T, CategoriasProductoFindFirstArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriasProducto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasProductoFindFirstOrThrowArgs} args - Arguments to find a CategoriasProducto
     * @example
     * // Get one CategoriasProducto
     * const categoriasProducto = await prisma.categoriasProducto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriasProductoFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriasProductoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoriasProductos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriasProductos
     * const categoriasProductos = await prisma.categoriasProducto.findMany()
     * 
     * // Get first 10 CategoriasProductos
     * const categoriasProductos = await prisma.categoriasProducto.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const categoriasProductoWithIdOnly = await prisma.categoriasProducto.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends CategoriasProductoFindManyArgs>(args?: SelectSubset<T, CategoriasProductoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoriasProducto.
     * @param {CategoriasProductoCreateArgs} args - Arguments to create a CategoriasProducto.
     * @example
     * // Create one CategoriasProducto
     * const CategoriasProducto = await prisma.categoriasProducto.create({
     *   data: {
     *     // ... data to create a CategoriasProducto
     *   }
     * })
     * 
     */
    create<T extends CategoriasProductoCreateArgs>(args: SelectSubset<T, CategoriasProductoCreateArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoriasProductos.
     * @param {CategoriasProductoCreateManyArgs} args - Arguments to create many CategoriasProductos.
     * @example
     * // Create many CategoriasProductos
     * const categoriasProducto = await prisma.categoriasProducto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriasProductoCreateManyArgs>(args?: SelectSubset<T, CategoriasProductoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoriasProducto.
     * @param {CategoriasProductoDeleteArgs} args - Arguments to delete one CategoriasProducto.
     * @example
     * // Delete one CategoriasProducto
     * const CategoriasProducto = await prisma.categoriasProducto.delete({
     *   where: {
     *     // ... filter to delete one CategoriasProducto
     *   }
     * })
     * 
     */
    delete<T extends CategoriasProductoDeleteArgs>(args: SelectSubset<T, CategoriasProductoDeleteArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoriasProducto.
     * @param {CategoriasProductoUpdateArgs} args - Arguments to update one CategoriasProducto.
     * @example
     * // Update one CategoriasProducto
     * const categoriasProducto = await prisma.categoriasProducto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriasProductoUpdateArgs>(args: SelectSubset<T, CategoriasProductoUpdateArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoriasProductos.
     * @param {CategoriasProductoDeleteManyArgs} args - Arguments to filter CategoriasProductos to delete.
     * @example
     * // Delete a few CategoriasProductos
     * const { count } = await prisma.categoriasProducto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriasProductoDeleteManyArgs>(args?: SelectSubset<T, CategoriasProductoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriasProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriasProductos
     * const categoriasProducto = await prisma.categoriasProducto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriasProductoUpdateManyArgs>(args: SelectSubset<T, CategoriasProductoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoriasProducto.
     * @param {CategoriasProductoUpsertArgs} args - Arguments to update or create a CategoriasProducto.
     * @example
     * // Update or create a CategoriasProducto
     * const categoriasProducto = await prisma.categoriasProducto.upsert({
     *   create: {
     *     // ... data to create a CategoriasProducto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriasProducto we want to update
     *   }
     * })
     */
    upsert<T extends CategoriasProductoUpsertArgs>(args: SelectSubset<T, CategoriasProductoUpsertArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoriasProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasProductoCountArgs} args - Arguments to filter CategoriasProductos to count.
     * @example
     * // Count the number of CategoriasProductos
     * const count = await prisma.categoriasProducto.count({
     *   where: {
     *     // ... the filter for the CategoriasProductos we want to count
     *   }
     * })
    **/
    count<T extends CategoriasProductoCountArgs>(
      args?: Subset<T, CategoriasProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriasProducto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasProductoAggregateArgs>(args: Subset<T, CategoriasProductoAggregateArgs>): Prisma.PrismaPromise<GetCategoriasProductoAggregateType<T>>

    /**
     * Group by CategoriasProducto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriasProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriasProductoGroupByArgs['orderBy'] }
        : { orderBy?: CategoriasProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriasProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoriasProducto model
   */
  readonly fields: CategoriasProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoriasProducto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriasProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Productos<T extends CategoriasProducto$ProductosArgs<ExtArgs> = {}>(args?: Subset<T, CategoriasProducto$ProductosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoriasProducto model
   */
  interface CategoriasProductoFieldRefs {
    readonly Id: FieldRef<"CategoriasProducto", 'Int'>
    readonly Code: FieldRef<"CategoriasProducto", 'String'>
    readonly Nombre: FieldRef<"CategoriasProducto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CategoriasProducto findUnique
   */
  export type CategoriasProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriasProducto to fetch.
     */
    where: CategoriasProductoWhereUniqueInput
  }

  /**
   * CategoriasProducto findUniqueOrThrow
   */
  export type CategoriasProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriasProducto to fetch.
     */
    where: CategoriasProductoWhereUniqueInput
  }

  /**
   * CategoriasProducto findFirst
   */
  export type CategoriasProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriasProducto to fetch.
     */
    where?: CategoriasProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriasProductos to fetch.
     */
    orderBy?: CategoriasProductoOrderByWithRelationInput | CategoriasProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriasProductos.
     */
    cursor?: CategoriasProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriasProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriasProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriasProductos.
     */
    distinct?: CategoriasProductoScalarFieldEnum | CategoriasProductoScalarFieldEnum[]
  }

  /**
   * CategoriasProducto findFirstOrThrow
   */
  export type CategoriasProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriasProducto to fetch.
     */
    where?: CategoriasProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriasProductos to fetch.
     */
    orderBy?: CategoriasProductoOrderByWithRelationInput | CategoriasProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriasProductos.
     */
    cursor?: CategoriasProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriasProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriasProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriasProductos.
     */
    distinct?: CategoriasProductoScalarFieldEnum | CategoriasProductoScalarFieldEnum[]
  }

  /**
   * CategoriasProducto findMany
   */
  export type CategoriasProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriasProductos to fetch.
     */
    where?: CategoriasProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriasProductos to fetch.
     */
    orderBy?: CategoriasProductoOrderByWithRelationInput | CategoriasProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoriasProductos.
     */
    cursor?: CategoriasProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriasProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriasProductos.
     */
    skip?: number
    distinct?: CategoriasProductoScalarFieldEnum | CategoriasProductoScalarFieldEnum[]
  }

  /**
   * CategoriasProducto create
   */
  export type CategoriasProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoriasProducto.
     */
    data: XOR<CategoriasProductoCreateInput, CategoriasProductoUncheckedCreateInput>
  }

  /**
   * CategoriasProducto createMany
   */
  export type CategoriasProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoriasProductos.
     */
    data: CategoriasProductoCreateManyInput | CategoriasProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoriasProducto update
   */
  export type CategoriasProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoriasProducto.
     */
    data: XOR<CategoriasProductoUpdateInput, CategoriasProductoUncheckedUpdateInput>
    /**
     * Choose, which CategoriasProducto to update.
     */
    where: CategoriasProductoWhereUniqueInput
  }

  /**
   * CategoriasProducto updateMany
   */
  export type CategoriasProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoriasProductos.
     */
    data: XOR<CategoriasProductoUpdateManyMutationInput, CategoriasProductoUncheckedUpdateManyInput>
    /**
     * Filter which CategoriasProductos to update
     */
    where?: CategoriasProductoWhereInput
    /**
     * Limit how many CategoriasProductos to update.
     */
    limit?: number
  }

  /**
   * CategoriasProducto upsert
   */
  export type CategoriasProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoriasProducto to update in case it exists.
     */
    where: CategoriasProductoWhereUniqueInput
    /**
     * In case the CategoriasProducto found by the `where` argument doesn't exist, create a new CategoriasProducto with this data.
     */
    create: XOR<CategoriasProductoCreateInput, CategoriasProductoUncheckedCreateInput>
    /**
     * In case the CategoriasProducto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriasProductoUpdateInput, CategoriasProductoUncheckedUpdateInput>
  }

  /**
   * CategoriasProducto delete
   */
  export type CategoriasProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
    /**
     * Filter which CategoriasProducto to delete.
     */
    where: CategoriasProductoWhereUniqueInput
  }

  /**
   * CategoriasProducto deleteMany
   */
  export type CategoriasProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriasProductos to delete
     */
    where?: CategoriasProductoWhereInput
    /**
     * Limit how many CategoriasProductos to delete.
     */
    limit?: number
  }

  /**
   * CategoriasProducto.Productos
   */
  export type CategoriasProducto$ProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    where?: ProductosWhereInput
    orderBy?: ProductosOrderByWithRelationInput | ProductosOrderByWithRelationInput[]
    cursor?: ProductosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * CategoriasProducto without action
   */
  export type CategoriasProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasProducto
     */
    select?: CategoriasProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoriasProducto
     */
    omit?: CategoriasProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriasProductoInclude<ExtArgs> | null
  }


  /**
   * Model Clientes
   */

  export type AggregateClientes = {
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  export type ClientesAvgAggregateOutputType = {
    Id: number | null
  }

  export type ClientesSumAggregateOutputType = {
    Id: number | null
  }

  export type ClientesMinAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    Telefono: string | null
  }

  export type ClientesMaxAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    Telefono: string | null
  }

  export type ClientesCountAggregateOutputType = {
    Id: number
    Nombre: number
    Telefono: number
    _all: number
  }


  export type ClientesAvgAggregateInputType = {
    Id?: true
  }

  export type ClientesSumAggregateInputType = {
    Id?: true
  }

  export type ClientesMinAggregateInputType = {
    Id?: true
    Nombre?: true
    Telefono?: true
  }

  export type ClientesMaxAggregateInputType = {
    Id?: true
    Nombre?: true
    Telefono?: true
  }

  export type ClientesCountAggregateInputType = {
    Id?: true
    Nombre?: true
    Telefono?: true
    _all?: true
  }

  export type ClientesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to aggregate.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientesMaxAggregateInputType
  }

  export type GetClientesAggregateType<T extends ClientesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientes[P]>
      : GetScalarType<T[P], AggregateClientes[P]>
  }




  export type ClientesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientesWhereInput
    orderBy?: ClientesOrderByWithAggregationInput | ClientesOrderByWithAggregationInput[]
    by: ClientesScalarFieldEnum[] | ClientesScalarFieldEnum
    having?: ClientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientesCountAggregateInputType | true
    _avg?: ClientesAvgAggregateInputType
    _sum?: ClientesSumAggregateInputType
    _min?: ClientesMinAggregateInputType
    _max?: ClientesMaxAggregateInputType
  }

  export type ClientesGroupByOutputType = {
    Id: number
    Nombre: string
    Telefono: string | null
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  type GetClientesGroupByPayload<T extends ClientesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientesGroupByOutputType[P]>
        }
      >
    >


  export type ClientesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Nombre?: boolean
    Telefono?: boolean
    Ventas?: boolean | Clientes$VentasArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientes"]>



  export type ClientesSelectScalar = {
    Id?: boolean
    Nombre?: boolean
    Telefono?: boolean
  }

  export type ClientesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Nombre" | "Telefono", ExtArgs["result"]["clientes"]>
  export type ClientesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ventas?: boolean | Clientes$VentasArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clientes"
    objects: {
      Ventas: Prisma.$VentasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Nombre: string
      Telefono: string | null
    }, ExtArgs["result"]["clientes"]>
    composites: {}
  }

  type ClientesGetPayload<S extends boolean | null | undefined | ClientesDefaultArgs> = $Result.GetResult<Prisma.$ClientesPayload, S>

  type ClientesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientesCountAggregateInputType | true
    }

  export interface ClientesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clientes'], meta: { name: 'Clientes' } }
    /**
     * Find zero or one Clientes that matches the filter.
     * @param {ClientesFindUniqueArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientesFindUniqueArgs>(args: SelectSubset<T, ClientesFindUniqueArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clientes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientesFindUniqueOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientesFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindFirstArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientesFindFirstArgs>(args?: SelectSubset<T, ClientesFindFirstArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clientes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindFirstOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientesFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.clientes.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.clientes.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const clientesWithIdOnly = await prisma.clientes.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends ClientesFindManyArgs>(args?: SelectSubset<T, ClientesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clientes.
     * @param {ClientesCreateArgs} args - Arguments to create a Clientes.
     * @example
     * // Create one Clientes
     * const Clientes = await prisma.clientes.create({
     *   data: {
     *     // ... data to create a Clientes
     *   }
     * })
     * 
     */
    create<T extends ClientesCreateArgs>(args: SelectSubset<T, ClientesCreateArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clientes.
     * @param {ClientesCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const clientes = await prisma.clientes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientesCreateManyArgs>(args?: SelectSubset<T, ClientesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clientes.
     * @param {ClientesDeleteArgs} args - Arguments to delete one Clientes.
     * @example
     * // Delete one Clientes
     * const Clientes = await prisma.clientes.delete({
     *   where: {
     *     // ... filter to delete one Clientes
     *   }
     * })
     * 
     */
    delete<T extends ClientesDeleteArgs>(args: SelectSubset<T, ClientesDeleteArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clientes.
     * @param {ClientesUpdateArgs} args - Arguments to update one Clientes.
     * @example
     * // Update one Clientes
     * const clientes = await prisma.clientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientesUpdateArgs>(args: SelectSubset<T, ClientesUpdateArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clientes.
     * @param {ClientesDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.clientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientesDeleteManyArgs>(args?: SelectSubset<T, ClientesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const clientes = await prisma.clientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientesUpdateManyArgs>(args: SelectSubset<T, ClientesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientes.
     * @param {ClientesUpsertArgs} args - Arguments to update or create a Clientes.
     * @example
     * // Update or create a Clientes
     * const clientes = await prisma.clientes.upsert({
     *   create: {
     *     // ... data to create a Clientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientes we want to update
     *   }
     * })
     */
    upsert<T extends ClientesUpsertArgs>(args: SelectSubset<T, ClientesUpsertArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.clientes.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClientesCountArgs>(
      args?: Subset<T, ClientesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientesAggregateArgs>(args: Subset<T, ClientesAggregateArgs>): Prisma.PrismaPromise<GetClientesAggregateType<T>>

    /**
     * Group by Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientesGroupByArgs['orderBy'] }
        : { orderBy?: ClientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clientes model
   */
  readonly fields: ClientesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ventas<T extends Clientes$VentasArgs<ExtArgs> = {}>(args?: Subset<T, Clientes$VentasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clientes model
   */
  interface ClientesFieldRefs {
    readonly Id: FieldRef<"Clientes", 'Int'>
    readonly Nombre: FieldRef<"Clientes", 'String'>
    readonly Telefono: FieldRef<"Clientes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Clientes findUnique
   */
  export type ClientesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where: ClientesWhereUniqueInput
  }

  /**
   * Clientes findUniqueOrThrow
   */
  export type ClientesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where: ClientesWhereUniqueInput
  }

  /**
   * Clientes findFirst
   */
  export type ClientesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * Clientes findFirstOrThrow
   */
  export type ClientesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * Clientes findMany
   */
  export type ClientesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * Clientes create
   */
  export type ClientesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * The data needed to create a Clientes.
     */
    data: XOR<ClientesCreateInput, ClientesUncheckedCreateInput>
  }

  /**
   * Clientes createMany
   */
  export type ClientesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClientesCreateManyInput | ClientesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clientes update
   */
  export type ClientesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * The data needed to update a Clientes.
     */
    data: XOR<ClientesUpdateInput, ClientesUncheckedUpdateInput>
    /**
     * Choose, which Clientes to update.
     */
    where: ClientesWhereUniqueInput
  }

  /**
   * Clientes updateMany
   */
  export type ClientesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClientesUpdateManyMutationInput, ClientesUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClientesWhereInput
    /**
     * Limit how many Clientes to update.
     */
    limit?: number
  }

  /**
   * Clientes upsert
   */
  export type ClientesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * The filter to search for the Clientes to update in case it exists.
     */
    where: ClientesWhereUniqueInput
    /**
     * In case the Clientes found by the `where` argument doesn't exist, create a new Clientes with this data.
     */
    create: XOR<ClientesCreateInput, ClientesUncheckedCreateInput>
    /**
     * In case the Clientes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientesUpdateInput, ClientesUncheckedUpdateInput>
  }

  /**
   * Clientes delete
   */
  export type ClientesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter which Clientes to delete.
     */
    where: ClientesWhereUniqueInput
  }

  /**
   * Clientes deleteMany
   */
  export type ClientesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClientesWhereInput
    /**
     * Limit how many Clientes to delete.
     */
    limit?: number
  }

  /**
   * Clientes.Ventas
   */
  export type Clientes$VentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    where?: VentasWhereInput
    orderBy?: VentasOrderByWithRelationInput | VentasOrderByWithRelationInput[]
    cursor?: VentasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentasScalarFieldEnum | VentasScalarFieldEnum[]
  }

  /**
   * Clientes without action
   */
  export type ClientesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
  }


  /**
   * Model Compras
   */

  export type AggregateCompras = {
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  export type ComprasAvgAggregateOutputType = {
    Id: number | null
    TipoCompraId: number | null
    ProveedorId: number | null
    ProductoId: number | null
    InsumoId: number | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
    PrecioUnitario: Decimal | null
  }

  export type ComprasSumAggregateOutputType = {
    Id: number | null
    TipoCompraId: number | null
    ProveedorId: number | null
    ProductoId: number | null
    InsumoId: number | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
    PrecioUnitario: Decimal | null
  }

  export type ComprasMinAggregateOutputType = {
    Id: number | null
    Folio: string | null
    TipoCompraId: number | null
    ProveedorId: number | null
    ProductoId: number | null
    InsumoId: number | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
    PrecioUnitario: Decimal | null
    FechaRecepcion: Date | null
    CreadoFecha: Date | null
  }

  export type ComprasMaxAggregateOutputType = {
    Id: number | null
    Folio: string | null
    TipoCompraId: number | null
    ProveedorId: number | null
    ProductoId: number | null
    InsumoId: number | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
    PrecioUnitario: Decimal | null
    FechaRecepcion: Date | null
    CreadoFecha: Date | null
  }

  export type ComprasCountAggregateOutputType = {
    Id: number
    Folio: number
    TipoCompraId: number
    ProveedorId: number
    ProductoId: number
    InsumoId: number
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: number
    PrecioUnitario: number
    FechaRecepcion: number
    CreadoFecha: number
    _all: number
  }


  export type ComprasAvgAggregateInputType = {
    Id?: true
    TipoCompraId?: true
    ProveedorId?: true
    ProductoId?: true
    InsumoId?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
    PrecioUnitario?: true
  }

  export type ComprasSumAggregateInputType = {
    Id?: true
    TipoCompraId?: true
    ProveedorId?: true
    ProductoId?: true
    InsumoId?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
    PrecioUnitario?: true
  }

  export type ComprasMinAggregateInputType = {
    Id?: true
    Folio?: true
    TipoCompraId?: true
    ProveedorId?: true
    ProductoId?: true
    InsumoId?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
    PrecioUnitario?: true
    FechaRecepcion?: true
    CreadoFecha?: true
  }

  export type ComprasMaxAggregateInputType = {
    Id?: true
    Folio?: true
    TipoCompraId?: true
    ProveedorId?: true
    ProductoId?: true
    InsumoId?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
    PrecioUnitario?: true
    FechaRecepcion?: true
    CreadoFecha?: true
  }

  export type ComprasCountAggregateInputType = {
    Id?: true
    Folio?: true
    TipoCompraId?: true
    ProveedorId?: true
    ProductoId?: true
    InsumoId?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
    PrecioUnitario?: true
    FechaRecepcion?: true
    CreadoFecha?: true
    _all?: true
  }

  export type ComprasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Compras to aggregate.
     */
    where?: ComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compras to fetch.
     */
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Compras
    **/
    _count?: true | ComprasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprasMaxAggregateInputType
  }

  export type GetComprasAggregateType<T extends ComprasAggregateArgs> = {
        [P in keyof T & keyof AggregateCompras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompras[P]>
      : GetScalarType<T[P], AggregateCompras[P]>
  }




  export type ComprasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprasWhereInput
    orderBy?: ComprasOrderByWithAggregationInput | ComprasOrderByWithAggregationInput[]
    by: ComprasScalarFieldEnum[] | ComprasScalarFieldEnum
    having?: ComprasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprasCountAggregateInputType | true
    _avg?: ComprasAvgAggregateInputType
    _sum?: ComprasSumAggregateInputType
    _min?: ComprasMinAggregateInputType
    _max?: ComprasMaxAggregateInputType
  }

  export type ComprasGroupByOutputType = {
    Id: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    ProductoId: number | null
    InsumoId: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal
    PrecioUnitario: Decimal
    FechaRecepcion: Date
    CreadoFecha: Date
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  type GetComprasGroupByPayload<T extends ComprasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprasGroupByOutputType[P]>
            : GetScalarType<T[P], ComprasGroupByOutputType[P]>
        }
      >
    >


  export type ComprasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Folio?: boolean
    TipoCompraId?: boolean
    ProveedorId?: boolean
    ProductoId?: boolean
    InsumoId?: boolean
    Cantidad?: boolean
    CantidadRecibida?: boolean
    CostoUnitario?: boolean
    PrecioUnitario?: boolean
    FechaRecepcion?: boolean
    CreadoFecha?: boolean
    TiposCompra?: boolean | TiposCompraDefaultArgs<ExtArgs>
    Proveedores?: boolean | ProveedoresDefaultArgs<ExtArgs>
    Productos?: boolean | Compras$ProductosArgs<ExtArgs>
    Insumos?: boolean | Compras$InsumosArgs<ExtArgs>
    Inventario?: boolean | Compras$InventarioArgs<ExtArgs>
    _count?: boolean | ComprasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>



  export type ComprasSelectScalar = {
    Id?: boolean
    Folio?: boolean
    TipoCompraId?: boolean
    ProveedorId?: boolean
    ProductoId?: boolean
    InsumoId?: boolean
    Cantidad?: boolean
    CantidadRecibida?: boolean
    CostoUnitario?: boolean
    PrecioUnitario?: boolean
    FechaRecepcion?: boolean
    CreadoFecha?: boolean
  }

  export type ComprasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Folio" | "TipoCompraId" | "ProveedorId" | "ProductoId" | "InsumoId" | "Cantidad" | "CantidadRecibida" | "CostoUnitario" | "PrecioUnitario" | "FechaRecepcion" | "CreadoFecha", ExtArgs["result"]["compras"]>
  export type ComprasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TiposCompra?: boolean | TiposCompraDefaultArgs<ExtArgs>
    Proveedores?: boolean | ProveedoresDefaultArgs<ExtArgs>
    Productos?: boolean | Compras$ProductosArgs<ExtArgs>
    Insumos?: boolean | Compras$InsumosArgs<ExtArgs>
    Inventario?: boolean | Compras$InventarioArgs<ExtArgs>
    _count?: boolean | ComprasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ComprasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Compras"
    objects: {
      TiposCompra: Prisma.$TiposCompraPayload<ExtArgs>
      Proveedores: Prisma.$ProveedoresPayload<ExtArgs>
      Productos: Prisma.$ProductosPayload<ExtArgs> | null
      Insumos: Prisma.$InsumosPayload<ExtArgs> | null
      Inventario: Prisma.$InventarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Folio: string
      TipoCompraId: number
      ProveedorId: number
      ProductoId: number | null
      InsumoId: number | null
      Cantidad: number
      CantidadRecibida: number
      CostoUnitario: Prisma.Decimal
      PrecioUnitario: Prisma.Decimal
      FechaRecepcion: Date
      CreadoFecha: Date
    }, ExtArgs["result"]["compras"]>
    composites: {}
  }

  type ComprasGetPayload<S extends boolean | null | undefined | ComprasDefaultArgs> = $Result.GetResult<Prisma.$ComprasPayload, S>

  type ComprasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComprasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComprasCountAggregateInputType | true
    }

  export interface ComprasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Compras'], meta: { name: 'Compras' } }
    /**
     * Find zero or one Compras that matches the filter.
     * @param {ComprasFindUniqueArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComprasFindUniqueArgs>(args: SelectSubset<T, ComprasFindUniqueArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compras that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComprasFindUniqueOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComprasFindUniqueOrThrowArgs>(args: SelectSubset<T, ComprasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasFindFirstArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComprasFindFirstArgs>(args?: SelectSubset<T, ComprasFindFirstArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasFindFirstOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComprasFindFirstOrThrowArgs>(args?: SelectSubset<T, ComprasFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compras
     * const compras = await prisma.compras.findMany()
     * 
     * // Get first 10 Compras
     * const compras = await prisma.compras.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const comprasWithIdOnly = await prisma.compras.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends ComprasFindManyArgs>(args?: SelectSubset<T, ComprasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compras.
     * @param {ComprasCreateArgs} args - Arguments to create a Compras.
     * @example
     * // Create one Compras
     * const Compras = await prisma.compras.create({
     *   data: {
     *     // ... data to create a Compras
     *   }
     * })
     * 
     */
    create<T extends ComprasCreateArgs>(args: SelectSubset<T, ComprasCreateArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Compras.
     * @param {ComprasCreateManyArgs} args - Arguments to create many Compras.
     * @example
     * // Create many Compras
     * const compras = await prisma.compras.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComprasCreateManyArgs>(args?: SelectSubset<T, ComprasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Compras.
     * @param {ComprasDeleteArgs} args - Arguments to delete one Compras.
     * @example
     * // Delete one Compras
     * const Compras = await prisma.compras.delete({
     *   where: {
     *     // ... filter to delete one Compras
     *   }
     * })
     * 
     */
    delete<T extends ComprasDeleteArgs>(args: SelectSubset<T, ComprasDeleteArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compras.
     * @param {ComprasUpdateArgs} args - Arguments to update one Compras.
     * @example
     * // Update one Compras
     * const compras = await prisma.compras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComprasUpdateArgs>(args: SelectSubset<T, ComprasUpdateArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Compras.
     * @param {ComprasDeleteManyArgs} args - Arguments to filter Compras to delete.
     * @example
     * // Delete a few Compras
     * const { count } = await prisma.compras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComprasDeleteManyArgs>(args?: SelectSubset<T, ComprasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compras
     * const compras = await prisma.compras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComprasUpdateManyArgs>(args: SelectSubset<T, ComprasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Compras.
     * @param {ComprasUpsertArgs} args - Arguments to update or create a Compras.
     * @example
     * // Update or create a Compras
     * const compras = await prisma.compras.upsert({
     *   create: {
     *     // ... data to create a Compras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compras we want to update
     *   }
     * })
     */
    upsert<T extends ComprasUpsertArgs>(args: SelectSubset<T, ComprasUpsertArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasCountArgs} args - Arguments to filter Compras to count.
     * @example
     * // Count the number of Compras
     * const count = await prisma.compras.count({
     *   where: {
     *     // ... the filter for the Compras we want to count
     *   }
     * })
    **/
    count<T extends ComprasCountArgs>(
      args?: Subset<T, ComprasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprasAggregateArgs>(args: Subset<T, ComprasAggregateArgs>): Prisma.PrismaPromise<GetComprasAggregateType<T>>

    /**
     * Group by Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComprasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComprasGroupByArgs['orderBy'] }
        : { orderBy?: ComprasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComprasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Compras model
   */
  readonly fields: ComprasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Compras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComprasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TiposCompra<T extends TiposCompraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TiposCompraDefaultArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Proveedores<T extends ProveedoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProveedoresDefaultArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Productos<T extends Compras$ProductosArgs<ExtArgs> = {}>(args?: Subset<T, Compras$ProductosArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Insumos<T extends Compras$InsumosArgs<ExtArgs> = {}>(args?: Subset<T, Compras$InsumosArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Inventario<T extends Compras$InventarioArgs<ExtArgs> = {}>(args?: Subset<T, Compras$InventarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Compras model
   */
  interface ComprasFieldRefs {
    readonly Id: FieldRef<"Compras", 'Int'>
    readonly Folio: FieldRef<"Compras", 'String'>
    readonly TipoCompraId: FieldRef<"Compras", 'Int'>
    readonly ProveedorId: FieldRef<"Compras", 'Int'>
    readonly ProductoId: FieldRef<"Compras", 'Int'>
    readonly InsumoId: FieldRef<"Compras", 'Int'>
    readonly Cantidad: FieldRef<"Compras", 'Int'>
    readonly CantidadRecibida: FieldRef<"Compras", 'Int'>
    readonly CostoUnitario: FieldRef<"Compras", 'Decimal'>
    readonly PrecioUnitario: FieldRef<"Compras", 'Decimal'>
    readonly FechaRecepcion: FieldRef<"Compras", 'DateTime'>
    readonly CreadoFecha: FieldRef<"Compras", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Compras findUnique
   */
  export type ComprasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * Filter, which Compras to fetch.
     */
    where: ComprasWhereUniqueInput
  }

  /**
   * Compras findUniqueOrThrow
   */
  export type ComprasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * Filter, which Compras to fetch.
     */
    where: ComprasWhereUniqueInput
  }

  /**
   * Compras findFirst
   */
  export type ComprasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * Filter, which Compras to fetch.
     */
    where?: ComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compras to fetch.
     */
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Compras.
     */
    cursor?: ComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * Compras findFirstOrThrow
   */
  export type ComprasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * Filter, which Compras to fetch.
     */
    where?: ComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compras to fetch.
     */
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Compras.
     */
    cursor?: ComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * Compras findMany
   */
  export type ComprasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * Filter, which Compras to fetch.
     */
    where?: ComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compras to fetch.
     */
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Compras.
     */
    cursor?: ComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compras.
     */
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * Compras create
   */
  export type ComprasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * The data needed to create a Compras.
     */
    data: XOR<ComprasCreateInput, ComprasUncheckedCreateInput>
  }

  /**
   * Compras createMany
   */
  export type ComprasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Compras.
     */
    data: ComprasCreateManyInput | ComprasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Compras update
   */
  export type ComprasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * The data needed to update a Compras.
     */
    data: XOR<ComprasUpdateInput, ComprasUncheckedUpdateInput>
    /**
     * Choose, which Compras to update.
     */
    where: ComprasWhereUniqueInput
  }

  /**
   * Compras updateMany
   */
  export type ComprasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Compras.
     */
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyInput>
    /**
     * Filter which Compras to update
     */
    where?: ComprasWhereInput
    /**
     * Limit how many Compras to update.
     */
    limit?: number
  }

  /**
   * Compras upsert
   */
  export type ComprasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * The filter to search for the Compras to update in case it exists.
     */
    where: ComprasWhereUniqueInput
    /**
     * In case the Compras found by the `where` argument doesn't exist, create a new Compras with this data.
     */
    create: XOR<ComprasCreateInput, ComprasUncheckedCreateInput>
    /**
     * In case the Compras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComprasUpdateInput, ComprasUncheckedUpdateInput>
  }

  /**
   * Compras delete
   */
  export type ComprasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    /**
     * Filter which Compras to delete.
     */
    where: ComprasWhereUniqueInput
  }

  /**
   * Compras deleteMany
   */
  export type ComprasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Compras to delete
     */
    where?: ComprasWhereInput
    /**
     * Limit how many Compras to delete.
     */
    limit?: number
  }

  /**
   * Compras.Productos
   */
  export type Compras$ProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    where?: ProductosWhereInput
  }

  /**
   * Compras.Insumos
   */
  export type Compras$InsumosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    where?: InsumosWhereInput
  }

  /**
   * Compras.Inventario
   */
  export type Compras$InventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Compras without action
   */
  export type ComprasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
  }


  /**
   * Model ImagenesProductos
   */

  export type AggregateImagenesProductos = {
    _count: ImagenesProductosCountAggregateOutputType | null
    _avg: ImagenesProductosAvgAggregateOutputType | null
    _sum: ImagenesProductosSumAggregateOutputType | null
    _min: ImagenesProductosMinAggregateOutputType | null
    _max: ImagenesProductosMaxAggregateOutputType | null
  }

  export type ImagenesProductosAvgAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
  }

  export type ImagenesProductosSumAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
  }

  export type ImagenesProductosMinAggregateOutputType = {
    Id: number | null
    URLImagen: string | null
    ProductoId: number | null
  }

  export type ImagenesProductosMaxAggregateOutputType = {
    Id: number | null
    URLImagen: string | null
    ProductoId: number | null
  }

  export type ImagenesProductosCountAggregateOutputType = {
    Id: number
    URLImagen: number
    ProductoId: number
    _all: number
  }


  export type ImagenesProductosAvgAggregateInputType = {
    Id?: true
    ProductoId?: true
  }

  export type ImagenesProductosSumAggregateInputType = {
    Id?: true
    ProductoId?: true
  }

  export type ImagenesProductosMinAggregateInputType = {
    Id?: true
    URLImagen?: true
    ProductoId?: true
  }

  export type ImagenesProductosMaxAggregateInputType = {
    Id?: true
    URLImagen?: true
    ProductoId?: true
  }

  export type ImagenesProductosCountAggregateInputType = {
    Id?: true
    URLImagen?: true
    ProductoId?: true
    _all?: true
  }

  export type ImagenesProductosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagenesProductos to aggregate.
     */
    where?: ImagenesProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenesProductos to fetch.
     */
    orderBy?: ImagenesProductosOrderByWithRelationInput | ImagenesProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImagenesProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenesProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenesProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImagenesProductos
    **/
    _count?: true | ImagenesProductosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagenesProductosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagenesProductosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagenesProductosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagenesProductosMaxAggregateInputType
  }

  export type GetImagenesProductosAggregateType<T extends ImagenesProductosAggregateArgs> = {
        [P in keyof T & keyof AggregateImagenesProductos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImagenesProductos[P]>
      : GetScalarType<T[P], AggregateImagenesProductos[P]>
  }




  export type ImagenesProductosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagenesProductosWhereInput
    orderBy?: ImagenesProductosOrderByWithAggregationInput | ImagenesProductosOrderByWithAggregationInput[]
    by: ImagenesProductosScalarFieldEnum[] | ImagenesProductosScalarFieldEnum
    having?: ImagenesProductosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagenesProductosCountAggregateInputType | true
    _avg?: ImagenesProductosAvgAggregateInputType
    _sum?: ImagenesProductosSumAggregateInputType
    _min?: ImagenesProductosMinAggregateInputType
    _max?: ImagenesProductosMaxAggregateInputType
  }

  export type ImagenesProductosGroupByOutputType = {
    Id: number
    URLImagen: string | null
    ProductoId: number
    _count: ImagenesProductosCountAggregateOutputType | null
    _avg: ImagenesProductosAvgAggregateOutputType | null
    _sum: ImagenesProductosSumAggregateOutputType | null
    _min: ImagenesProductosMinAggregateOutputType | null
    _max: ImagenesProductosMaxAggregateOutputType | null
  }

  type GetImagenesProductosGroupByPayload<T extends ImagenesProductosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagenesProductosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagenesProductosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagenesProductosGroupByOutputType[P]>
            : GetScalarType<T[P], ImagenesProductosGroupByOutputType[P]>
        }
      >
    >


  export type ImagenesProductosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    URLImagen?: boolean
    ProductoId?: boolean
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imagenesProductos"]>



  export type ImagenesProductosSelectScalar = {
    Id?: boolean
    URLImagen?: boolean
    ProductoId?: boolean
  }

  export type ImagenesProductosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "URLImagen" | "ProductoId", ExtArgs["result"]["imagenesProductos"]>
  export type ImagenesProductosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
  }

  export type $ImagenesProductosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImagenesProductos"
    objects: {
      Productos: Prisma.$ProductosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      URLImagen: string | null
      ProductoId: number
    }, ExtArgs["result"]["imagenesProductos"]>
    composites: {}
  }

  type ImagenesProductosGetPayload<S extends boolean | null | undefined | ImagenesProductosDefaultArgs> = $Result.GetResult<Prisma.$ImagenesProductosPayload, S>

  type ImagenesProductosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImagenesProductosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagenesProductosCountAggregateInputType | true
    }

  export interface ImagenesProductosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImagenesProductos'], meta: { name: 'ImagenesProductos' } }
    /**
     * Find zero or one ImagenesProductos that matches the filter.
     * @param {ImagenesProductosFindUniqueArgs} args - Arguments to find a ImagenesProductos
     * @example
     * // Get one ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImagenesProductosFindUniqueArgs>(args: SelectSubset<T, ImagenesProductosFindUniqueArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImagenesProductos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImagenesProductosFindUniqueOrThrowArgs} args - Arguments to find a ImagenesProductos
     * @example
     * // Get one ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImagenesProductosFindUniqueOrThrowArgs>(args: SelectSubset<T, ImagenesProductosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagenesProductos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenesProductosFindFirstArgs} args - Arguments to find a ImagenesProductos
     * @example
     * // Get one ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImagenesProductosFindFirstArgs>(args?: SelectSubset<T, ImagenesProductosFindFirstArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagenesProductos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenesProductosFindFirstOrThrowArgs} args - Arguments to find a ImagenesProductos
     * @example
     * // Get one ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImagenesProductosFindFirstOrThrowArgs>(args?: SelectSubset<T, ImagenesProductosFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImagenesProductos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenesProductosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.findMany()
     * 
     * // Get first 10 ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const imagenesProductosWithIdOnly = await prisma.imagenesProductos.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends ImagenesProductosFindManyArgs>(args?: SelectSubset<T, ImagenesProductosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImagenesProductos.
     * @param {ImagenesProductosCreateArgs} args - Arguments to create a ImagenesProductos.
     * @example
     * // Create one ImagenesProductos
     * const ImagenesProductos = await prisma.imagenesProductos.create({
     *   data: {
     *     // ... data to create a ImagenesProductos
     *   }
     * })
     * 
     */
    create<T extends ImagenesProductosCreateArgs>(args: SelectSubset<T, ImagenesProductosCreateArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImagenesProductos.
     * @param {ImagenesProductosCreateManyArgs} args - Arguments to create many ImagenesProductos.
     * @example
     * // Create many ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImagenesProductosCreateManyArgs>(args?: SelectSubset<T, ImagenesProductosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImagenesProductos.
     * @param {ImagenesProductosDeleteArgs} args - Arguments to delete one ImagenesProductos.
     * @example
     * // Delete one ImagenesProductos
     * const ImagenesProductos = await prisma.imagenesProductos.delete({
     *   where: {
     *     // ... filter to delete one ImagenesProductos
     *   }
     * })
     * 
     */
    delete<T extends ImagenesProductosDeleteArgs>(args: SelectSubset<T, ImagenesProductosDeleteArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImagenesProductos.
     * @param {ImagenesProductosUpdateArgs} args - Arguments to update one ImagenesProductos.
     * @example
     * // Update one ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImagenesProductosUpdateArgs>(args: SelectSubset<T, ImagenesProductosUpdateArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImagenesProductos.
     * @param {ImagenesProductosDeleteManyArgs} args - Arguments to filter ImagenesProductos to delete.
     * @example
     * // Delete a few ImagenesProductos
     * const { count } = await prisma.imagenesProductos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImagenesProductosDeleteManyArgs>(args?: SelectSubset<T, ImagenesProductosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImagenesProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenesProductosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImagenesProductosUpdateManyArgs>(args: SelectSubset<T, ImagenesProductosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImagenesProductos.
     * @param {ImagenesProductosUpsertArgs} args - Arguments to update or create a ImagenesProductos.
     * @example
     * // Update or create a ImagenesProductos
     * const imagenesProductos = await prisma.imagenesProductos.upsert({
     *   create: {
     *     // ... data to create a ImagenesProductos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImagenesProductos we want to update
     *   }
     * })
     */
    upsert<T extends ImagenesProductosUpsertArgs>(args: SelectSubset<T, ImagenesProductosUpsertArgs<ExtArgs>>): Prisma__ImagenesProductosClient<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImagenesProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenesProductosCountArgs} args - Arguments to filter ImagenesProductos to count.
     * @example
     * // Count the number of ImagenesProductos
     * const count = await prisma.imagenesProductos.count({
     *   where: {
     *     // ... the filter for the ImagenesProductos we want to count
     *   }
     * })
    **/
    count<T extends ImagenesProductosCountArgs>(
      args?: Subset<T, ImagenesProductosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagenesProductosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImagenesProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenesProductosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagenesProductosAggregateArgs>(args: Subset<T, ImagenesProductosAggregateArgs>): Prisma.PrismaPromise<GetImagenesProductosAggregateType<T>>

    /**
     * Group by ImagenesProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenesProductosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagenesProductosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagenesProductosGroupByArgs['orderBy'] }
        : { orderBy?: ImagenesProductosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagenesProductosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagenesProductosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImagenesProductos model
   */
  readonly fields: ImagenesProductosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImagenesProductos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImagenesProductosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Productos<T extends ProductosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductosDefaultArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImagenesProductos model
   */
  interface ImagenesProductosFieldRefs {
    readonly Id: FieldRef<"ImagenesProductos", 'Int'>
    readonly URLImagen: FieldRef<"ImagenesProductos", 'String'>
    readonly ProductoId: FieldRef<"ImagenesProductos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ImagenesProductos findUnique
   */
  export type ImagenesProductosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * Filter, which ImagenesProductos to fetch.
     */
    where: ImagenesProductosWhereUniqueInput
  }

  /**
   * ImagenesProductos findUniqueOrThrow
   */
  export type ImagenesProductosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * Filter, which ImagenesProductos to fetch.
     */
    where: ImagenesProductosWhereUniqueInput
  }

  /**
   * ImagenesProductos findFirst
   */
  export type ImagenesProductosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * Filter, which ImagenesProductos to fetch.
     */
    where?: ImagenesProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenesProductos to fetch.
     */
    orderBy?: ImagenesProductosOrderByWithRelationInput | ImagenesProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagenesProductos.
     */
    cursor?: ImagenesProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenesProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenesProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagenesProductos.
     */
    distinct?: ImagenesProductosScalarFieldEnum | ImagenesProductosScalarFieldEnum[]
  }

  /**
   * ImagenesProductos findFirstOrThrow
   */
  export type ImagenesProductosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * Filter, which ImagenesProductos to fetch.
     */
    where?: ImagenesProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenesProductos to fetch.
     */
    orderBy?: ImagenesProductosOrderByWithRelationInput | ImagenesProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagenesProductos.
     */
    cursor?: ImagenesProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenesProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenesProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagenesProductos.
     */
    distinct?: ImagenesProductosScalarFieldEnum | ImagenesProductosScalarFieldEnum[]
  }

  /**
   * ImagenesProductos findMany
   */
  export type ImagenesProductosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * Filter, which ImagenesProductos to fetch.
     */
    where?: ImagenesProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenesProductos to fetch.
     */
    orderBy?: ImagenesProductosOrderByWithRelationInput | ImagenesProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImagenesProductos.
     */
    cursor?: ImagenesProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenesProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenesProductos.
     */
    skip?: number
    distinct?: ImagenesProductosScalarFieldEnum | ImagenesProductosScalarFieldEnum[]
  }

  /**
   * ImagenesProductos create
   */
  export type ImagenesProductosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * The data needed to create a ImagenesProductos.
     */
    data: XOR<ImagenesProductosCreateInput, ImagenesProductosUncheckedCreateInput>
  }

  /**
   * ImagenesProductos createMany
   */
  export type ImagenesProductosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImagenesProductos.
     */
    data: ImagenesProductosCreateManyInput | ImagenesProductosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImagenesProductos update
   */
  export type ImagenesProductosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * The data needed to update a ImagenesProductos.
     */
    data: XOR<ImagenesProductosUpdateInput, ImagenesProductosUncheckedUpdateInput>
    /**
     * Choose, which ImagenesProductos to update.
     */
    where: ImagenesProductosWhereUniqueInput
  }

  /**
   * ImagenesProductos updateMany
   */
  export type ImagenesProductosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImagenesProductos.
     */
    data: XOR<ImagenesProductosUpdateManyMutationInput, ImagenesProductosUncheckedUpdateManyInput>
    /**
     * Filter which ImagenesProductos to update
     */
    where?: ImagenesProductosWhereInput
    /**
     * Limit how many ImagenesProductos to update.
     */
    limit?: number
  }

  /**
   * ImagenesProductos upsert
   */
  export type ImagenesProductosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * The filter to search for the ImagenesProductos to update in case it exists.
     */
    where: ImagenesProductosWhereUniqueInput
    /**
     * In case the ImagenesProductos found by the `where` argument doesn't exist, create a new ImagenesProductos with this data.
     */
    create: XOR<ImagenesProductosCreateInput, ImagenesProductosUncheckedCreateInput>
    /**
     * In case the ImagenesProductos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImagenesProductosUpdateInput, ImagenesProductosUncheckedUpdateInput>
  }

  /**
   * ImagenesProductos delete
   */
  export type ImagenesProductosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    /**
     * Filter which ImagenesProductos to delete.
     */
    where: ImagenesProductosWhereUniqueInput
  }

  /**
   * ImagenesProductos deleteMany
   */
  export type ImagenesProductosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagenesProductos to delete
     */
    where?: ImagenesProductosWhereInput
    /**
     * Limit how many ImagenesProductos to delete.
     */
    limit?: number
  }

  /**
   * ImagenesProductos without action
   */
  export type ImagenesProductosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
  }


  /**
   * Model Insumos
   */

  export type AggregateInsumos = {
    _count: InsumosCountAggregateOutputType | null
    _avg: InsumosAvgAggregateOutputType | null
    _sum: InsumosSumAggregateOutputType | null
    _min: InsumosMinAggregateOutputType | null
    _max: InsumosMaxAggregateOutputType | null
  }

  export type InsumosAvgAggregateOutputType = {
    Id: number | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
  }

  export type InsumosSumAggregateOutputType = {
    Id: number | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
  }

  export type InsumosMinAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    Descripcion: string | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
  }

  export type InsumosMaxAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    Descripcion: string | null
    Cantidad: number | null
    CantidadRecibida: number | null
    CostoUnitario: Decimal | null
  }

  export type InsumosCountAggregateOutputType = {
    Id: number
    Nombre: number
    Descripcion: number
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: number
    _all: number
  }


  export type InsumosAvgAggregateInputType = {
    Id?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
  }

  export type InsumosSumAggregateInputType = {
    Id?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
  }

  export type InsumosMinAggregateInputType = {
    Id?: true
    Nombre?: true
    Descripcion?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
  }

  export type InsumosMaxAggregateInputType = {
    Id?: true
    Nombre?: true
    Descripcion?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
  }

  export type InsumosCountAggregateInputType = {
    Id?: true
    Nombre?: true
    Descripcion?: true
    Cantidad?: true
    CantidadRecibida?: true
    CostoUnitario?: true
    _all?: true
  }

  export type InsumosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insumos to aggregate.
     */
    where?: InsumosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insumos to fetch.
     */
    orderBy?: InsumosOrderByWithRelationInput | InsumosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsumosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insumos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insumos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insumos
    **/
    _count?: true | InsumosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsumosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsumosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsumosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsumosMaxAggregateInputType
  }

  export type GetInsumosAggregateType<T extends InsumosAggregateArgs> = {
        [P in keyof T & keyof AggregateInsumos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsumos[P]>
      : GetScalarType<T[P], AggregateInsumos[P]>
  }




  export type InsumosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsumosWhereInput
    orderBy?: InsumosOrderByWithAggregationInput | InsumosOrderByWithAggregationInput[]
    by: InsumosScalarFieldEnum[] | InsumosScalarFieldEnum
    having?: InsumosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsumosCountAggregateInputType | true
    _avg?: InsumosAvgAggregateInputType
    _sum?: InsumosSumAggregateInputType
    _min?: InsumosMinAggregateInputType
    _max?: InsumosMaxAggregateInputType
  }

  export type InsumosGroupByOutputType = {
    Id: number
    Nombre: string
    Descripcion: string | null
    Cantidad: number
    CantidadRecibida: number | null
    CostoUnitario: Decimal
    _count: InsumosCountAggregateOutputType | null
    _avg: InsumosAvgAggregateOutputType | null
    _sum: InsumosSumAggregateOutputType | null
    _min: InsumosMinAggregateOutputType | null
    _max: InsumosMaxAggregateOutputType | null
  }

  type GetInsumosGroupByPayload<T extends InsumosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsumosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsumosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsumosGroupByOutputType[P]>
            : GetScalarType<T[P], InsumosGroupByOutputType[P]>
        }
      >
    >


  export type InsumosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Nombre?: boolean
    Descripcion?: boolean
    Cantidad?: boolean
    CantidadRecibida?: boolean
    CostoUnitario?: boolean
    Compras?: boolean | Insumos$ComprasArgs<ExtArgs>
    _count?: boolean | InsumosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insumos"]>



  export type InsumosSelectScalar = {
    Id?: boolean
    Nombre?: boolean
    Descripcion?: boolean
    Cantidad?: boolean
    CantidadRecibida?: boolean
    CostoUnitario?: boolean
  }

  export type InsumosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Nombre" | "Descripcion" | "Cantidad" | "CantidadRecibida" | "CostoUnitario", ExtArgs["result"]["insumos"]>
  export type InsumosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | Insumos$ComprasArgs<ExtArgs>
    _count?: boolean | InsumosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InsumosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Insumos"
    objects: {
      Compras: Prisma.$ComprasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Nombre: string
      Descripcion: string | null
      Cantidad: number
      CantidadRecibida: number | null
      CostoUnitario: Prisma.Decimal
    }, ExtArgs["result"]["insumos"]>
    composites: {}
  }

  type InsumosGetPayload<S extends boolean | null | undefined | InsumosDefaultArgs> = $Result.GetResult<Prisma.$InsumosPayload, S>

  type InsumosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsumosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsumosCountAggregateInputType | true
    }

  export interface InsumosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insumos'], meta: { name: 'Insumos' } }
    /**
     * Find zero or one Insumos that matches the filter.
     * @param {InsumosFindUniqueArgs} args - Arguments to find a Insumos
     * @example
     * // Get one Insumos
     * const insumos = await prisma.insumos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsumosFindUniqueArgs>(args: SelectSubset<T, InsumosFindUniqueArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Insumos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsumosFindUniqueOrThrowArgs} args - Arguments to find a Insumos
     * @example
     * // Get one Insumos
     * const insumos = await prisma.insumos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsumosFindUniqueOrThrowArgs>(args: SelectSubset<T, InsumosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Insumos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsumosFindFirstArgs} args - Arguments to find a Insumos
     * @example
     * // Get one Insumos
     * const insumos = await prisma.insumos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsumosFindFirstArgs>(args?: SelectSubset<T, InsumosFindFirstArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Insumos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsumosFindFirstOrThrowArgs} args - Arguments to find a Insumos
     * @example
     * // Get one Insumos
     * const insumos = await prisma.insumos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsumosFindFirstOrThrowArgs>(args?: SelectSubset<T, InsumosFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Insumos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsumosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insumos
     * const insumos = await prisma.insumos.findMany()
     * 
     * // Get first 10 Insumos
     * const insumos = await prisma.insumos.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const insumosWithIdOnly = await prisma.insumos.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends InsumosFindManyArgs>(args?: SelectSubset<T, InsumosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Insumos.
     * @param {InsumosCreateArgs} args - Arguments to create a Insumos.
     * @example
     * // Create one Insumos
     * const Insumos = await prisma.insumos.create({
     *   data: {
     *     // ... data to create a Insumos
     *   }
     * })
     * 
     */
    create<T extends InsumosCreateArgs>(args: SelectSubset<T, InsumosCreateArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Insumos.
     * @param {InsumosCreateManyArgs} args - Arguments to create many Insumos.
     * @example
     * // Create many Insumos
     * const insumos = await prisma.insumos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsumosCreateManyArgs>(args?: SelectSubset<T, InsumosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Insumos.
     * @param {InsumosDeleteArgs} args - Arguments to delete one Insumos.
     * @example
     * // Delete one Insumos
     * const Insumos = await prisma.insumos.delete({
     *   where: {
     *     // ... filter to delete one Insumos
     *   }
     * })
     * 
     */
    delete<T extends InsumosDeleteArgs>(args: SelectSubset<T, InsumosDeleteArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Insumos.
     * @param {InsumosUpdateArgs} args - Arguments to update one Insumos.
     * @example
     * // Update one Insumos
     * const insumos = await prisma.insumos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsumosUpdateArgs>(args: SelectSubset<T, InsumosUpdateArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Insumos.
     * @param {InsumosDeleteManyArgs} args - Arguments to filter Insumos to delete.
     * @example
     * // Delete a few Insumos
     * const { count } = await prisma.insumos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsumosDeleteManyArgs>(args?: SelectSubset<T, InsumosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insumos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsumosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insumos
     * const insumos = await prisma.insumos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsumosUpdateManyArgs>(args: SelectSubset<T, InsumosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insumos.
     * @param {InsumosUpsertArgs} args - Arguments to update or create a Insumos.
     * @example
     * // Update or create a Insumos
     * const insumos = await prisma.insumos.upsert({
     *   create: {
     *     // ... data to create a Insumos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insumos we want to update
     *   }
     * })
     */
    upsert<T extends InsumosUpsertArgs>(args: SelectSubset<T, InsumosUpsertArgs<ExtArgs>>): Prisma__InsumosClient<$Result.GetResult<Prisma.$InsumosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Insumos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsumosCountArgs} args - Arguments to filter Insumos to count.
     * @example
     * // Count the number of Insumos
     * const count = await prisma.insumos.count({
     *   where: {
     *     // ... the filter for the Insumos we want to count
     *   }
     * })
    **/
    count<T extends InsumosCountArgs>(
      args?: Subset<T, InsumosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsumosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insumos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsumosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsumosAggregateArgs>(args: Subset<T, InsumosAggregateArgs>): Prisma.PrismaPromise<GetInsumosAggregateType<T>>

    /**
     * Group by Insumos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsumosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsumosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsumosGroupByArgs['orderBy'] }
        : { orderBy?: InsumosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsumosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsumosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Insumos model
   */
  readonly fields: InsumosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Insumos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsumosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Compras<T extends Insumos$ComprasArgs<ExtArgs> = {}>(args?: Subset<T, Insumos$ComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Insumos model
   */
  interface InsumosFieldRefs {
    readonly Id: FieldRef<"Insumos", 'Int'>
    readonly Nombre: FieldRef<"Insumos", 'String'>
    readonly Descripcion: FieldRef<"Insumos", 'String'>
    readonly Cantidad: FieldRef<"Insumos", 'Int'>
    readonly CantidadRecibida: FieldRef<"Insumos", 'Int'>
    readonly CostoUnitario: FieldRef<"Insumos", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Insumos findUnique
   */
  export type InsumosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * Filter, which Insumos to fetch.
     */
    where: InsumosWhereUniqueInput
  }

  /**
   * Insumos findUniqueOrThrow
   */
  export type InsumosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * Filter, which Insumos to fetch.
     */
    where: InsumosWhereUniqueInput
  }

  /**
   * Insumos findFirst
   */
  export type InsumosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * Filter, which Insumos to fetch.
     */
    where?: InsumosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insumos to fetch.
     */
    orderBy?: InsumosOrderByWithRelationInput | InsumosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insumos.
     */
    cursor?: InsumosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insumos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insumos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insumos.
     */
    distinct?: InsumosScalarFieldEnum | InsumosScalarFieldEnum[]
  }

  /**
   * Insumos findFirstOrThrow
   */
  export type InsumosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * Filter, which Insumos to fetch.
     */
    where?: InsumosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insumos to fetch.
     */
    orderBy?: InsumosOrderByWithRelationInput | InsumosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insumos.
     */
    cursor?: InsumosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insumos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insumos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insumos.
     */
    distinct?: InsumosScalarFieldEnum | InsumosScalarFieldEnum[]
  }

  /**
   * Insumos findMany
   */
  export type InsumosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * Filter, which Insumos to fetch.
     */
    where?: InsumosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insumos to fetch.
     */
    orderBy?: InsumosOrderByWithRelationInput | InsumosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insumos.
     */
    cursor?: InsumosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insumos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insumos.
     */
    skip?: number
    distinct?: InsumosScalarFieldEnum | InsumosScalarFieldEnum[]
  }

  /**
   * Insumos create
   */
  export type InsumosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * The data needed to create a Insumos.
     */
    data: XOR<InsumosCreateInput, InsumosUncheckedCreateInput>
  }

  /**
   * Insumos createMany
   */
  export type InsumosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insumos.
     */
    data: InsumosCreateManyInput | InsumosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insumos update
   */
  export type InsumosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * The data needed to update a Insumos.
     */
    data: XOR<InsumosUpdateInput, InsumosUncheckedUpdateInput>
    /**
     * Choose, which Insumos to update.
     */
    where: InsumosWhereUniqueInput
  }

  /**
   * Insumos updateMany
   */
  export type InsumosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insumos.
     */
    data: XOR<InsumosUpdateManyMutationInput, InsumosUncheckedUpdateManyInput>
    /**
     * Filter which Insumos to update
     */
    where?: InsumosWhereInput
    /**
     * Limit how many Insumos to update.
     */
    limit?: number
  }

  /**
   * Insumos upsert
   */
  export type InsumosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * The filter to search for the Insumos to update in case it exists.
     */
    where: InsumosWhereUniqueInput
    /**
     * In case the Insumos found by the `where` argument doesn't exist, create a new Insumos with this data.
     */
    create: XOR<InsumosCreateInput, InsumosUncheckedCreateInput>
    /**
     * In case the Insumos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsumosUpdateInput, InsumosUncheckedUpdateInput>
  }

  /**
   * Insumos delete
   */
  export type InsumosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
    /**
     * Filter which Insumos to delete.
     */
    where: InsumosWhereUniqueInput
  }

  /**
   * Insumos deleteMany
   */
  export type InsumosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insumos to delete
     */
    where?: InsumosWhereInput
    /**
     * Limit how many Insumos to delete.
     */
    limit?: number
  }

  /**
   * Insumos.Compras
   */
  export type Insumos$ComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    where?: ComprasWhereInput
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    cursor?: ComprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * Insumos without action
   */
  export type InsumosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insumos
     */
    select?: InsumosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Insumos
     */
    omit?: InsumosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsumosInclude<ExtArgs> | null
  }


  /**
   * Model Inventario
   */

  export type AggregateInventario = {
    _count: InventarioCountAggregateOutputType | null
    _avg: InventarioAvgAggregateOutputType | null
    _sum: InventarioSumAggregateOutputType | null
    _min: InventarioMinAggregateOutputType | null
    _max: InventarioMaxAggregateOutputType | null
  }

  export type InventarioAvgAggregateOutputType = {
    Id: number | null
    CompraId: number | null
    ProductoId: number | null
    CantidadRecibida: number | null
    AlmacenActualId: number | null
    SurtidoPorAlmacenId: number | null
    RecibidoPorAlmacenId: number | null
    CreadoPor: number | null
  }

  export type InventarioSumAggregateOutputType = {
    Id: number | null
    CompraId: number | null
    ProductoId: number | null
    CantidadRecibida: number | null
    AlmacenActualId: number | null
    SurtidoPorAlmacenId: number | null
    RecibidoPorAlmacenId: number | null
    CreadoPor: number | null
  }

  export type InventarioMinAggregateOutputType = {
    Id: number | null
    CompraId: number | null
    ProductoId: number | null
    CantidadRecibida: number | null
    AlmacenActualId: number | null
    FechaSurtido: Date | null
    SurtidoPorAlmacenId: number | null
    RecibidoPorAlmacenId: number | null
    CreadoFecha: Date | null
    CreadoPor: number | null
  }

  export type InventarioMaxAggregateOutputType = {
    Id: number | null
    CompraId: number | null
    ProductoId: number | null
    CantidadRecibida: number | null
    AlmacenActualId: number | null
    FechaSurtido: Date | null
    SurtidoPorAlmacenId: number | null
    RecibidoPorAlmacenId: number | null
    CreadoFecha: Date | null
    CreadoPor: number | null
  }

  export type InventarioCountAggregateOutputType = {
    Id: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: number
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: number
    CreadoPor: number
    _all: number
  }


  export type InventarioAvgAggregateInputType = {
    Id?: true
    CompraId?: true
    ProductoId?: true
    CantidadRecibida?: true
    AlmacenActualId?: true
    SurtidoPorAlmacenId?: true
    RecibidoPorAlmacenId?: true
    CreadoPor?: true
  }

  export type InventarioSumAggregateInputType = {
    Id?: true
    CompraId?: true
    ProductoId?: true
    CantidadRecibida?: true
    AlmacenActualId?: true
    SurtidoPorAlmacenId?: true
    RecibidoPorAlmacenId?: true
    CreadoPor?: true
  }

  export type InventarioMinAggregateInputType = {
    Id?: true
    CompraId?: true
    ProductoId?: true
    CantidadRecibida?: true
    AlmacenActualId?: true
    FechaSurtido?: true
    SurtidoPorAlmacenId?: true
    RecibidoPorAlmacenId?: true
    CreadoFecha?: true
    CreadoPor?: true
  }

  export type InventarioMaxAggregateInputType = {
    Id?: true
    CompraId?: true
    ProductoId?: true
    CantidadRecibida?: true
    AlmacenActualId?: true
    FechaSurtido?: true
    SurtidoPorAlmacenId?: true
    RecibidoPorAlmacenId?: true
    CreadoFecha?: true
    CreadoPor?: true
  }

  export type InventarioCountAggregateInputType = {
    Id?: true
    CompraId?: true
    ProductoId?: true
    CantidadRecibida?: true
    AlmacenActualId?: true
    FechaSurtido?: true
    SurtidoPorAlmacenId?: true
    RecibidoPorAlmacenId?: true
    CreadoFecha?: true
    CreadoPor?: true
    _all?: true
  }

  export type InventarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventario to aggregate.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventarios
    **/
    _count?: true | InventarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventarioMaxAggregateInputType
  }

  export type GetInventarioAggregateType<T extends InventarioAggregateArgs> = {
        [P in keyof T & keyof AggregateInventario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventario[P]>
      : GetScalarType<T[P], AggregateInventario[P]>
  }




  export type InventarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithAggregationInput | InventarioOrderByWithAggregationInput[]
    by: InventarioScalarFieldEnum[] | InventarioScalarFieldEnum
    having?: InventarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventarioCountAggregateInputType | true
    _avg?: InventarioAvgAggregateInputType
    _sum?: InventarioSumAggregateInputType
    _min?: InventarioMinAggregateInputType
    _max?: InventarioMaxAggregateInputType
  }

  export type InventarioGroupByOutputType = {
    Id: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date
    CreadoPor: number
    _count: InventarioCountAggregateOutputType | null
    _avg: InventarioAvgAggregateOutputType | null
    _sum: InventarioSumAggregateOutputType | null
    _min: InventarioMinAggregateOutputType | null
    _max: InventarioMaxAggregateOutputType | null
  }

  type GetInventarioGroupByPayload<T extends InventarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventarioGroupByOutputType[P]>
            : GetScalarType<T[P], InventarioGroupByOutputType[P]>
        }
      >
    >


  export type InventarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    CompraId?: boolean
    ProductoId?: boolean
    CantidadRecibida?: boolean
    AlmacenActualId?: boolean
    FechaSurtido?: boolean
    SurtidoPorAlmacenId?: boolean
    RecibidoPorAlmacenId?: boolean
    CreadoFecha?: boolean
    CreadoPor?: boolean
    Compras?: boolean | ComprasDefaultArgs<ExtArgs>
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: boolean | AlmacenesDefaultArgs<ExtArgs>
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: boolean | AlmacenesDefaultArgs<ExtArgs>
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: boolean | AlmacenesDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventario"]>



  export type InventarioSelectScalar = {
    Id?: boolean
    CompraId?: boolean
    ProductoId?: boolean
    CantidadRecibida?: boolean
    AlmacenActualId?: boolean
    FechaSurtido?: boolean
    SurtidoPorAlmacenId?: boolean
    RecibidoPorAlmacenId?: boolean
    CreadoFecha?: boolean
    CreadoPor?: boolean
  }

  export type InventarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "CompraId" | "ProductoId" | "CantidadRecibida" | "AlmacenActualId" | "FechaSurtido" | "SurtidoPorAlmacenId" | "RecibidoPorAlmacenId" | "CreadoFecha" | "CreadoPor", ExtArgs["result"]["inventario"]>
  export type InventarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | ComprasDefaultArgs<ExtArgs>
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: boolean | AlmacenesDefaultArgs<ExtArgs>
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: boolean | AlmacenesDefaultArgs<ExtArgs>
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: boolean | AlmacenesDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuariosDefaultArgs<ExtArgs>
  }

  export type $InventarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventario"
    objects: {
      Compras: Prisma.$ComprasPayload<ExtArgs>
      Productos: Prisma.$ProductosPayload<ExtArgs>
      Almacenes_Inventario_AlmacenActualIdToAlmacenes: Prisma.$AlmacenesPayload<ExtArgs>
      Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes: Prisma.$AlmacenesPayload<ExtArgs>
      Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes: Prisma.$AlmacenesPayload<ExtArgs>
      Usuarios: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      CompraId: number
      ProductoId: number
      CantidadRecibida: number
      AlmacenActualId: number
      FechaSurtido: Date
      SurtidoPorAlmacenId: number
      RecibidoPorAlmacenId: number
      CreadoFecha: Date
      CreadoPor: number
    }, ExtArgs["result"]["inventario"]>
    composites: {}
  }

  type InventarioGetPayload<S extends boolean | null | undefined | InventarioDefaultArgs> = $Result.GetResult<Prisma.$InventarioPayload, S>

  type InventarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventarioCountAggregateInputType | true
    }

  export interface InventarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventario'], meta: { name: 'Inventario' } }
    /**
     * Find zero or one Inventario that matches the filter.
     * @param {InventarioFindUniqueArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventarioFindUniqueArgs>(args: SelectSubset<T, InventarioFindUniqueArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventarioFindUniqueOrThrowArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventarioFindUniqueOrThrowArgs>(args: SelectSubset<T, InventarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioFindFirstArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventarioFindFirstArgs>(args?: SelectSubset<T, InventarioFindFirstArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioFindFirstOrThrowArgs} args - Arguments to find a Inventario
     * @example
     * // Get one Inventario
     * const inventario = await prisma.inventario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventarioFindFirstOrThrowArgs>(args?: SelectSubset<T, InventarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventarios
     * const inventarios = await prisma.inventario.findMany()
     * 
     * // Get first 10 Inventarios
     * const inventarios = await prisma.inventario.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const inventarioWithIdOnly = await prisma.inventario.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends InventarioFindManyArgs>(args?: SelectSubset<T, InventarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventario.
     * @param {InventarioCreateArgs} args - Arguments to create a Inventario.
     * @example
     * // Create one Inventario
     * const Inventario = await prisma.inventario.create({
     *   data: {
     *     // ... data to create a Inventario
     *   }
     * })
     * 
     */
    create<T extends InventarioCreateArgs>(args: SelectSubset<T, InventarioCreateArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventarios.
     * @param {InventarioCreateManyArgs} args - Arguments to create many Inventarios.
     * @example
     * // Create many Inventarios
     * const inventario = await prisma.inventario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventarioCreateManyArgs>(args?: SelectSubset<T, InventarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventario.
     * @param {InventarioDeleteArgs} args - Arguments to delete one Inventario.
     * @example
     * // Delete one Inventario
     * const Inventario = await prisma.inventario.delete({
     *   where: {
     *     // ... filter to delete one Inventario
     *   }
     * })
     * 
     */
    delete<T extends InventarioDeleteArgs>(args: SelectSubset<T, InventarioDeleteArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventario.
     * @param {InventarioUpdateArgs} args - Arguments to update one Inventario.
     * @example
     * // Update one Inventario
     * const inventario = await prisma.inventario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventarioUpdateArgs>(args: SelectSubset<T, InventarioUpdateArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventarios.
     * @param {InventarioDeleteManyArgs} args - Arguments to filter Inventarios to delete.
     * @example
     * // Delete a few Inventarios
     * const { count } = await prisma.inventario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventarioDeleteManyArgs>(args?: SelectSubset<T, InventarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventarios
     * const inventario = await prisma.inventario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventarioUpdateManyArgs>(args: SelectSubset<T, InventarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventario.
     * @param {InventarioUpsertArgs} args - Arguments to update or create a Inventario.
     * @example
     * // Update or create a Inventario
     * const inventario = await prisma.inventario.upsert({
     *   create: {
     *     // ... data to create a Inventario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventario we want to update
     *   }
     * })
     */
    upsert<T extends InventarioUpsertArgs>(args: SelectSubset<T, InventarioUpsertArgs<ExtArgs>>): Prisma__InventarioClient<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioCountArgs} args - Arguments to filter Inventarios to count.
     * @example
     * // Count the number of Inventarios
     * const count = await prisma.inventario.count({
     *   where: {
     *     // ... the filter for the Inventarios we want to count
     *   }
     * })
    **/
    count<T extends InventarioCountArgs>(
      args?: Subset<T, InventarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventarioAggregateArgs>(args: Subset<T, InventarioAggregateArgs>): Prisma.PrismaPromise<GetInventarioAggregateType<T>>

    /**
     * Group by Inventario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventarioGroupByArgs['orderBy'] }
        : { orderBy?: InventarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventario model
   */
  readonly fields: InventarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Compras<T extends ComprasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComprasDefaultArgs<ExtArgs>>): Prisma__ComprasClient<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Productos<T extends ProductosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductosDefaultArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Almacenes_Inventario_AlmacenActualIdToAlmacenes<T extends AlmacenesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlmacenesDefaultArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes<T extends AlmacenesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlmacenesDefaultArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes<T extends AlmacenesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlmacenesDefaultArgs<ExtArgs>>): Prisma__AlmacenesClient<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuarios<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventario model
   */
  interface InventarioFieldRefs {
    readonly Id: FieldRef<"Inventario", 'Int'>
    readonly CompraId: FieldRef<"Inventario", 'Int'>
    readonly ProductoId: FieldRef<"Inventario", 'Int'>
    readonly CantidadRecibida: FieldRef<"Inventario", 'Int'>
    readonly AlmacenActualId: FieldRef<"Inventario", 'Int'>
    readonly FechaSurtido: FieldRef<"Inventario", 'DateTime'>
    readonly SurtidoPorAlmacenId: FieldRef<"Inventario", 'Int'>
    readonly RecibidoPorAlmacenId: FieldRef<"Inventario", 'Int'>
    readonly CreadoFecha: FieldRef<"Inventario", 'DateTime'>
    readonly CreadoPor: FieldRef<"Inventario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Inventario findUnique
   */
  export type InventarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where: InventarioWhereUniqueInput
  }

  /**
   * Inventario findUniqueOrThrow
   */
  export type InventarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where: InventarioWhereUniqueInput
  }

  /**
   * Inventario findFirst
   */
  export type InventarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventarios.
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventarios.
     */
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Inventario findFirstOrThrow
   */
  export type InventarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventario to fetch.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventarios.
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventarios.
     */
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Inventario findMany
   */
  export type InventarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter, which Inventarios to fetch.
     */
    where?: InventarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarios to fetch.
     */
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventarios.
     */
    cursor?: InventarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarios.
     */
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Inventario create
   */
  export type InventarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventario.
     */
    data: XOR<InventarioCreateInput, InventarioUncheckedCreateInput>
  }

  /**
   * Inventario createMany
   */
  export type InventarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventarios.
     */
    data: InventarioCreateManyInput | InventarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventario update
   */
  export type InventarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventario.
     */
    data: XOR<InventarioUpdateInput, InventarioUncheckedUpdateInput>
    /**
     * Choose, which Inventario to update.
     */
    where: InventarioWhereUniqueInput
  }

  /**
   * Inventario updateMany
   */
  export type InventarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventarios.
     */
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyInput>
    /**
     * Filter which Inventarios to update
     */
    where?: InventarioWhereInput
    /**
     * Limit how many Inventarios to update.
     */
    limit?: number
  }

  /**
   * Inventario upsert
   */
  export type InventarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventario to update in case it exists.
     */
    where: InventarioWhereUniqueInput
    /**
     * In case the Inventario found by the `where` argument doesn't exist, create a new Inventario with this data.
     */
    create: XOR<InventarioCreateInput, InventarioUncheckedCreateInput>
    /**
     * In case the Inventario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventarioUpdateInput, InventarioUncheckedUpdateInput>
  }

  /**
   * Inventario delete
   */
  export type InventarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    /**
     * Filter which Inventario to delete.
     */
    where: InventarioWhereUniqueInput
  }

  /**
   * Inventario deleteMany
   */
  export type InventarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventarios to delete
     */
    where?: InventarioWhereInput
    /**
     * Limit how many Inventarios to delete.
     */
    limit?: number
  }

  /**
   * Inventario without action
   */
  export type InventarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
  }


  /**
   * Model ListasPrecios
   */

  export type AggregateListasPrecios = {
    _count: ListasPreciosCountAggregateOutputType | null
    _avg: ListasPreciosAvgAggregateOutputType | null
    _sum: ListasPreciosSumAggregateOutputType | null
    _min: ListasPreciosMinAggregateOutputType | null
    _max: ListasPreciosMaxAggregateOutputType | null
  }

  export type ListasPreciosAvgAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
    UnidadMedidaId: number | null
    CostoUnitario: Decimal | null
    Utilidad: Decimal | null
    PrecioUnitario: Decimal | null
  }

  export type ListasPreciosSumAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
    UnidadMedidaId: number | null
    CostoUnitario: Decimal | null
    Utilidad: Decimal | null
    PrecioUnitario: Decimal | null
  }

  export type ListasPreciosMinAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
    UnidadMedidaId: number | null
    CostoUnitario: Decimal | null
    Utilidad: Decimal | null
    PrecioUnitario: Decimal | null
    CreadoFecha: Date | null
    Vigente: boolean | null
  }

  export type ListasPreciosMaxAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
    UnidadMedidaId: number | null
    CostoUnitario: Decimal | null
    Utilidad: Decimal | null
    PrecioUnitario: Decimal | null
    CreadoFecha: Date | null
    Vigente: boolean | null
  }

  export type ListasPreciosCountAggregateOutputType = {
    Id: number
    ProductoId: number
    UnidadMedidaId: number
    CostoUnitario: number
    Utilidad: number
    PrecioUnitario: number
    CreadoFecha: number
    Vigente: number
    _all: number
  }


  export type ListasPreciosAvgAggregateInputType = {
    Id?: true
    ProductoId?: true
    UnidadMedidaId?: true
    CostoUnitario?: true
    Utilidad?: true
    PrecioUnitario?: true
  }

  export type ListasPreciosSumAggregateInputType = {
    Id?: true
    ProductoId?: true
    UnidadMedidaId?: true
    CostoUnitario?: true
    Utilidad?: true
    PrecioUnitario?: true
  }

  export type ListasPreciosMinAggregateInputType = {
    Id?: true
    ProductoId?: true
    UnidadMedidaId?: true
    CostoUnitario?: true
    Utilidad?: true
    PrecioUnitario?: true
    CreadoFecha?: true
    Vigente?: true
  }

  export type ListasPreciosMaxAggregateInputType = {
    Id?: true
    ProductoId?: true
    UnidadMedidaId?: true
    CostoUnitario?: true
    Utilidad?: true
    PrecioUnitario?: true
    CreadoFecha?: true
    Vigente?: true
  }

  export type ListasPreciosCountAggregateInputType = {
    Id?: true
    ProductoId?: true
    UnidadMedidaId?: true
    CostoUnitario?: true
    Utilidad?: true
    PrecioUnitario?: true
    CreadoFecha?: true
    Vigente?: true
    _all?: true
  }

  export type ListasPreciosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListasPrecios to aggregate.
     */
    where?: ListasPreciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListasPrecios to fetch.
     */
    orderBy?: ListasPreciosOrderByWithRelationInput | ListasPreciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListasPreciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListasPrecios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListasPrecios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListasPrecios
    **/
    _count?: true | ListasPreciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListasPreciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListasPreciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListasPreciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListasPreciosMaxAggregateInputType
  }

  export type GetListasPreciosAggregateType<T extends ListasPreciosAggregateArgs> = {
        [P in keyof T & keyof AggregateListasPrecios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListasPrecios[P]>
      : GetScalarType<T[P], AggregateListasPrecios[P]>
  }




  export type ListasPreciosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListasPreciosWhereInput
    orderBy?: ListasPreciosOrderByWithAggregationInput | ListasPreciosOrderByWithAggregationInput[]
    by: ListasPreciosScalarFieldEnum[] | ListasPreciosScalarFieldEnum
    having?: ListasPreciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListasPreciosCountAggregateInputType | true
    _avg?: ListasPreciosAvgAggregateInputType
    _sum?: ListasPreciosSumAggregateInputType
    _min?: ListasPreciosMinAggregateInputType
    _max?: ListasPreciosMaxAggregateInputType
  }

  export type ListasPreciosGroupByOutputType = {
    Id: number
    ProductoId: number
    UnidadMedidaId: number
    CostoUnitario: Decimal
    Utilidad: Decimal
    PrecioUnitario: Decimal
    CreadoFecha: Date
    Vigente: boolean
    _count: ListasPreciosCountAggregateOutputType | null
    _avg: ListasPreciosAvgAggregateOutputType | null
    _sum: ListasPreciosSumAggregateOutputType | null
    _min: ListasPreciosMinAggregateOutputType | null
    _max: ListasPreciosMaxAggregateOutputType | null
  }

  type GetListasPreciosGroupByPayload<T extends ListasPreciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListasPreciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListasPreciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListasPreciosGroupByOutputType[P]>
            : GetScalarType<T[P], ListasPreciosGroupByOutputType[P]>
        }
      >
    >


  export type ListasPreciosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    ProductoId?: boolean
    UnidadMedidaId?: boolean
    CostoUnitario?: boolean
    Utilidad?: boolean
    PrecioUnitario?: boolean
    CreadoFecha?: boolean
    Vigente?: boolean
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
    UnidadesMedida?: boolean | UnidadesMedidaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listasPrecios"]>



  export type ListasPreciosSelectScalar = {
    Id?: boolean
    ProductoId?: boolean
    UnidadMedidaId?: boolean
    CostoUnitario?: boolean
    Utilidad?: boolean
    PrecioUnitario?: boolean
    CreadoFecha?: boolean
    Vigente?: boolean
  }

  export type ListasPreciosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "ProductoId" | "UnidadMedidaId" | "CostoUnitario" | "Utilidad" | "PrecioUnitario" | "CreadoFecha" | "Vigente", ExtArgs["result"]["listasPrecios"]>
  export type ListasPreciosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
    UnidadesMedida?: boolean | UnidadesMedidaDefaultArgs<ExtArgs>
  }

  export type $ListasPreciosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListasPrecios"
    objects: {
      Productos: Prisma.$ProductosPayload<ExtArgs>
      UnidadesMedida: Prisma.$UnidadesMedidaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      ProductoId: number
      UnidadMedidaId: number
      CostoUnitario: Prisma.Decimal
      Utilidad: Prisma.Decimal
      PrecioUnitario: Prisma.Decimal
      CreadoFecha: Date
      Vigente: boolean
    }, ExtArgs["result"]["listasPrecios"]>
    composites: {}
  }

  type ListasPreciosGetPayload<S extends boolean | null | undefined | ListasPreciosDefaultArgs> = $Result.GetResult<Prisma.$ListasPreciosPayload, S>

  type ListasPreciosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListasPreciosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListasPreciosCountAggregateInputType | true
    }

  export interface ListasPreciosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListasPrecios'], meta: { name: 'ListasPrecios' } }
    /**
     * Find zero or one ListasPrecios that matches the filter.
     * @param {ListasPreciosFindUniqueArgs} args - Arguments to find a ListasPrecios
     * @example
     * // Get one ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListasPreciosFindUniqueArgs>(args: SelectSubset<T, ListasPreciosFindUniqueArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListasPrecios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListasPreciosFindUniqueOrThrowArgs} args - Arguments to find a ListasPrecios
     * @example
     * // Get one ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListasPreciosFindUniqueOrThrowArgs>(args: SelectSubset<T, ListasPreciosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListasPrecios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListasPreciosFindFirstArgs} args - Arguments to find a ListasPrecios
     * @example
     * // Get one ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListasPreciosFindFirstArgs>(args?: SelectSubset<T, ListasPreciosFindFirstArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListasPrecios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListasPreciosFindFirstOrThrowArgs} args - Arguments to find a ListasPrecios
     * @example
     * // Get one ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListasPreciosFindFirstOrThrowArgs>(args?: SelectSubset<T, ListasPreciosFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListasPrecios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListasPreciosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.findMany()
     * 
     * // Get first 10 ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const listasPreciosWithIdOnly = await prisma.listasPrecios.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends ListasPreciosFindManyArgs>(args?: SelectSubset<T, ListasPreciosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListasPrecios.
     * @param {ListasPreciosCreateArgs} args - Arguments to create a ListasPrecios.
     * @example
     * // Create one ListasPrecios
     * const ListasPrecios = await prisma.listasPrecios.create({
     *   data: {
     *     // ... data to create a ListasPrecios
     *   }
     * })
     * 
     */
    create<T extends ListasPreciosCreateArgs>(args: SelectSubset<T, ListasPreciosCreateArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListasPrecios.
     * @param {ListasPreciosCreateManyArgs} args - Arguments to create many ListasPrecios.
     * @example
     * // Create many ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListasPreciosCreateManyArgs>(args?: SelectSubset<T, ListasPreciosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ListasPrecios.
     * @param {ListasPreciosDeleteArgs} args - Arguments to delete one ListasPrecios.
     * @example
     * // Delete one ListasPrecios
     * const ListasPrecios = await prisma.listasPrecios.delete({
     *   where: {
     *     // ... filter to delete one ListasPrecios
     *   }
     * })
     * 
     */
    delete<T extends ListasPreciosDeleteArgs>(args: SelectSubset<T, ListasPreciosDeleteArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListasPrecios.
     * @param {ListasPreciosUpdateArgs} args - Arguments to update one ListasPrecios.
     * @example
     * // Update one ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListasPreciosUpdateArgs>(args: SelectSubset<T, ListasPreciosUpdateArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListasPrecios.
     * @param {ListasPreciosDeleteManyArgs} args - Arguments to filter ListasPrecios to delete.
     * @example
     * // Delete a few ListasPrecios
     * const { count } = await prisma.listasPrecios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListasPreciosDeleteManyArgs>(args?: SelectSubset<T, ListasPreciosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListasPrecios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListasPreciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListasPreciosUpdateManyArgs>(args: SelectSubset<T, ListasPreciosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ListasPrecios.
     * @param {ListasPreciosUpsertArgs} args - Arguments to update or create a ListasPrecios.
     * @example
     * // Update or create a ListasPrecios
     * const listasPrecios = await prisma.listasPrecios.upsert({
     *   create: {
     *     // ... data to create a ListasPrecios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListasPrecios we want to update
     *   }
     * })
     */
    upsert<T extends ListasPreciosUpsertArgs>(args: SelectSubset<T, ListasPreciosUpsertArgs<ExtArgs>>): Prisma__ListasPreciosClient<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListasPrecios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListasPreciosCountArgs} args - Arguments to filter ListasPrecios to count.
     * @example
     * // Count the number of ListasPrecios
     * const count = await prisma.listasPrecios.count({
     *   where: {
     *     // ... the filter for the ListasPrecios we want to count
     *   }
     * })
    **/
    count<T extends ListasPreciosCountArgs>(
      args?: Subset<T, ListasPreciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListasPreciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListasPrecios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListasPreciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListasPreciosAggregateArgs>(args: Subset<T, ListasPreciosAggregateArgs>): Prisma.PrismaPromise<GetListasPreciosAggregateType<T>>

    /**
     * Group by ListasPrecios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListasPreciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListasPreciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListasPreciosGroupByArgs['orderBy'] }
        : { orderBy?: ListasPreciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListasPreciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListasPreciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListasPrecios model
   */
  readonly fields: ListasPreciosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListasPrecios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListasPreciosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Productos<T extends ProductosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductosDefaultArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    UnidadesMedida<T extends UnidadesMedidaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnidadesMedidaDefaultArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListasPrecios model
   */
  interface ListasPreciosFieldRefs {
    readonly Id: FieldRef<"ListasPrecios", 'Int'>
    readonly ProductoId: FieldRef<"ListasPrecios", 'Int'>
    readonly UnidadMedidaId: FieldRef<"ListasPrecios", 'Int'>
    readonly CostoUnitario: FieldRef<"ListasPrecios", 'Decimal'>
    readonly Utilidad: FieldRef<"ListasPrecios", 'Decimal'>
    readonly PrecioUnitario: FieldRef<"ListasPrecios", 'Decimal'>
    readonly CreadoFecha: FieldRef<"ListasPrecios", 'DateTime'>
    readonly Vigente: FieldRef<"ListasPrecios", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ListasPrecios findUnique
   */
  export type ListasPreciosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * Filter, which ListasPrecios to fetch.
     */
    where: ListasPreciosWhereUniqueInput
  }

  /**
   * ListasPrecios findUniqueOrThrow
   */
  export type ListasPreciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * Filter, which ListasPrecios to fetch.
     */
    where: ListasPreciosWhereUniqueInput
  }

  /**
   * ListasPrecios findFirst
   */
  export type ListasPreciosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * Filter, which ListasPrecios to fetch.
     */
    where?: ListasPreciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListasPrecios to fetch.
     */
    orderBy?: ListasPreciosOrderByWithRelationInput | ListasPreciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListasPrecios.
     */
    cursor?: ListasPreciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListasPrecios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListasPrecios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListasPrecios.
     */
    distinct?: ListasPreciosScalarFieldEnum | ListasPreciosScalarFieldEnum[]
  }

  /**
   * ListasPrecios findFirstOrThrow
   */
  export type ListasPreciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * Filter, which ListasPrecios to fetch.
     */
    where?: ListasPreciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListasPrecios to fetch.
     */
    orderBy?: ListasPreciosOrderByWithRelationInput | ListasPreciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListasPrecios.
     */
    cursor?: ListasPreciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListasPrecios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListasPrecios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListasPrecios.
     */
    distinct?: ListasPreciosScalarFieldEnum | ListasPreciosScalarFieldEnum[]
  }

  /**
   * ListasPrecios findMany
   */
  export type ListasPreciosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * Filter, which ListasPrecios to fetch.
     */
    where?: ListasPreciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListasPrecios to fetch.
     */
    orderBy?: ListasPreciosOrderByWithRelationInput | ListasPreciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListasPrecios.
     */
    cursor?: ListasPreciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListasPrecios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListasPrecios.
     */
    skip?: number
    distinct?: ListasPreciosScalarFieldEnum | ListasPreciosScalarFieldEnum[]
  }

  /**
   * ListasPrecios create
   */
  export type ListasPreciosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * The data needed to create a ListasPrecios.
     */
    data: XOR<ListasPreciosCreateInput, ListasPreciosUncheckedCreateInput>
  }

  /**
   * ListasPrecios createMany
   */
  export type ListasPreciosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListasPrecios.
     */
    data: ListasPreciosCreateManyInput | ListasPreciosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListasPrecios update
   */
  export type ListasPreciosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * The data needed to update a ListasPrecios.
     */
    data: XOR<ListasPreciosUpdateInput, ListasPreciosUncheckedUpdateInput>
    /**
     * Choose, which ListasPrecios to update.
     */
    where: ListasPreciosWhereUniqueInput
  }

  /**
   * ListasPrecios updateMany
   */
  export type ListasPreciosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListasPrecios.
     */
    data: XOR<ListasPreciosUpdateManyMutationInput, ListasPreciosUncheckedUpdateManyInput>
    /**
     * Filter which ListasPrecios to update
     */
    where?: ListasPreciosWhereInput
    /**
     * Limit how many ListasPrecios to update.
     */
    limit?: number
  }

  /**
   * ListasPrecios upsert
   */
  export type ListasPreciosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * The filter to search for the ListasPrecios to update in case it exists.
     */
    where: ListasPreciosWhereUniqueInput
    /**
     * In case the ListasPrecios found by the `where` argument doesn't exist, create a new ListasPrecios with this data.
     */
    create: XOR<ListasPreciosCreateInput, ListasPreciosUncheckedCreateInput>
    /**
     * In case the ListasPrecios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListasPreciosUpdateInput, ListasPreciosUncheckedUpdateInput>
  }

  /**
   * ListasPrecios delete
   */
  export type ListasPreciosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    /**
     * Filter which ListasPrecios to delete.
     */
    where: ListasPreciosWhereUniqueInput
  }

  /**
   * ListasPrecios deleteMany
   */
  export type ListasPreciosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListasPrecios to delete
     */
    where?: ListasPreciosWhereInput
    /**
     * Limit how many ListasPrecios to delete.
     */
    limit?: number
  }

  /**
   * ListasPrecios without action
   */
  export type ListasPreciosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
  }


  /**
   * Model MetodosPago
   */

  export type AggregateMetodosPago = {
    _count: MetodosPagoCountAggregateOutputType | null
    _avg: MetodosPagoAvgAggregateOutputType | null
    _sum: MetodosPagoSumAggregateOutputType | null
    _min: MetodosPagoMinAggregateOutputType | null
    _max: MetodosPagoMaxAggregateOutputType | null
  }

  export type MetodosPagoAvgAggregateOutputType = {
    Id: number | null
  }

  export type MetodosPagoSumAggregateOutputType = {
    Id: number | null
  }

  export type MetodosPagoMinAggregateOutputType = {
    Id: number | null
    code: string | null
    Nombre: string | null
  }

  export type MetodosPagoMaxAggregateOutputType = {
    Id: number | null
    code: string | null
    Nombre: string | null
  }

  export type MetodosPagoCountAggregateOutputType = {
    Id: number
    code: number
    Nombre: number
    _all: number
  }


  export type MetodosPagoAvgAggregateInputType = {
    Id?: true
  }

  export type MetodosPagoSumAggregateInputType = {
    Id?: true
  }

  export type MetodosPagoMinAggregateInputType = {
    Id?: true
    code?: true
    Nombre?: true
  }

  export type MetodosPagoMaxAggregateInputType = {
    Id?: true
    code?: true
    Nombre?: true
  }

  export type MetodosPagoCountAggregateInputType = {
    Id?: true
    code?: true
    Nombre?: true
    _all?: true
  }

  export type MetodosPagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetodosPago to aggregate.
     */
    where?: MetodosPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodosPagos to fetch.
     */
    orderBy?: MetodosPagoOrderByWithRelationInput | MetodosPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetodosPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodosPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodosPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetodosPagos
    **/
    _count?: true | MetodosPagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetodosPagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetodosPagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetodosPagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetodosPagoMaxAggregateInputType
  }

  export type GetMetodosPagoAggregateType<T extends MetodosPagoAggregateArgs> = {
        [P in keyof T & keyof AggregateMetodosPago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetodosPago[P]>
      : GetScalarType<T[P], AggregateMetodosPago[P]>
  }




  export type MetodosPagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetodosPagoWhereInput
    orderBy?: MetodosPagoOrderByWithAggregationInput | MetodosPagoOrderByWithAggregationInput[]
    by: MetodosPagoScalarFieldEnum[] | MetodosPagoScalarFieldEnum
    having?: MetodosPagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetodosPagoCountAggregateInputType | true
    _avg?: MetodosPagoAvgAggregateInputType
    _sum?: MetodosPagoSumAggregateInputType
    _min?: MetodosPagoMinAggregateInputType
    _max?: MetodosPagoMaxAggregateInputType
  }

  export type MetodosPagoGroupByOutputType = {
    Id: number
    code: string
    Nombre: string
    _count: MetodosPagoCountAggregateOutputType | null
    _avg: MetodosPagoAvgAggregateOutputType | null
    _sum: MetodosPagoSumAggregateOutputType | null
    _min: MetodosPagoMinAggregateOutputType | null
    _max: MetodosPagoMaxAggregateOutputType | null
  }

  type GetMetodosPagoGroupByPayload<T extends MetodosPagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetodosPagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetodosPagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetodosPagoGroupByOutputType[P]>
            : GetScalarType<T[P], MetodosPagoGroupByOutputType[P]>
        }
      >
    >


  export type MetodosPagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    code?: boolean
    Nombre?: boolean
    Ventas?: boolean | MetodosPago$VentasArgs<ExtArgs>
    _count?: boolean | MetodosPagoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metodosPago"]>



  export type MetodosPagoSelectScalar = {
    Id?: boolean
    code?: boolean
    Nombre?: boolean
  }

  export type MetodosPagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "code" | "Nombre", ExtArgs["result"]["metodosPago"]>
  export type MetodosPagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ventas?: boolean | MetodosPago$VentasArgs<ExtArgs>
    _count?: boolean | MetodosPagoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MetodosPagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MetodosPago"
    objects: {
      Ventas: Prisma.$VentasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      code: string
      Nombre: string
    }, ExtArgs["result"]["metodosPago"]>
    composites: {}
  }

  type MetodosPagoGetPayload<S extends boolean | null | undefined | MetodosPagoDefaultArgs> = $Result.GetResult<Prisma.$MetodosPagoPayload, S>

  type MetodosPagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetodosPagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetodosPagoCountAggregateInputType | true
    }

  export interface MetodosPagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MetodosPago'], meta: { name: 'MetodosPago' } }
    /**
     * Find zero or one MetodosPago that matches the filter.
     * @param {MetodosPagoFindUniqueArgs} args - Arguments to find a MetodosPago
     * @example
     * // Get one MetodosPago
     * const metodosPago = await prisma.metodosPago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetodosPagoFindUniqueArgs>(args: SelectSubset<T, MetodosPagoFindUniqueArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MetodosPago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetodosPagoFindUniqueOrThrowArgs} args - Arguments to find a MetodosPago
     * @example
     * // Get one MetodosPago
     * const metodosPago = await prisma.metodosPago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetodosPagoFindUniqueOrThrowArgs>(args: SelectSubset<T, MetodosPagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetodosPago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosPagoFindFirstArgs} args - Arguments to find a MetodosPago
     * @example
     * // Get one MetodosPago
     * const metodosPago = await prisma.metodosPago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetodosPagoFindFirstArgs>(args?: SelectSubset<T, MetodosPagoFindFirstArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetodosPago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosPagoFindFirstOrThrowArgs} args - Arguments to find a MetodosPago
     * @example
     * // Get one MetodosPago
     * const metodosPago = await prisma.metodosPago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetodosPagoFindFirstOrThrowArgs>(args?: SelectSubset<T, MetodosPagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MetodosPagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosPagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetodosPagos
     * const metodosPagos = await prisma.metodosPago.findMany()
     * 
     * // Get first 10 MetodosPagos
     * const metodosPagos = await prisma.metodosPago.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const metodosPagoWithIdOnly = await prisma.metodosPago.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends MetodosPagoFindManyArgs>(args?: SelectSubset<T, MetodosPagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MetodosPago.
     * @param {MetodosPagoCreateArgs} args - Arguments to create a MetodosPago.
     * @example
     * // Create one MetodosPago
     * const MetodosPago = await prisma.metodosPago.create({
     *   data: {
     *     // ... data to create a MetodosPago
     *   }
     * })
     * 
     */
    create<T extends MetodosPagoCreateArgs>(args: SelectSubset<T, MetodosPagoCreateArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MetodosPagos.
     * @param {MetodosPagoCreateManyArgs} args - Arguments to create many MetodosPagos.
     * @example
     * // Create many MetodosPagos
     * const metodosPago = await prisma.metodosPago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetodosPagoCreateManyArgs>(args?: SelectSubset<T, MetodosPagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MetodosPago.
     * @param {MetodosPagoDeleteArgs} args - Arguments to delete one MetodosPago.
     * @example
     * // Delete one MetodosPago
     * const MetodosPago = await prisma.metodosPago.delete({
     *   where: {
     *     // ... filter to delete one MetodosPago
     *   }
     * })
     * 
     */
    delete<T extends MetodosPagoDeleteArgs>(args: SelectSubset<T, MetodosPagoDeleteArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MetodosPago.
     * @param {MetodosPagoUpdateArgs} args - Arguments to update one MetodosPago.
     * @example
     * // Update one MetodosPago
     * const metodosPago = await prisma.metodosPago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetodosPagoUpdateArgs>(args: SelectSubset<T, MetodosPagoUpdateArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MetodosPagos.
     * @param {MetodosPagoDeleteManyArgs} args - Arguments to filter MetodosPagos to delete.
     * @example
     * // Delete a few MetodosPagos
     * const { count } = await prisma.metodosPago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetodosPagoDeleteManyArgs>(args?: SelectSubset<T, MetodosPagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetodosPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosPagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetodosPagos
     * const metodosPago = await prisma.metodosPago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetodosPagoUpdateManyArgs>(args: SelectSubset<T, MetodosPagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MetodosPago.
     * @param {MetodosPagoUpsertArgs} args - Arguments to update or create a MetodosPago.
     * @example
     * // Update or create a MetodosPago
     * const metodosPago = await prisma.metodosPago.upsert({
     *   create: {
     *     // ... data to create a MetodosPago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetodosPago we want to update
     *   }
     * })
     */
    upsert<T extends MetodosPagoUpsertArgs>(args: SelectSubset<T, MetodosPagoUpsertArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MetodosPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosPagoCountArgs} args - Arguments to filter MetodosPagos to count.
     * @example
     * // Count the number of MetodosPagos
     * const count = await prisma.metodosPago.count({
     *   where: {
     *     // ... the filter for the MetodosPagos we want to count
     *   }
     * })
    **/
    count<T extends MetodosPagoCountArgs>(
      args?: Subset<T, MetodosPagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetodosPagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetodosPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosPagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetodosPagoAggregateArgs>(args: Subset<T, MetodosPagoAggregateArgs>): Prisma.PrismaPromise<GetMetodosPagoAggregateType<T>>

    /**
     * Group by MetodosPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetodosPagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetodosPagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetodosPagoGroupByArgs['orderBy'] }
        : { orderBy?: MetodosPagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetodosPagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetodosPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MetodosPago model
   */
  readonly fields: MetodosPagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetodosPago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetodosPagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ventas<T extends MetodosPago$VentasArgs<ExtArgs> = {}>(args?: Subset<T, MetodosPago$VentasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MetodosPago model
   */
  interface MetodosPagoFieldRefs {
    readonly Id: FieldRef<"MetodosPago", 'Int'>
    readonly code: FieldRef<"MetodosPago", 'String'>
    readonly Nombre: FieldRef<"MetodosPago", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MetodosPago findUnique
   */
  export type MetodosPagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * Filter, which MetodosPago to fetch.
     */
    where: MetodosPagoWhereUniqueInput
  }

  /**
   * MetodosPago findUniqueOrThrow
   */
  export type MetodosPagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * Filter, which MetodosPago to fetch.
     */
    where: MetodosPagoWhereUniqueInput
  }

  /**
   * MetodosPago findFirst
   */
  export type MetodosPagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * Filter, which MetodosPago to fetch.
     */
    where?: MetodosPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodosPagos to fetch.
     */
    orderBy?: MetodosPagoOrderByWithRelationInput | MetodosPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetodosPagos.
     */
    cursor?: MetodosPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodosPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodosPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetodosPagos.
     */
    distinct?: MetodosPagoScalarFieldEnum | MetodosPagoScalarFieldEnum[]
  }

  /**
   * MetodosPago findFirstOrThrow
   */
  export type MetodosPagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * Filter, which MetodosPago to fetch.
     */
    where?: MetodosPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodosPagos to fetch.
     */
    orderBy?: MetodosPagoOrderByWithRelationInput | MetodosPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetodosPagos.
     */
    cursor?: MetodosPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodosPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodosPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetodosPagos.
     */
    distinct?: MetodosPagoScalarFieldEnum | MetodosPagoScalarFieldEnum[]
  }

  /**
   * MetodosPago findMany
   */
  export type MetodosPagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * Filter, which MetodosPagos to fetch.
     */
    where?: MetodosPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetodosPagos to fetch.
     */
    orderBy?: MetodosPagoOrderByWithRelationInput | MetodosPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetodosPagos.
     */
    cursor?: MetodosPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetodosPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetodosPagos.
     */
    skip?: number
    distinct?: MetodosPagoScalarFieldEnum | MetodosPagoScalarFieldEnum[]
  }

  /**
   * MetodosPago create
   */
  export type MetodosPagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * The data needed to create a MetodosPago.
     */
    data: XOR<MetodosPagoCreateInput, MetodosPagoUncheckedCreateInput>
  }

  /**
   * MetodosPago createMany
   */
  export type MetodosPagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MetodosPagos.
     */
    data: MetodosPagoCreateManyInput | MetodosPagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MetodosPago update
   */
  export type MetodosPagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * The data needed to update a MetodosPago.
     */
    data: XOR<MetodosPagoUpdateInput, MetodosPagoUncheckedUpdateInput>
    /**
     * Choose, which MetodosPago to update.
     */
    where: MetodosPagoWhereUniqueInput
  }

  /**
   * MetodosPago updateMany
   */
  export type MetodosPagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MetodosPagos.
     */
    data: XOR<MetodosPagoUpdateManyMutationInput, MetodosPagoUncheckedUpdateManyInput>
    /**
     * Filter which MetodosPagos to update
     */
    where?: MetodosPagoWhereInput
    /**
     * Limit how many MetodosPagos to update.
     */
    limit?: number
  }

  /**
   * MetodosPago upsert
   */
  export type MetodosPagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * The filter to search for the MetodosPago to update in case it exists.
     */
    where: MetodosPagoWhereUniqueInput
    /**
     * In case the MetodosPago found by the `where` argument doesn't exist, create a new MetodosPago with this data.
     */
    create: XOR<MetodosPagoCreateInput, MetodosPagoUncheckedCreateInput>
    /**
     * In case the MetodosPago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetodosPagoUpdateInput, MetodosPagoUncheckedUpdateInput>
  }

  /**
   * MetodosPago delete
   */
  export type MetodosPagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
    /**
     * Filter which MetodosPago to delete.
     */
    where: MetodosPagoWhereUniqueInput
  }

  /**
   * MetodosPago deleteMany
   */
  export type MetodosPagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetodosPagos to delete
     */
    where?: MetodosPagoWhereInput
    /**
     * Limit how many MetodosPagos to delete.
     */
    limit?: number
  }

  /**
   * MetodosPago.Ventas
   */
  export type MetodosPago$VentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    where?: VentasWhereInput
    orderBy?: VentasOrderByWithRelationInput | VentasOrderByWithRelationInput[]
    cursor?: VentasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentasScalarFieldEnum | VentasScalarFieldEnum[]
  }

  /**
   * MetodosPago without action
   */
  export type MetodosPagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetodosPago
     */
    select?: MetodosPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetodosPago
     */
    omit?: MetodosPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetodosPagoInclude<ExtArgs> | null
  }


  /**
   * Model Productos
   */

  export type AggregateProductos = {
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  export type ProductosAvgAggregateOutputType = {
    Id: number | null
    Cantidad: number | null
    CategoriaId: number | null
  }

  export type ProductosSumAggregateOutputType = {
    Id: number | null
    Cantidad: number | null
    CategoriaId: number | null
  }

  export type ProductosMinAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    Descripcion: string | null
    Cantidad: number | null
    EsPieza: boolean | null
    CategoriaId: number | null
  }

  export type ProductosMaxAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    Descripcion: string | null
    Cantidad: number | null
    EsPieza: boolean | null
    CategoriaId: number | null
  }

  export type ProductosCountAggregateOutputType = {
    Id: number
    Nombre: number
    Descripcion: number
    Cantidad: number
    EsPieza: number
    CategoriaId: number
    _all: number
  }


  export type ProductosAvgAggregateInputType = {
    Id?: true
    Cantidad?: true
    CategoriaId?: true
  }

  export type ProductosSumAggregateInputType = {
    Id?: true
    Cantidad?: true
    CategoriaId?: true
  }

  export type ProductosMinAggregateInputType = {
    Id?: true
    Nombre?: true
    Descripcion?: true
    Cantidad?: true
    EsPieza?: true
    CategoriaId?: true
  }

  export type ProductosMaxAggregateInputType = {
    Id?: true
    Nombre?: true
    Descripcion?: true
    Cantidad?: true
    EsPieza?: true
    CategoriaId?: true
  }

  export type ProductosCountAggregateInputType = {
    Id?: true
    Nombre?: true
    Descripcion?: true
    Cantidad?: true
    EsPieza?: true
    CategoriaId?: true
    _all?: true
  }

  export type ProductosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to aggregate.
     */
    where?: ProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductosOrderByWithRelationInput | ProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductosMaxAggregateInputType
  }

  export type GetProductosAggregateType<T extends ProductosAggregateArgs> = {
        [P in keyof T & keyof AggregateProductos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductos[P]>
      : GetScalarType<T[P], AggregateProductos[P]>
  }




  export type ProductosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductosWhereInput
    orderBy?: ProductosOrderByWithAggregationInput | ProductosOrderByWithAggregationInput[]
    by: ProductosScalarFieldEnum[] | ProductosScalarFieldEnum
    having?: ProductosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductosCountAggregateInputType | true
    _avg?: ProductosAvgAggregateInputType
    _sum?: ProductosSumAggregateInputType
    _min?: ProductosMinAggregateInputType
    _max?: ProductosMaxAggregateInputType
  }

  export type ProductosGroupByOutputType = {
    Id: number
    Nombre: string
    Descripcion: string | null
    Cantidad: number
    EsPieza: boolean
    CategoriaId: number
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  type GetProductosGroupByPayload<T extends ProductosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductosGroupByOutputType[P]>
            : GetScalarType<T[P], ProductosGroupByOutputType[P]>
        }
      >
    >


  export type ProductosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Nombre?: boolean
    Descripcion?: boolean
    Cantidad?: boolean
    EsPieza?: boolean
    CategoriaId?: boolean
    Compras?: boolean | Productos$ComprasArgs<ExtArgs>
    ImagenesProductos?: boolean | Productos$ImagenesProductosArgs<ExtArgs>
    Inventario?: boolean | Productos$InventarioArgs<ExtArgs>
    ListasPrecios?: boolean | Productos$ListasPreciosArgs<ExtArgs>
    CategoriasProducto?: boolean | CategoriasProductoDefaultArgs<ExtArgs>
    Ventas?: boolean | Productos$VentasArgs<ExtArgs>
    _count?: boolean | ProductosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos"]>



  export type ProductosSelectScalar = {
    Id?: boolean
    Nombre?: boolean
    Descripcion?: boolean
    Cantidad?: boolean
    EsPieza?: boolean
    CategoriaId?: boolean
  }

  export type ProductosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Nombre" | "Descripcion" | "Cantidad" | "EsPieza" | "CategoriaId", ExtArgs["result"]["productos"]>
  export type ProductosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | Productos$ComprasArgs<ExtArgs>
    ImagenesProductos?: boolean | Productos$ImagenesProductosArgs<ExtArgs>
    Inventario?: boolean | Productos$InventarioArgs<ExtArgs>
    ListasPrecios?: boolean | Productos$ListasPreciosArgs<ExtArgs>
    CategoriasProducto?: boolean | CategoriasProductoDefaultArgs<ExtArgs>
    Ventas?: boolean | Productos$VentasArgs<ExtArgs>
    _count?: boolean | ProductosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Productos"
    objects: {
      Compras: Prisma.$ComprasPayload<ExtArgs>[]
      ImagenesProductos: Prisma.$ImagenesProductosPayload<ExtArgs>[]
      Inventario: Prisma.$InventarioPayload<ExtArgs>[]
      ListasPrecios: Prisma.$ListasPreciosPayload<ExtArgs>[]
      CategoriasProducto: Prisma.$CategoriasProductoPayload<ExtArgs>
      Ventas: Prisma.$VentasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Nombre: string
      Descripcion: string | null
      Cantidad: number
      EsPieza: boolean
      CategoriaId: number
    }, ExtArgs["result"]["productos"]>
    composites: {}
  }

  type ProductosGetPayload<S extends boolean | null | undefined | ProductosDefaultArgs> = $Result.GetResult<Prisma.$ProductosPayload, S>

  type ProductosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductosCountAggregateInputType | true
    }

  export interface ProductosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Productos'], meta: { name: 'Productos' } }
    /**
     * Find zero or one Productos that matches the filter.
     * @param {ProductosFindUniqueArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductosFindUniqueArgs>(args: SelectSubset<T, ProductosFindUniqueArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Productos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductosFindUniqueOrThrowArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductosFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosFindFirstArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductosFindFirstArgs>(args?: SelectSubset<T, ProductosFindFirstArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosFindFirstOrThrowArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductosFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductosFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.productos.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.productos.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const productosWithIdOnly = await prisma.productos.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends ProductosFindManyArgs>(args?: SelectSubset<T, ProductosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Productos.
     * @param {ProductosCreateArgs} args - Arguments to create a Productos.
     * @example
     * // Create one Productos
     * const Productos = await prisma.productos.create({
     *   data: {
     *     // ... data to create a Productos
     *   }
     * })
     * 
     */
    create<T extends ProductosCreateArgs>(args: SelectSubset<T, ProductosCreateArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productos.
     * @param {ProductosCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const productos = await prisma.productos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductosCreateManyArgs>(args?: SelectSubset<T, ProductosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Productos.
     * @param {ProductosDeleteArgs} args - Arguments to delete one Productos.
     * @example
     * // Delete one Productos
     * const Productos = await prisma.productos.delete({
     *   where: {
     *     // ... filter to delete one Productos
     *   }
     * })
     * 
     */
    delete<T extends ProductosDeleteArgs>(args: SelectSubset<T, ProductosDeleteArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Productos.
     * @param {ProductosUpdateArgs} args - Arguments to update one Productos.
     * @example
     * // Update one Productos
     * const productos = await prisma.productos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductosUpdateArgs>(args: SelectSubset<T, ProductosUpdateArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productos.
     * @param {ProductosDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.productos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductosDeleteManyArgs>(args?: SelectSubset<T, ProductosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const productos = await prisma.productos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductosUpdateManyArgs>(args: SelectSubset<T, ProductosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Productos.
     * @param {ProductosUpsertArgs} args - Arguments to update or create a Productos.
     * @example
     * // Update or create a Productos
     * const productos = await prisma.productos.upsert({
     *   create: {
     *     // ... data to create a Productos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productos we want to update
     *   }
     * })
     */
    upsert<T extends ProductosUpsertArgs>(args: SelectSubset<T, ProductosUpsertArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.productos.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductosCountArgs>(
      args?: Subset<T, ProductosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductosAggregateArgs>(args: Subset<T, ProductosAggregateArgs>): Prisma.PrismaPromise<GetProductosAggregateType<T>>

    /**
     * Group by Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductosGroupByArgs['orderBy'] }
        : { orderBy?: ProductosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Productos model
   */
  readonly fields: ProductosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Productos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Compras<T extends Productos$ComprasArgs<ExtArgs> = {}>(args?: Subset<T, Productos$ComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ImagenesProductos<T extends Productos$ImagenesProductosArgs<ExtArgs> = {}>(args?: Subset<T, Productos$ImagenesProductosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagenesProductosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inventario<T extends Productos$InventarioArgs<ExtArgs> = {}>(args?: Subset<T, Productos$InventarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ListasPrecios<T extends Productos$ListasPreciosArgs<ExtArgs> = {}>(args?: Subset<T, Productos$ListasPreciosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CategoriasProducto<T extends CategoriasProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriasProductoDefaultArgs<ExtArgs>>): Prisma__CategoriasProductoClient<$Result.GetResult<Prisma.$CategoriasProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Ventas<T extends Productos$VentasArgs<ExtArgs> = {}>(args?: Subset<T, Productos$VentasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Productos model
   */
  interface ProductosFieldRefs {
    readonly Id: FieldRef<"Productos", 'Int'>
    readonly Nombre: FieldRef<"Productos", 'String'>
    readonly Descripcion: FieldRef<"Productos", 'String'>
    readonly Cantidad: FieldRef<"Productos", 'Int'>
    readonly EsPieza: FieldRef<"Productos", 'Boolean'>
    readonly CategoriaId: FieldRef<"Productos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Productos findUnique
   */
  export type ProductosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where: ProductosWhereUniqueInput
  }

  /**
   * Productos findUniqueOrThrow
   */
  export type ProductosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where: ProductosWhereUniqueInput
  }

  /**
   * Productos findFirst
   */
  export type ProductosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductosOrderByWithRelationInput | ProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * Productos findFirstOrThrow
   */
  export type ProductosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductosOrderByWithRelationInput | ProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * Productos findMany
   */
  export type ProductosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductosOrderByWithRelationInput | ProductosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     */
    cursor?: ProductosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * Productos create
   */
  export type ProductosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * The data needed to create a Productos.
     */
    data: XOR<ProductosCreateInput, ProductosUncheckedCreateInput>
  }

  /**
   * Productos createMany
   */
  export type ProductosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productos.
     */
    data: ProductosCreateManyInput | ProductosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Productos update
   */
  export type ProductosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * The data needed to update a Productos.
     */
    data: XOR<ProductosUpdateInput, ProductosUncheckedUpdateInput>
    /**
     * Choose, which Productos to update.
     */
    where: ProductosWhereUniqueInput
  }

  /**
   * Productos updateMany
   */
  export type ProductosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductosUpdateManyMutationInput, ProductosUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductosWhereInput
    /**
     * Limit how many Productos to update.
     */
    limit?: number
  }

  /**
   * Productos upsert
   */
  export type ProductosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * The filter to search for the Productos to update in case it exists.
     */
    where: ProductosWhereUniqueInput
    /**
     * In case the Productos found by the `where` argument doesn't exist, create a new Productos with this data.
     */
    create: XOR<ProductosCreateInput, ProductosUncheckedCreateInput>
    /**
     * In case the Productos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductosUpdateInput, ProductosUncheckedUpdateInput>
  }

  /**
   * Productos delete
   */
  export type ProductosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
    /**
     * Filter which Productos to delete.
     */
    where: ProductosWhereUniqueInput
  }

  /**
   * Productos deleteMany
   */
  export type ProductosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductosWhereInput
    /**
     * Limit how many Productos to delete.
     */
    limit?: number
  }

  /**
   * Productos.Compras
   */
  export type Productos$ComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    where?: ComprasWhereInput
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    cursor?: ComprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * Productos.ImagenesProductos
   */
  export type Productos$ImagenesProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenesProductos
     */
    select?: ImagenesProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenesProductos
     */
    omit?: ImagenesProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenesProductosInclude<ExtArgs> | null
    where?: ImagenesProductosWhereInput
    orderBy?: ImagenesProductosOrderByWithRelationInput | ImagenesProductosOrderByWithRelationInput[]
    cursor?: ImagenesProductosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagenesProductosScalarFieldEnum | ImagenesProductosScalarFieldEnum[]
  }

  /**
   * Productos.Inventario
   */
  export type Productos$InventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Productos.ListasPrecios
   */
  export type Productos$ListasPreciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    where?: ListasPreciosWhereInput
    orderBy?: ListasPreciosOrderByWithRelationInput | ListasPreciosOrderByWithRelationInput[]
    cursor?: ListasPreciosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListasPreciosScalarFieldEnum | ListasPreciosScalarFieldEnum[]
  }

  /**
   * Productos.Ventas
   */
  export type Productos$VentasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    where?: VentasWhereInput
    orderBy?: VentasOrderByWithRelationInput | VentasOrderByWithRelationInput[]
    cursor?: VentasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentasScalarFieldEnum | VentasScalarFieldEnum[]
  }

  /**
   * Productos without action
   */
  export type ProductosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos
     */
    select?: ProductosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Productos
     */
    omit?: ProductosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductosInclude<ExtArgs> | null
  }


  /**
   * Model Proveedores
   */

  export type AggregateProveedores = {
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  export type ProveedoresAvgAggregateOutputType = {
    Id: number | null
  }

  export type ProveedoresSumAggregateOutputType = {
    Id: number | null
  }

  export type ProveedoresMinAggregateOutputType = {
    Id: number | null
    Nombre: string | null
  }

  export type ProveedoresMaxAggregateOutputType = {
    Id: number | null
    Nombre: string | null
  }

  export type ProveedoresCountAggregateOutputType = {
    Id: number
    Nombre: number
    _all: number
  }


  export type ProveedoresAvgAggregateInputType = {
    Id?: true
  }

  export type ProveedoresSumAggregateInputType = {
    Id?: true
  }

  export type ProveedoresMinAggregateInputType = {
    Id?: true
    Nombre?: true
  }

  export type ProveedoresMaxAggregateInputType = {
    Id?: true
    Nombre?: true
  }

  export type ProveedoresCountAggregateInputType = {
    Id?: true
    Nombre?: true
    _all?: true
  }

  export type ProveedoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proveedores to aggregate.
     */
    where?: ProveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedores to fetch.
     */
    orderBy?: ProveedoresOrderByWithRelationInput | ProveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proveedores
    **/
    _count?: true | ProveedoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedoresMaxAggregateInputType
  }

  export type GetProveedoresAggregateType<T extends ProveedoresAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedores[P]>
      : GetScalarType<T[P], AggregateProveedores[P]>
  }




  export type ProveedoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProveedoresWhereInput
    orderBy?: ProveedoresOrderByWithAggregationInput | ProveedoresOrderByWithAggregationInput[]
    by: ProveedoresScalarFieldEnum[] | ProveedoresScalarFieldEnum
    having?: ProveedoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedoresCountAggregateInputType | true
    _avg?: ProveedoresAvgAggregateInputType
    _sum?: ProveedoresSumAggregateInputType
    _min?: ProveedoresMinAggregateInputType
    _max?: ProveedoresMaxAggregateInputType
  }

  export type ProveedoresGroupByOutputType = {
    Id: number
    Nombre: string
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  type GetProveedoresGroupByPayload<T extends ProveedoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
        }
      >
    >


  export type ProveedoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Nombre?: boolean
    Compras?: boolean | Proveedores$ComprasArgs<ExtArgs>
    _count?: boolean | ProveedoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proveedores"]>



  export type ProveedoresSelectScalar = {
    Id?: boolean
    Nombre?: boolean
  }

  export type ProveedoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Nombre", ExtArgs["result"]["proveedores"]>
  export type ProveedoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | Proveedores$ComprasArgs<ExtArgs>
    _count?: boolean | ProveedoresCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProveedoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proveedores"
    objects: {
      Compras: Prisma.$ComprasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Nombre: string
    }, ExtArgs["result"]["proveedores"]>
    composites: {}
  }

  type ProveedoresGetPayload<S extends boolean | null | undefined | ProveedoresDefaultArgs> = $Result.GetResult<Prisma.$ProveedoresPayload, S>

  type ProveedoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProveedoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProveedoresCountAggregateInputType | true
    }

  export interface ProveedoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proveedores'], meta: { name: 'Proveedores' } }
    /**
     * Find zero or one Proveedores that matches the filter.
     * @param {ProveedoresFindUniqueArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProveedoresFindUniqueArgs>(args: SelectSubset<T, ProveedoresFindUniqueArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proveedores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProveedoresFindUniqueOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProveedoresFindUniqueOrThrowArgs>(args: SelectSubset<T, ProveedoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresFindFirstArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProveedoresFindFirstArgs>(args?: SelectSubset<T, ProveedoresFindFirstArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proveedores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresFindFirstOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProveedoresFindFirstOrThrowArgs>(args?: SelectSubset<T, ProveedoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedores
     * const proveedores = await prisma.proveedores.findMany()
     * 
     * // Get first 10 Proveedores
     * const proveedores = await prisma.proveedores.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const proveedoresWithIdOnly = await prisma.proveedores.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends ProveedoresFindManyArgs>(args?: SelectSubset<T, ProveedoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proveedores.
     * @param {ProveedoresCreateArgs} args - Arguments to create a Proveedores.
     * @example
     * // Create one Proveedores
     * const Proveedores = await prisma.proveedores.create({
     *   data: {
     *     // ... data to create a Proveedores
     *   }
     * })
     * 
     */
    create<T extends ProveedoresCreateArgs>(args: SelectSubset<T, ProveedoresCreateArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proveedores.
     * @param {ProveedoresCreateManyArgs} args - Arguments to create many Proveedores.
     * @example
     * // Create many Proveedores
     * const proveedores = await prisma.proveedores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProveedoresCreateManyArgs>(args?: SelectSubset<T, ProveedoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedores.
     * @param {ProveedoresDeleteArgs} args - Arguments to delete one Proveedores.
     * @example
     * // Delete one Proveedores
     * const Proveedores = await prisma.proveedores.delete({
     *   where: {
     *     // ... filter to delete one Proveedores
     *   }
     * })
     * 
     */
    delete<T extends ProveedoresDeleteArgs>(args: SelectSubset<T, ProveedoresDeleteArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proveedores.
     * @param {ProveedoresUpdateArgs} args - Arguments to update one Proveedores.
     * @example
     * // Update one Proveedores
     * const proveedores = await prisma.proveedores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProveedoresUpdateArgs>(args: SelectSubset<T, ProveedoresUpdateArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proveedores.
     * @param {ProveedoresDeleteManyArgs} args - Arguments to filter Proveedores to delete.
     * @example
     * // Delete a few Proveedores
     * const { count } = await prisma.proveedores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProveedoresDeleteManyArgs>(args?: SelectSubset<T, ProveedoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedores
     * const proveedores = await prisma.proveedores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProveedoresUpdateManyArgs>(args: SelectSubset<T, ProveedoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedores.
     * @param {ProveedoresUpsertArgs} args - Arguments to update or create a Proveedores.
     * @example
     * // Update or create a Proveedores
     * const proveedores = await prisma.proveedores.upsert({
     *   create: {
     *     // ... data to create a Proveedores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedores we want to update
     *   }
     * })
     */
    upsert<T extends ProveedoresUpsertArgs>(args: SelectSubset<T, ProveedoresUpsertArgs<ExtArgs>>): Prisma__ProveedoresClient<$Result.GetResult<Prisma.$ProveedoresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresCountArgs} args - Arguments to filter Proveedores to count.
     * @example
     * // Count the number of Proveedores
     * const count = await prisma.proveedores.count({
     *   where: {
     *     // ... the filter for the Proveedores we want to count
     *   }
     * })
    **/
    count<T extends ProveedoresCountArgs>(
      args?: Subset<T, ProveedoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedoresAggregateArgs>(args: Subset<T, ProveedoresAggregateArgs>): Prisma.PrismaPromise<GetProveedoresAggregateType<T>>

    /**
     * Group by Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProveedoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProveedoresGroupByArgs['orderBy'] }
        : { orderBy?: ProveedoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProveedoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proveedores model
   */
  readonly fields: ProveedoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proveedores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProveedoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Compras<T extends Proveedores$ComprasArgs<ExtArgs> = {}>(args?: Subset<T, Proveedores$ComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proveedores model
   */
  interface ProveedoresFieldRefs {
    readonly Id: FieldRef<"Proveedores", 'Int'>
    readonly Nombre: FieldRef<"Proveedores", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Proveedores findUnique
   */
  export type ProveedoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * Filter, which Proveedores to fetch.
     */
    where: ProveedoresWhereUniqueInput
  }

  /**
   * Proveedores findUniqueOrThrow
   */
  export type ProveedoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * Filter, which Proveedores to fetch.
     */
    where: ProveedoresWhereUniqueInput
  }

  /**
   * Proveedores findFirst
   */
  export type ProveedoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * Filter, which Proveedores to fetch.
     */
    where?: ProveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedores to fetch.
     */
    orderBy?: ProveedoresOrderByWithRelationInput | ProveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedores.
     */
    cursor?: ProveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * Proveedores findFirstOrThrow
   */
  export type ProveedoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * Filter, which Proveedores to fetch.
     */
    where?: ProveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedores to fetch.
     */
    orderBy?: ProveedoresOrderByWithRelationInput | ProveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedores.
     */
    cursor?: ProveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * Proveedores findMany
   */
  export type ProveedoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * Filter, which Proveedores to fetch.
     */
    where?: ProveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedores to fetch.
     */
    orderBy?: ProveedoresOrderByWithRelationInput | ProveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proveedores.
     */
    cursor?: ProveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedores.
     */
    skip?: number
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * Proveedores create
   */
  export type ProveedoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * The data needed to create a Proveedores.
     */
    data: XOR<ProveedoresCreateInput, ProveedoresUncheckedCreateInput>
  }

  /**
   * Proveedores createMany
   */
  export type ProveedoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proveedores.
     */
    data: ProveedoresCreateManyInput | ProveedoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proveedores update
   */
  export type ProveedoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * The data needed to update a Proveedores.
     */
    data: XOR<ProveedoresUpdateInput, ProveedoresUncheckedUpdateInput>
    /**
     * Choose, which Proveedores to update.
     */
    where: ProveedoresWhereUniqueInput
  }

  /**
   * Proveedores updateMany
   */
  export type ProveedoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proveedores.
     */
    data: XOR<ProveedoresUpdateManyMutationInput, ProveedoresUncheckedUpdateManyInput>
    /**
     * Filter which Proveedores to update
     */
    where?: ProveedoresWhereInput
    /**
     * Limit how many Proveedores to update.
     */
    limit?: number
  }

  /**
   * Proveedores upsert
   */
  export type ProveedoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * The filter to search for the Proveedores to update in case it exists.
     */
    where: ProveedoresWhereUniqueInput
    /**
     * In case the Proveedores found by the `where` argument doesn't exist, create a new Proveedores with this data.
     */
    create: XOR<ProveedoresCreateInput, ProveedoresUncheckedCreateInput>
    /**
     * In case the Proveedores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProveedoresUpdateInput, ProveedoresUncheckedUpdateInput>
  }

  /**
   * Proveedores delete
   */
  export type ProveedoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
    /**
     * Filter which Proveedores to delete.
     */
    where: ProveedoresWhereUniqueInput
  }

  /**
   * Proveedores deleteMany
   */
  export type ProveedoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proveedores to delete
     */
    where?: ProveedoresWhereInput
    /**
     * Limit how many Proveedores to delete.
     */
    limit?: number
  }

  /**
   * Proveedores.Compras
   */
  export type Proveedores$ComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    where?: ComprasWhereInput
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    cursor?: ComprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * Proveedores without action
   */
  export type ProveedoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedores
     */
    select?: ProveedoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedores
     */
    omit?: ProveedoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedoresInclude<ExtArgs> | null
  }


  /**
   * Model RolesUSuario
   */

  export type AggregateRolesUSuario = {
    _count: RolesUSuarioCountAggregateOutputType | null
    _avg: RolesUSuarioAvgAggregateOutputType | null
    _sum: RolesUSuarioSumAggregateOutputType | null
    _min: RolesUSuarioMinAggregateOutputType | null
    _max: RolesUSuarioMaxAggregateOutputType | null
  }

  export type RolesUSuarioAvgAggregateOutputType = {
    Id: number | null
  }

  export type RolesUSuarioSumAggregateOutputType = {
    Id: number | null
  }

  export type RolesUSuarioMinAggregateOutputType = {
    Id: number | null
    Nombre: string | null
  }

  export type RolesUSuarioMaxAggregateOutputType = {
    Id: number | null
    Nombre: string | null
  }

  export type RolesUSuarioCountAggregateOutputType = {
    Id: number
    Nombre: number
    _all: number
  }


  export type RolesUSuarioAvgAggregateInputType = {
    Id?: true
  }

  export type RolesUSuarioSumAggregateInputType = {
    Id?: true
  }

  export type RolesUSuarioMinAggregateInputType = {
    Id?: true
    Nombre?: true
  }

  export type RolesUSuarioMaxAggregateInputType = {
    Id?: true
    Nombre?: true
  }

  export type RolesUSuarioCountAggregateInputType = {
    Id?: true
    Nombre?: true
    _all?: true
  }

  export type RolesUSuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolesUSuario to aggregate.
     */
    where?: RolesUSuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesUSuarios to fetch.
     */
    orderBy?: RolesUSuarioOrderByWithRelationInput | RolesUSuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesUSuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesUSuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesUSuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolesUSuarios
    **/
    _count?: true | RolesUSuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesUSuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesUSuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesUSuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesUSuarioMaxAggregateInputType
  }

  export type GetRolesUSuarioAggregateType<T extends RolesUSuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateRolesUSuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolesUSuario[P]>
      : GetScalarType<T[P], AggregateRolesUSuario[P]>
  }




  export type RolesUSuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesUSuarioWhereInput
    orderBy?: RolesUSuarioOrderByWithAggregationInput | RolesUSuarioOrderByWithAggregationInput[]
    by: RolesUSuarioScalarFieldEnum[] | RolesUSuarioScalarFieldEnum
    having?: RolesUSuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesUSuarioCountAggregateInputType | true
    _avg?: RolesUSuarioAvgAggregateInputType
    _sum?: RolesUSuarioSumAggregateInputType
    _min?: RolesUSuarioMinAggregateInputType
    _max?: RolesUSuarioMaxAggregateInputType
  }

  export type RolesUSuarioGroupByOutputType = {
    Id: number
    Nombre: string
    _count: RolesUSuarioCountAggregateOutputType | null
    _avg: RolesUSuarioAvgAggregateOutputType | null
    _sum: RolesUSuarioSumAggregateOutputType | null
    _min: RolesUSuarioMinAggregateOutputType | null
    _max: RolesUSuarioMaxAggregateOutputType | null
  }

  type GetRolesUSuarioGroupByPayload<T extends RolesUSuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesUSuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesUSuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesUSuarioGroupByOutputType[P]>
            : GetScalarType<T[P], RolesUSuarioGroupByOutputType[P]>
        }
      >
    >


  export type RolesUSuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Nombre?: boolean
    Usuarios?: boolean | RolesUSuario$UsuariosArgs<ExtArgs>
    _count?: boolean | RolesUSuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolesUSuario"]>



  export type RolesUSuarioSelectScalar = {
    Id?: boolean
    Nombre?: boolean
  }

  export type RolesUSuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Nombre", ExtArgs["result"]["rolesUSuario"]>
  export type RolesUSuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuarios?: boolean | RolesUSuario$UsuariosArgs<ExtArgs>
    _count?: boolean | RolesUSuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolesUSuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolesUSuario"
    objects: {
      Usuarios: Prisma.$UsuariosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Nombre: string
    }, ExtArgs["result"]["rolesUSuario"]>
    composites: {}
  }

  type RolesUSuarioGetPayload<S extends boolean | null | undefined | RolesUSuarioDefaultArgs> = $Result.GetResult<Prisma.$RolesUSuarioPayload, S>

  type RolesUSuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesUSuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesUSuarioCountAggregateInputType | true
    }

  export interface RolesUSuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolesUSuario'], meta: { name: 'RolesUSuario' } }
    /**
     * Find zero or one RolesUSuario that matches the filter.
     * @param {RolesUSuarioFindUniqueArgs} args - Arguments to find a RolesUSuario
     * @example
     * // Get one RolesUSuario
     * const rolesUSuario = await prisma.rolesUSuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesUSuarioFindUniqueArgs>(args: SelectSubset<T, RolesUSuarioFindUniqueArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolesUSuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesUSuarioFindUniqueOrThrowArgs} args - Arguments to find a RolesUSuario
     * @example
     * // Get one RolesUSuario
     * const rolesUSuario = await prisma.rolesUSuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesUSuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesUSuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolesUSuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUSuarioFindFirstArgs} args - Arguments to find a RolesUSuario
     * @example
     * // Get one RolesUSuario
     * const rolesUSuario = await prisma.rolesUSuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesUSuarioFindFirstArgs>(args?: SelectSubset<T, RolesUSuarioFindFirstArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolesUSuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUSuarioFindFirstOrThrowArgs} args - Arguments to find a RolesUSuario
     * @example
     * // Get one RolesUSuario
     * const rolesUSuario = await prisma.rolesUSuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesUSuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesUSuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolesUSuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUSuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolesUSuarios
     * const rolesUSuarios = await prisma.rolesUSuario.findMany()
     * 
     * // Get first 10 RolesUSuarios
     * const rolesUSuarios = await prisma.rolesUSuario.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const rolesUSuarioWithIdOnly = await prisma.rolesUSuario.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends RolesUSuarioFindManyArgs>(args?: SelectSubset<T, RolesUSuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolesUSuario.
     * @param {RolesUSuarioCreateArgs} args - Arguments to create a RolesUSuario.
     * @example
     * // Create one RolesUSuario
     * const RolesUSuario = await prisma.rolesUSuario.create({
     *   data: {
     *     // ... data to create a RolesUSuario
     *   }
     * })
     * 
     */
    create<T extends RolesUSuarioCreateArgs>(args: SelectSubset<T, RolesUSuarioCreateArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolesUSuarios.
     * @param {RolesUSuarioCreateManyArgs} args - Arguments to create many RolesUSuarios.
     * @example
     * // Create many RolesUSuarios
     * const rolesUSuario = await prisma.rolesUSuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesUSuarioCreateManyArgs>(args?: SelectSubset<T, RolesUSuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolesUSuario.
     * @param {RolesUSuarioDeleteArgs} args - Arguments to delete one RolesUSuario.
     * @example
     * // Delete one RolesUSuario
     * const RolesUSuario = await prisma.rolesUSuario.delete({
     *   where: {
     *     // ... filter to delete one RolesUSuario
     *   }
     * })
     * 
     */
    delete<T extends RolesUSuarioDeleteArgs>(args: SelectSubset<T, RolesUSuarioDeleteArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolesUSuario.
     * @param {RolesUSuarioUpdateArgs} args - Arguments to update one RolesUSuario.
     * @example
     * // Update one RolesUSuario
     * const rolesUSuario = await prisma.rolesUSuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUSuarioUpdateArgs>(args: SelectSubset<T, RolesUSuarioUpdateArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolesUSuarios.
     * @param {RolesUSuarioDeleteManyArgs} args - Arguments to filter RolesUSuarios to delete.
     * @example
     * // Delete a few RolesUSuarios
     * const { count } = await prisma.rolesUSuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesUSuarioDeleteManyArgs>(args?: SelectSubset<T, RolesUSuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolesUSuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUSuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolesUSuarios
     * const rolesUSuario = await prisma.rolesUSuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUSuarioUpdateManyArgs>(args: SelectSubset<T, RolesUSuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolesUSuario.
     * @param {RolesUSuarioUpsertArgs} args - Arguments to update or create a RolesUSuario.
     * @example
     * // Update or create a RolesUSuario
     * const rolesUSuario = await prisma.rolesUSuario.upsert({
     *   create: {
     *     // ... data to create a RolesUSuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolesUSuario we want to update
     *   }
     * })
     */
    upsert<T extends RolesUSuarioUpsertArgs>(args: SelectSubset<T, RolesUSuarioUpsertArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolesUSuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUSuarioCountArgs} args - Arguments to filter RolesUSuarios to count.
     * @example
     * // Count the number of RolesUSuarios
     * const count = await prisma.rolesUSuario.count({
     *   where: {
     *     // ... the filter for the RolesUSuarios we want to count
     *   }
     * })
    **/
    count<T extends RolesUSuarioCountArgs>(
      args?: Subset<T, RolesUSuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesUSuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolesUSuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUSuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesUSuarioAggregateArgs>(args: Subset<T, RolesUSuarioAggregateArgs>): Prisma.PrismaPromise<GetRolesUSuarioAggregateType<T>>

    /**
     * Group by RolesUSuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUSuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesUSuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesUSuarioGroupByArgs['orderBy'] }
        : { orderBy?: RolesUSuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesUSuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesUSuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolesUSuario model
   */
  readonly fields: RolesUSuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolesUSuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesUSuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuarios<T extends RolesUSuario$UsuariosArgs<ExtArgs> = {}>(args?: Subset<T, RolesUSuario$UsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolesUSuario model
   */
  interface RolesUSuarioFieldRefs {
    readonly Id: FieldRef<"RolesUSuario", 'Int'>
    readonly Nombre: FieldRef<"RolesUSuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolesUSuario findUnique
   */
  export type RolesUSuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolesUSuario to fetch.
     */
    where: RolesUSuarioWhereUniqueInput
  }

  /**
   * RolesUSuario findUniqueOrThrow
   */
  export type RolesUSuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolesUSuario to fetch.
     */
    where: RolesUSuarioWhereUniqueInput
  }

  /**
   * RolesUSuario findFirst
   */
  export type RolesUSuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolesUSuario to fetch.
     */
    where?: RolesUSuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesUSuarios to fetch.
     */
    orderBy?: RolesUSuarioOrderByWithRelationInput | RolesUSuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolesUSuarios.
     */
    cursor?: RolesUSuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesUSuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesUSuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolesUSuarios.
     */
    distinct?: RolesUSuarioScalarFieldEnum | RolesUSuarioScalarFieldEnum[]
  }

  /**
   * RolesUSuario findFirstOrThrow
   */
  export type RolesUSuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolesUSuario to fetch.
     */
    where?: RolesUSuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesUSuarios to fetch.
     */
    orderBy?: RolesUSuarioOrderByWithRelationInput | RolesUSuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolesUSuarios.
     */
    cursor?: RolesUSuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesUSuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesUSuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolesUSuarios.
     */
    distinct?: RolesUSuarioScalarFieldEnum | RolesUSuarioScalarFieldEnum[]
  }

  /**
   * RolesUSuario findMany
   */
  export type RolesUSuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * Filter, which RolesUSuarios to fetch.
     */
    where?: RolesUSuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesUSuarios to fetch.
     */
    orderBy?: RolesUSuarioOrderByWithRelationInput | RolesUSuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolesUSuarios.
     */
    cursor?: RolesUSuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesUSuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesUSuarios.
     */
    skip?: number
    distinct?: RolesUSuarioScalarFieldEnum | RolesUSuarioScalarFieldEnum[]
  }

  /**
   * RolesUSuario create
   */
  export type RolesUSuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a RolesUSuario.
     */
    data: XOR<RolesUSuarioCreateInput, RolesUSuarioUncheckedCreateInput>
  }

  /**
   * RolesUSuario createMany
   */
  export type RolesUSuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolesUSuarios.
     */
    data: RolesUSuarioCreateManyInput | RolesUSuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolesUSuario update
   */
  export type RolesUSuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a RolesUSuario.
     */
    data: XOR<RolesUSuarioUpdateInput, RolesUSuarioUncheckedUpdateInput>
    /**
     * Choose, which RolesUSuario to update.
     */
    where: RolesUSuarioWhereUniqueInput
  }

  /**
   * RolesUSuario updateMany
   */
  export type RolesUSuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolesUSuarios.
     */
    data: XOR<RolesUSuarioUpdateManyMutationInput, RolesUSuarioUncheckedUpdateManyInput>
    /**
     * Filter which RolesUSuarios to update
     */
    where?: RolesUSuarioWhereInput
    /**
     * Limit how many RolesUSuarios to update.
     */
    limit?: number
  }

  /**
   * RolesUSuario upsert
   */
  export type RolesUSuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the RolesUSuario to update in case it exists.
     */
    where: RolesUSuarioWhereUniqueInput
    /**
     * In case the RolesUSuario found by the `where` argument doesn't exist, create a new RolesUSuario with this data.
     */
    create: XOR<RolesUSuarioCreateInput, RolesUSuarioUncheckedCreateInput>
    /**
     * In case the RolesUSuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUSuarioUpdateInput, RolesUSuarioUncheckedUpdateInput>
  }

  /**
   * RolesUSuario delete
   */
  export type RolesUSuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    /**
     * Filter which RolesUSuario to delete.
     */
    where: RolesUSuarioWhereUniqueInput
  }

  /**
   * RolesUSuario deleteMany
   */
  export type RolesUSuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolesUSuarios to delete
     */
    where?: RolesUSuarioWhereInput
    /**
     * Limit how many RolesUSuarios to delete.
     */
    limit?: number
  }

  /**
   * RolesUSuario.Usuarios
   */
  export type RolesUSuario$UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    cursor?: UsuariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * RolesUSuario without action
   */
  export type RolesUSuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
  }


  /**
   * Model TiposCompra
   */

  export type AggregateTiposCompra = {
    _count: TiposCompraCountAggregateOutputType | null
    _avg: TiposCompraAvgAggregateOutputType | null
    _sum: TiposCompraSumAggregateOutputType | null
    _min: TiposCompraMinAggregateOutputType | null
    _max: TiposCompraMaxAggregateOutputType | null
  }

  export type TiposCompraAvgAggregateOutputType = {
    Id: number | null
  }

  export type TiposCompraSumAggregateOutputType = {
    Id: number | null
  }

  export type TiposCompraMinAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
  }

  export type TiposCompraMaxAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
  }

  export type TiposCompraCountAggregateOutputType = {
    Id: number
    Code: number
    Nombre: number
    _all: number
  }


  export type TiposCompraAvgAggregateInputType = {
    Id?: true
  }

  export type TiposCompraSumAggregateInputType = {
    Id?: true
  }

  export type TiposCompraMinAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
  }

  export type TiposCompraMaxAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
  }

  export type TiposCompraCountAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
    _all?: true
  }

  export type TiposCompraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TiposCompra to aggregate.
     */
    where?: TiposCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiposCompras to fetch.
     */
    orderBy?: TiposCompraOrderByWithRelationInput | TiposCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TiposCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiposCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiposCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TiposCompras
    **/
    _count?: true | TiposCompraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TiposCompraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TiposCompraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TiposCompraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TiposCompraMaxAggregateInputType
  }

  export type GetTiposCompraAggregateType<T extends TiposCompraAggregateArgs> = {
        [P in keyof T & keyof AggregateTiposCompra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTiposCompra[P]>
      : GetScalarType<T[P], AggregateTiposCompra[P]>
  }




  export type TiposCompraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiposCompraWhereInput
    orderBy?: TiposCompraOrderByWithAggregationInput | TiposCompraOrderByWithAggregationInput[]
    by: TiposCompraScalarFieldEnum[] | TiposCompraScalarFieldEnum
    having?: TiposCompraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TiposCompraCountAggregateInputType | true
    _avg?: TiposCompraAvgAggregateInputType
    _sum?: TiposCompraSumAggregateInputType
    _min?: TiposCompraMinAggregateInputType
    _max?: TiposCompraMaxAggregateInputType
  }

  export type TiposCompraGroupByOutputType = {
    Id: number
    Code: string
    Nombre: string
    _count: TiposCompraCountAggregateOutputType | null
    _avg: TiposCompraAvgAggregateOutputType | null
    _sum: TiposCompraSumAggregateOutputType | null
    _min: TiposCompraMinAggregateOutputType | null
    _max: TiposCompraMaxAggregateOutputType | null
  }

  type GetTiposCompraGroupByPayload<T extends TiposCompraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TiposCompraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TiposCompraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TiposCompraGroupByOutputType[P]>
            : GetScalarType<T[P], TiposCompraGroupByOutputType[P]>
        }
      >
    >


  export type TiposCompraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
    Compras?: boolean | TiposCompra$ComprasArgs<ExtArgs>
    _count?: boolean | TiposCompraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tiposCompra"]>



  export type TiposCompraSelectScalar = {
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
  }

  export type TiposCompraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Code" | "Nombre", ExtArgs["result"]["tiposCompra"]>
  export type TiposCompraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Compras?: boolean | TiposCompra$ComprasArgs<ExtArgs>
    _count?: boolean | TiposCompraCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TiposCompraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TiposCompra"
    objects: {
      Compras: Prisma.$ComprasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Code: string
      Nombre: string
    }, ExtArgs["result"]["tiposCompra"]>
    composites: {}
  }

  type TiposCompraGetPayload<S extends boolean | null | undefined | TiposCompraDefaultArgs> = $Result.GetResult<Prisma.$TiposCompraPayload, S>

  type TiposCompraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TiposCompraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TiposCompraCountAggregateInputType | true
    }

  export interface TiposCompraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TiposCompra'], meta: { name: 'TiposCompra' } }
    /**
     * Find zero or one TiposCompra that matches the filter.
     * @param {TiposCompraFindUniqueArgs} args - Arguments to find a TiposCompra
     * @example
     * // Get one TiposCompra
     * const tiposCompra = await prisma.tiposCompra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TiposCompraFindUniqueArgs>(args: SelectSubset<T, TiposCompraFindUniqueArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TiposCompra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TiposCompraFindUniqueOrThrowArgs} args - Arguments to find a TiposCompra
     * @example
     * // Get one TiposCompra
     * const tiposCompra = await prisma.tiposCompra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TiposCompraFindUniqueOrThrowArgs>(args: SelectSubset<T, TiposCompraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TiposCompra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposCompraFindFirstArgs} args - Arguments to find a TiposCompra
     * @example
     * // Get one TiposCompra
     * const tiposCompra = await prisma.tiposCompra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TiposCompraFindFirstArgs>(args?: SelectSubset<T, TiposCompraFindFirstArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TiposCompra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposCompraFindFirstOrThrowArgs} args - Arguments to find a TiposCompra
     * @example
     * // Get one TiposCompra
     * const tiposCompra = await prisma.tiposCompra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TiposCompraFindFirstOrThrowArgs>(args?: SelectSubset<T, TiposCompraFindFirstOrThrowArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TiposCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposCompraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TiposCompras
     * const tiposCompras = await prisma.tiposCompra.findMany()
     * 
     * // Get first 10 TiposCompras
     * const tiposCompras = await prisma.tiposCompra.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const tiposCompraWithIdOnly = await prisma.tiposCompra.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends TiposCompraFindManyArgs>(args?: SelectSubset<T, TiposCompraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TiposCompra.
     * @param {TiposCompraCreateArgs} args - Arguments to create a TiposCompra.
     * @example
     * // Create one TiposCompra
     * const TiposCompra = await prisma.tiposCompra.create({
     *   data: {
     *     // ... data to create a TiposCompra
     *   }
     * })
     * 
     */
    create<T extends TiposCompraCreateArgs>(args: SelectSubset<T, TiposCompraCreateArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TiposCompras.
     * @param {TiposCompraCreateManyArgs} args - Arguments to create many TiposCompras.
     * @example
     * // Create many TiposCompras
     * const tiposCompra = await prisma.tiposCompra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TiposCompraCreateManyArgs>(args?: SelectSubset<T, TiposCompraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TiposCompra.
     * @param {TiposCompraDeleteArgs} args - Arguments to delete one TiposCompra.
     * @example
     * // Delete one TiposCompra
     * const TiposCompra = await prisma.tiposCompra.delete({
     *   where: {
     *     // ... filter to delete one TiposCompra
     *   }
     * })
     * 
     */
    delete<T extends TiposCompraDeleteArgs>(args: SelectSubset<T, TiposCompraDeleteArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TiposCompra.
     * @param {TiposCompraUpdateArgs} args - Arguments to update one TiposCompra.
     * @example
     * // Update one TiposCompra
     * const tiposCompra = await prisma.tiposCompra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TiposCompraUpdateArgs>(args: SelectSubset<T, TiposCompraUpdateArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TiposCompras.
     * @param {TiposCompraDeleteManyArgs} args - Arguments to filter TiposCompras to delete.
     * @example
     * // Delete a few TiposCompras
     * const { count } = await prisma.tiposCompra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TiposCompraDeleteManyArgs>(args?: SelectSubset<T, TiposCompraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TiposCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposCompraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TiposCompras
     * const tiposCompra = await prisma.tiposCompra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TiposCompraUpdateManyArgs>(args: SelectSubset<T, TiposCompraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TiposCompra.
     * @param {TiposCompraUpsertArgs} args - Arguments to update or create a TiposCompra.
     * @example
     * // Update or create a TiposCompra
     * const tiposCompra = await prisma.tiposCompra.upsert({
     *   create: {
     *     // ... data to create a TiposCompra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TiposCompra we want to update
     *   }
     * })
     */
    upsert<T extends TiposCompraUpsertArgs>(args: SelectSubset<T, TiposCompraUpsertArgs<ExtArgs>>): Prisma__TiposCompraClient<$Result.GetResult<Prisma.$TiposCompraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TiposCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposCompraCountArgs} args - Arguments to filter TiposCompras to count.
     * @example
     * // Count the number of TiposCompras
     * const count = await prisma.tiposCompra.count({
     *   where: {
     *     // ... the filter for the TiposCompras we want to count
     *   }
     * })
    **/
    count<T extends TiposCompraCountArgs>(
      args?: Subset<T, TiposCompraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TiposCompraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TiposCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposCompraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TiposCompraAggregateArgs>(args: Subset<T, TiposCompraAggregateArgs>): Prisma.PrismaPromise<GetTiposCompraAggregateType<T>>

    /**
     * Group by TiposCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposCompraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TiposCompraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TiposCompraGroupByArgs['orderBy'] }
        : { orderBy?: TiposCompraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TiposCompraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTiposCompraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TiposCompra model
   */
  readonly fields: TiposCompraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TiposCompra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TiposCompraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Compras<T extends TiposCompra$ComprasArgs<ExtArgs> = {}>(args?: Subset<T, TiposCompra$ComprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TiposCompra model
   */
  interface TiposCompraFieldRefs {
    readonly Id: FieldRef<"TiposCompra", 'Int'>
    readonly Code: FieldRef<"TiposCompra", 'String'>
    readonly Nombre: FieldRef<"TiposCompra", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TiposCompra findUnique
   */
  export type TiposCompraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * Filter, which TiposCompra to fetch.
     */
    where: TiposCompraWhereUniqueInput
  }

  /**
   * TiposCompra findUniqueOrThrow
   */
  export type TiposCompraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * Filter, which TiposCompra to fetch.
     */
    where: TiposCompraWhereUniqueInput
  }

  /**
   * TiposCompra findFirst
   */
  export type TiposCompraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * Filter, which TiposCompra to fetch.
     */
    where?: TiposCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiposCompras to fetch.
     */
    orderBy?: TiposCompraOrderByWithRelationInput | TiposCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TiposCompras.
     */
    cursor?: TiposCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiposCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiposCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TiposCompras.
     */
    distinct?: TiposCompraScalarFieldEnum | TiposCompraScalarFieldEnum[]
  }

  /**
   * TiposCompra findFirstOrThrow
   */
  export type TiposCompraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * Filter, which TiposCompra to fetch.
     */
    where?: TiposCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiposCompras to fetch.
     */
    orderBy?: TiposCompraOrderByWithRelationInput | TiposCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TiposCompras.
     */
    cursor?: TiposCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiposCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiposCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TiposCompras.
     */
    distinct?: TiposCompraScalarFieldEnum | TiposCompraScalarFieldEnum[]
  }

  /**
   * TiposCompra findMany
   */
  export type TiposCompraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * Filter, which TiposCompras to fetch.
     */
    where?: TiposCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiposCompras to fetch.
     */
    orderBy?: TiposCompraOrderByWithRelationInput | TiposCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TiposCompras.
     */
    cursor?: TiposCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiposCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiposCompras.
     */
    skip?: number
    distinct?: TiposCompraScalarFieldEnum | TiposCompraScalarFieldEnum[]
  }

  /**
   * TiposCompra create
   */
  export type TiposCompraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * The data needed to create a TiposCompra.
     */
    data: XOR<TiposCompraCreateInput, TiposCompraUncheckedCreateInput>
  }

  /**
   * TiposCompra createMany
   */
  export type TiposCompraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TiposCompras.
     */
    data: TiposCompraCreateManyInput | TiposCompraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TiposCompra update
   */
  export type TiposCompraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * The data needed to update a TiposCompra.
     */
    data: XOR<TiposCompraUpdateInput, TiposCompraUncheckedUpdateInput>
    /**
     * Choose, which TiposCompra to update.
     */
    where: TiposCompraWhereUniqueInput
  }

  /**
   * TiposCompra updateMany
   */
  export type TiposCompraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TiposCompras.
     */
    data: XOR<TiposCompraUpdateManyMutationInput, TiposCompraUncheckedUpdateManyInput>
    /**
     * Filter which TiposCompras to update
     */
    where?: TiposCompraWhereInput
    /**
     * Limit how many TiposCompras to update.
     */
    limit?: number
  }

  /**
   * TiposCompra upsert
   */
  export type TiposCompraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * The filter to search for the TiposCompra to update in case it exists.
     */
    where: TiposCompraWhereUniqueInput
    /**
     * In case the TiposCompra found by the `where` argument doesn't exist, create a new TiposCompra with this data.
     */
    create: XOR<TiposCompraCreateInput, TiposCompraUncheckedCreateInput>
    /**
     * In case the TiposCompra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TiposCompraUpdateInput, TiposCompraUncheckedUpdateInput>
  }

  /**
   * TiposCompra delete
   */
  export type TiposCompraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
    /**
     * Filter which TiposCompra to delete.
     */
    where: TiposCompraWhereUniqueInput
  }

  /**
   * TiposCompra deleteMany
   */
  export type TiposCompraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TiposCompras to delete
     */
    where?: TiposCompraWhereInput
    /**
     * Limit how many TiposCompras to delete.
     */
    limit?: number
  }

  /**
   * TiposCompra.Compras
   */
  export type TiposCompra$ComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compras
     */
    select?: ComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compras
     */
    omit?: ComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprasInclude<ExtArgs> | null
    where?: ComprasWhereInput
    orderBy?: ComprasOrderByWithRelationInput | ComprasOrderByWithRelationInput[]
    cursor?: ComprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * TiposCompra without action
   */
  export type TiposCompraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiposCompra
     */
    select?: TiposCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TiposCompra
     */
    omit?: TiposCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiposCompraInclude<ExtArgs> | null
  }


  /**
   * Model UnidadesMedida
   */

  export type AggregateUnidadesMedida = {
    _count: UnidadesMedidaCountAggregateOutputType | null
    _avg: UnidadesMedidaAvgAggregateOutputType | null
    _sum: UnidadesMedidaSumAggregateOutputType | null
    _min: UnidadesMedidaMinAggregateOutputType | null
    _max: UnidadesMedidaMaxAggregateOutputType | null
  }

  export type UnidadesMedidaAvgAggregateOutputType = {
    Id: number | null
  }

  export type UnidadesMedidaSumAggregateOutputType = {
    Id: number | null
  }

  export type UnidadesMedidaMinAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
  }

  export type UnidadesMedidaMaxAggregateOutputType = {
    Id: number | null
    Code: string | null
    Nombre: string | null
  }

  export type UnidadesMedidaCountAggregateOutputType = {
    Id: number
    Code: number
    Nombre: number
    _all: number
  }


  export type UnidadesMedidaAvgAggregateInputType = {
    Id?: true
  }

  export type UnidadesMedidaSumAggregateInputType = {
    Id?: true
  }

  export type UnidadesMedidaMinAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
  }

  export type UnidadesMedidaMaxAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
  }

  export type UnidadesMedidaCountAggregateInputType = {
    Id?: true
    Code?: true
    Nombre?: true
    _all?: true
  }

  export type UnidadesMedidaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnidadesMedida to aggregate.
     */
    where?: UnidadesMedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadesMedidas to fetch.
     */
    orderBy?: UnidadesMedidaOrderByWithRelationInput | UnidadesMedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnidadesMedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadesMedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadesMedidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnidadesMedidas
    **/
    _count?: true | UnidadesMedidaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnidadesMedidaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnidadesMedidaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnidadesMedidaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnidadesMedidaMaxAggregateInputType
  }

  export type GetUnidadesMedidaAggregateType<T extends UnidadesMedidaAggregateArgs> = {
        [P in keyof T & keyof AggregateUnidadesMedida]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnidadesMedida[P]>
      : GetScalarType<T[P], AggregateUnidadesMedida[P]>
  }




  export type UnidadesMedidaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnidadesMedidaWhereInput
    orderBy?: UnidadesMedidaOrderByWithAggregationInput | UnidadesMedidaOrderByWithAggregationInput[]
    by: UnidadesMedidaScalarFieldEnum[] | UnidadesMedidaScalarFieldEnum
    having?: UnidadesMedidaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnidadesMedidaCountAggregateInputType | true
    _avg?: UnidadesMedidaAvgAggregateInputType
    _sum?: UnidadesMedidaSumAggregateInputType
    _min?: UnidadesMedidaMinAggregateInputType
    _max?: UnidadesMedidaMaxAggregateInputType
  }

  export type UnidadesMedidaGroupByOutputType = {
    Id: number
    Code: string
    Nombre: string | null
    _count: UnidadesMedidaCountAggregateOutputType | null
    _avg: UnidadesMedidaAvgAggregateOutputType | null
    _sum: UnidadesMedidaSumAggregateOutputType | null
    _min: UnidadesMedidaMinAggregateOutputType | null
    _max: UnidadesMedidaMaxAggregateOutputType | null
  }

  type GetUnidadesMedidaGroupByPayload<T extends UnidadesMedidaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnidadesMedidaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnidadesMedidaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnidadesMedidaGroupByOutputType[P]>
            : GetScalarType<T[P], UnidadesMedidaGroupByOutputType[P]>
        }
      >
    >


  export type UnidadesMedidaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
    ListasPrecios?: boolean | UnidadesMedida$ListasPreciosArgs<ExtArgs>
    _count?: boolean | UnidadesMedidaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unidadesMedida"]>



  export type UnidadesMedidaSelectScalar = {
    Id?: boolean
    Code?: boolean
    Nombre?: boolean
  }

  export type UnidadesMedidaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Code" | "Nombre", ExtArgs["result"]["unidadesMedida"]>
  export type UnidadesMedidaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ListasPrecios?: boolean | UnidadesMedida$ListasPreciosArgs<ExtArgs>
    _count?: boolean | UnidadesMedidaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnidadesMedidaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnidadesMedida"
    objects: {
      ListasPrecios: Prisma.$ListasPreciosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Code: string
      Nombre: string | null
    }, ExtArgs["result"]["unidadesMedida"]>
    composites: {}
  }

  type UnidadesMedidaGetPayload<S extends boolean | null | undefined | UnidadesMedidaDefaultArgs> = $Result.GetResult<Prisma.$UnidadesMedidaPayload, S>

  type UnidadesMedidaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnidadesMedidaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnidadesMedidaCountAggregateInputType | true
    }

  export interface UnidadesMedidaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnidadesMedida'], meta: { name: 'UnidadesMedida' } }
    /**
     * Find zero or one UnidadesMedida that matches the filter.
     * @param {UnidadesMedidaFindUniqueArgs} args - Arguments to find a UnidadesMedida
     * @example
     * // Get one UnidadesMedida
     * const unidadesMedida = await prisma.unidadesMedida.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnidadesMedidaFindUniqueArgs>(args: SelectSubset<T, UnidadesMedidaFindUniqueArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnidadesMedida that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnidadesMedidaFindUniqueOrThrowArgs} args - Arguments to find a UnidadesMedida
     * @example
     * // Get one UnidadesMedida
     * const unidadesMedida = await prisma.unidadesMedida.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnidadesMedidaFindUniqueOrThrowArgs>(args: SelectSubset<T, UnidadesMedidaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnidadesMedida that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesMedidaFindFirstArgs} args - Arguments to find a UnidadesMedida
     * @example
     * // Get one UnidadesMedida
     * const unidadesMedida = await prisma.unidadesMedida.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnidadesMedidaFindFirstArgs>(args?: SelectSubset<T, UnidadesMedidaFindFirstArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnidadesMedida that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesMedidaFindFirstOrThrowArgs} args - Arguments to find a UnidadesMedida
     * @example
     * // Get one UnidadesMedida
     * const unidadesMedida = await prisma.unidadesMedida.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnidadesMedidaFindFirstOrThrowArgs>(args?: SelectSubset<T, UnidadesMedidaFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnidadesMedidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesMedidaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnidadesMedidas
     * const unidadesMedidas = await prisma.unidadesMedida.findMany()
     * 
     * // Get first 10 UnidadesMedidas
     * const unidadesMedidas = await prisma.unidadesMedida.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const unidadesMedidaWithIdOnly = await prisma.unidadesMedida.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends UnidadesMedidaFindManyArgs>(args?: SelectSubset<T, UnidadesMedidaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnidadesMedida.
     * @param {UnidadesMedidaCreateArgs} args - Arguments to create a UnidadesMedida.
     * @example
     * // Create one UnidadesMedida
     * const UnidadesMedida = await prisma.unidadesMedida.create({
     *   data: {
     *     // ... data to create a UnidadesMedida
     *   }
     * })
     * 
     */
    create<T extends UnidadesMedidaCreateArgs>(args: SelectSubset<T, UnidadesMedidaCreateArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnidadesMedidas.
     * @param {UnidadesMedidaCreateManyArgs} args - Arguments to create many UnidadesMedidas.
     * @example
     * // Create many UnidadesMedidas
     * const unidadesMedida = await prisma.unidadesMedida.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnidadesMedidaCreateManyArgs>(args?: SelectSubset<T, UnidadesMedidaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnidadesMedida.
     * @param {UnidadesMedidaDeleteArgs} args - Arguments to delete one UnidadesMedida.
     * @example
     * // Delete one UnidadesMedida
     * const UnidadesMedida = await prisma.unidadesMedida.delete({
     *   where: {
     *     // ... filter to delete one UnidadesMedida
     *   }
     * })
     * 
     */
    delete<T extends UnidadesMedidaDeleteArgs>(args: SelectSubset<T, UnidadesMedidaDeleteArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnidadesMedida.
     * @param {UnidadesMedidaUpdateArgs} args - Arguments to update one UnidadesMedida.
     * @example
     * // Update one UnidadesMedida
     * const unidadesMedida = await prisma.unidadesMedida.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnidadesMedidaUpdateArgs>(args: SelectSubset<T, UnidadesMedidaUpdateArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnidadesMedidas.
     * @param {UnidadesMedidaDeleteManyArgs} args - Arguments to filter UnidadesMedidas to delete.
     * @example
     * // Delete a few UnidadesMedidas
     * const { count } = await prisma.unidadesMedida.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnidadesMedidaDeleteManyArgs>(args?: SelectSubset<T, UnidadesMedidaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnidadesMedidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesMedidaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnidadesMedidas
     * const unidadesMedida = await prisma.unidadesMedida.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnidadesMedidaUpdateManyArgs>(args: SelectSubset<T, UnidadesMedidaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnidadesMedida.
     * @param {UnidadesMedidaUpsertArgs} args - Arguments to update or create a UnidadesMedida.
     * @example
     * // Update or create a UnidadesMedida
     * const unidadesMedida = await prisma.unidadesMedida.upsert({
     *   create: {
     *     // ... data to create a UnidadesMedida
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnidadesMedida we want to update
     *   }
     * })
     */
    upsert<T extends UnidadesMedidaUpsertArgs>(args: SelectSubset<T, UnidadesMedidaUpsertArgs<ExtArgs>>): Prisma__UnidadesMedidaClient<$Result.GetResult<Prisma.$UnidadesMedidaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnidadesMedidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesMedidaCountArgs} args - Arguments to filter UnidadesMedidas to count.
     * @example
     * // Count the number of UnidadesMedidas
     * const count = await prisma.unidadesMedida.count({
     *   where: {
     *     // ... the filter for the UnidadesMedidas we want to count
     *   }
     * })
    **/
    count<T extends UnidadesMedidaCountArgs>(
      args?: Subset<T, UnidadesMedidaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnidadesMedidaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnidadesMedida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesMedidaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnidadesMedidaAggregateArgs>(args: Subset<T, UnidadesMedidaAggregateArgs>): Prisma.PrismaPromise<GetUnidadesMedidaAggregateType<T>>

    /**
     * Group by UnidadesMedida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesMedidaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnidadesMedidaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnidadesMedidaGroupByArgs['orderBy'] }
        : { orderBy?: UnidadesMedidaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnidadesMedidaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnidadesMedidaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnidadesMedida model
   */
  readonly fields: UnidadesMedidaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnidadesMedida.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnidadesMedidaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ListasPrecios<T extends UnidadesMedida$ListasPreciosArgs<ExtArgs> = {}>(args?: Subset<T, UnidadesMedida$ListasPreciosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListasPreciosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnidadesMedida model
   */
  interface UnidadesMedidaFieldRefs {
    readonly Id: FieldRef<"UnidadesMedida", 'Int'>
    readonly Code: FieldRef<"UnidadesMedida", 'String'>
    readonly Nombre: FieldRef<"UnidadesMedida", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnidadesMedida findUnique
   */
  export type UnidadesMedidaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * Filter, which UnidadesMedida to fetch.
     */
    where: UnidadesMedidaWhereUniqueInput
  }

  /**
   * UnidadesMedida findUniqueOrThrow
   */
  export type UnidadesMedidaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * Filter, which UnidadesMedida to fetch.
     */
    where: UnidadesMedidaWhereUniqueInput
  }

  /**
   * UnidadesMedida findFirst
   */
  export type UnidadesMedidaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * Filter, which UnidadesMedida to fetch.
     */
    where?: UnidadesMedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadesMedidas to fetch.
     */
    orderBy?: UnidadesMedidaOrderByWithRelationInput | UnidadesMedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnidadesMedidas.
     */
    cursor?: UnidadesMedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadesMedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadesMedidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnidadesMedidas.
     */
    distinct?: UnidadesMedidaScalarFieldEnum | UnidadesMedidaScalarFieldEnum[]
  }

  /**
   * UnidadesMedida findFirstOrThrow
   */
  export type UnidadesMedidaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * Filter, which UnidadesMedida to fetch.
     */
    where?: UnidadesMedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadesMedidas to fetch.
     */
    orderBy?: UnidadesMedidaOrderByWithRelationInput | UnidadesMedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnidadesMedidas.
     */
    cursor?: UnidadesMedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadesMedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadesMedidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnidadesMedidas.
     */
    distinct?: UnidadesMedidaScalarFieldEnum | UnidadesMedidaScalarFieldEnum[]
  }

  /**
   * UnidadesMedida findMany
   */
  export type UnidadesMedidaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * Filter, which UnidadesMedidas to fetch.
     */
    where?: UnidadesMedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadesMedidas to fetch.
     */
    orderBy?: UnidadesMedidaOrderByWithRelationInput | UnidadesMedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnidadesMedidas.
     */
    cursor?: UnidadesMedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadesMedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadesMedidas.
     */
    skip?: number
    distinct?: UnidadesMedidaScalarFieldEnum | UnidadesMedidaScalarFieldEnum[]
  }

  /**
   * UnidadesMedida create
   */
  export type UnidadesMedidaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * The data needed to create a UnidadesMedida.
     */
    data: XOR<UnidadesMedidaCreateInput, UnidadesMedidaUncheckedCreateInput>
  }

  /**
   * UnidadesMedida createMany
   */
  export type UnidadesMedidaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnidadesMedidas.
     */
    data: UnidadesMedidaCreateManyInput | UnidadesMedidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnidadesMedida update
   */
  export type UnidadesMedidaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * The data needed to update a UnidadesMedida.
     */
    data: XOR<UnidadesMedidaUpdateInput, UnidadesMedidaUncheckedUpdateInput>
    /**
     * Choose, which UnidadesMedida to update.
     */
    where: UnidadesMedidaWhereUniqueInput
  }

  /**
   * UnidadesMedida updateMany
   */
  export type UnidadesMedidaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnidadesMedidas.
     */
    data: XOR<UnidadesMedidaUpdateManyMutationInput, UnidadesMedidaUncheckedUpdateManyInput>
    /**
     * Filter which UnidadesMedidas to update
     */
    where?: UnidadesMedidaWhereInput
    /**
     * Limit how many UnidadesMedidas to update.
     */
    limit?: number
  }

  /**
   * UnidadesMedida upsert
   */
  export type UnidadesMedidaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * The filter to search for the UnidadesMedida to update in case it exists.
     */
    where: UnidadesMedidaWhereUniqueInput
    /**
     * In case the UnidadesMedida found by the `where` argument doesn't exist, create a new UnidadesMedida with this data.
     */
    create: XOR<UnidadesMedidaCreateInput, UnidadesMedidaUncheckedCreateInput>
    /**
     * In case the UnidadesMedida was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnidadesMedidaUpdateInput, UnidadesMedidaUncheckedUpdateInput>
  }

  /**
   * UnidadesMedida delete
   */
  export type UnidadesMedidaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
    /**
     * Filter which UnidadesMedida to delete.
     */
    where: UnidadesMedidaWhereUniqueInput
  }

  /**
   * UnidadesMedida deleteMany
   */
  export type UnidadesMedidaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnidadesMedidas to delete
     */
    where?: UnidadesMedidaWhereInput
    /**
     * Limit how many UnidadesMedidas to delete.
     */
    limit?: number
  }

  /**
   * UnidadesMedida.ListasPrecios
   */
  export type UnidadesMedida$ListasPreciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListasPrecios
     */
    select?: ListasPreciosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListasPrecios
     */
    omit?: ListasPreciosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListasPreciosInclude<ExtArgs> | null
    where?: ListasPreciosWhereInput
    orderBy?: ListasPreciosOrderByWithRelationInput | ListasPreciosOrderByWithRelationInput[]
    cursor?: ListasPreciosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListasPreciosScalarFieldEnum | ListasPreciosScalarFieldEnum[]
  }

  /**
   * UnidadesMedida without action
   */
  export type UnidadesMedidaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesMedida
     */
    select?: UnidadesMedidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadesMedida
     */
    omit?: UnidadesMedidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadesMedidaInclude<ExtArgs> | null
  }


  /**
   * Model Usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    Id: number | null
    RoleId: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    Id: number | null
    RoleId: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    RoleId: number | null
    UsuariosLeier: string | null
    Contrase_a: string | null
    CreadoFecha: Date | null
  }

  export type UsuariosMaxAggregateOutputType = {
    Id: number | null
    Nombre: string | null
    RoleId: number | null
    UsuariosLeier: string | null
    Contrase_a: string | null
    CreadoFecha: Date | null
  }

  export type UsuariosCountAggregateOutputType = {
    Id: number
    Nombre: number
    RoleId: number
    UsuariosLeier: number
    Contrase_a: number
    CreadoFecha: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    Id?: true
    RoleId?: true
  }

  export type UsuariosSumAggregateInputType = {
    Id?: true
    RoleId?: true
  }

  export type UsuariosMinAggregateInputType = {
    Id?: true
    Nombre?: true
    RoleId?: true
    UsuariosLeier?: true
    Contrase_a?: true
    CreadoFecha?: true
  }

  export type UsuariosMaxAggregateInputType = {
    Id?: true
    Nombre?: true
    RoleId?: true
    UsuariosLeier?: true
    Contrase_a?: true
    CreadoFecha?: true
  }

  export type UsuariosCountAggregateInputType = {
    Id?: true
    Nombre?: true
    RoleId?: true
    UsuariosLeier?: true
    Contrase_a?: true
    CreadoFecha?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to aggregate.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type UsuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithAggregationInput | UsuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: UsuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    Id: number
    Nombre: string
    RoleId: number | null
    UsuariosLeier: string | null
    Contrase_a: string | null
    CreadoFecha: Date
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends UsuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type UsuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Nombre?: boolean
    RoleId?: boolean
    UsuariosLeier?: boolean
    Contrase_a?: boolean
    CreadoFecha?: boolean
    Almacenes_Almacenes_UsuarioIdToUsuarios?: boolean | Usuarios$Almacenes_Almacenes_UsuarioIdToUsuariosArgs<ExtArgs>
    Almacenes_Almacenes_ModificadoPorToUsuarios?: boolean | Usuarios$Almacenes_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs>
    Inventario?: boolean | Usuarios$InventarioArgs<ExtArgs>
    RolesUSuario?: boolean | Usuarios$RolesUSuarioArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>



  export type UsuariosSelectScalar = {
    Id?: boolean
    Nombre?: boolean
    RoleId?: boolean
    UsuariosLeier?: boolean
    Contrase_a?: boolean
    CreadoFecha?: boolean
  }

  export type UsuariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Nombre" | "RoleId" | "UsuariosLeier" | "Contrase_a" | "CreadoFecha", ExtArgs["result"]["usuarios"]>
  export type UsuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Almacenes_Almacenes_UsuarioIdToUsuarios?: boolean | Usuarios$Almacenes_Almacenes_UsuarioIdToUsuariosArgs<ExtArgs>
    Almacenes_Almacenes_ModificadoPorToUsuarios?: boolean | Usuarios$Almacenes_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs>
    Inventario?: boolean | Usuarios$InventarioArgs<ExtArgs>
    RolesUSuario?: boolean | Usuarios$RolesUSuarioArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuarios"
    objects: {
      Almacenes_Almacenes_UsuarioIdToUsuarios: Prisma.$AlmacenesPayload<ExtArgs>[]
      Almacenes_Almacenes_ModificadoPorToUsuarios: Prisma.$AlmacenesPayload<ExtArgs>[]
      Inventario: Prisma.$InventarioPayload<ExtArgs>[]
      RolesUSuario: Prisma.$RolesUSuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Nombre: string
      RoleId: number | null
      UsuariosLeier: string | null
      Contrase_a: string | null
      CreadoFecha: Date
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }

  type UsuariosGetPayload<S extends boolean | null | undefined | UsuariosDefaultArgs> = $Result.GetResult<Prisma.$UsuariosPayload, S>

  type UsuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface UsuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuarios'], meta: { name: 'Usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {UsuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuariosFindUniqueArgs>(args: SelectSubset<T, UsuariosFindUniqueArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuariosFindFirstArgs>(args?: SelectSubset<T, UsuariosFindFirstArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends UsuariosFindManyArgs>(args?: SelectSubset<T, UsuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuarios.
     * @param {UsuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
     */
    create<T extends UsuariosCreateArgs>(args: SelectSubset<T, UsuariosCreateArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuariosCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuariosCreateManyArgs>(args?: SelectSubset<T, UsuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios.
     * @param {UsuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
     */
    delete<T extends UsuariosDeleteArgs>(args: SelectSubset<T, UsuariosDeleteArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuarios.
     * @param {UsuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuariosUpdateArgs>(args: SelectSubset<T, UsuariosUpdateArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuariosDeleteManyArgs>(args?: SelectSubset<T, UsuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuariosUpdateManyArgs>(args: SelectSubset<T, UsuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {UsuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
     */
    upsert<T extends UsuariosUpsertArgs>(args: SelectSubset<T, UsuariosUpsertArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuariosCountArgs>(
      args?: Subset<T, UsuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuarios model
   */
  readonly fields: UsuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Almacenes_Almacenes_UsuarioIdToUsuarios<T extends Usuarios$Almacenes_Almacenes_UsuarioIdToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$Almacenes_Almacenes_UsuarioIdToUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Almacenes_Almacenes_ModificadoPorToUsuarios<T extends Usuarios$Almacenes_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$Almacenes_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlmacenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inventario<T extends Usuarios$InventarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$InventarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RolesUSuario<T extends Usuarios$RolesUSuarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$RolesUSuarioArgs<ExtArgs>>): Prisma__RolesUSuarioClient<$Result.GetResult<Prisma.$RolesUSuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuarios model
   */
  interface UsuariosFieldRefs {
    readonly Id: FieldRef<"Usuarios", 'Int'>
    readonly Nombre: FieldRef<"Usuarios", 'String'>
    readonly RoleId: FieldRef<"Usuarios", 'Int'>
    readonly UsuariosLeier: FieldRef<"Usuarios", 'String'>
    readonly Contrase_a: FieldRef<"Usuarios", 'String'>
    readonly CreadoFecha: FieldRef<"Usuarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuarios findUnique
   */
  export type UsuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios findUniqueOrThrow
   */
  export type UsuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios findFirst
   */
  export type UsuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios findFirstOrThrow
   */
  export type UsuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios findMany
   */
  export type UsuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios create
   */
  export type UsuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuarios.
     */
    data: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
  }

  /**
   * Usuarios createMany
   */
  export type UsuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuarios update
   */
  export type UsuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuarios.
     */
    data: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
    /**
     * Choose, which Usuarios to update.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios updateMany
   */
  export type UsuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuarios upsert
   */
  export type UsuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuarios to update in case it exists.
     */
    where: UsuariosWhereUniqueInput
    /**
     * In case the Usuarios found by the `where` argument doesn't exist, create a new Usuarios with this data.
     */
    create: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
    /**
     * In case the Usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
  }

  /**
   * Usuarios delete
   */
  export type UsuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter which Usuarios to delete.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios deleteMany
   */
  export type UsuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuarios.Almacenes_Almacenes_UsuarioIdToUsuarios
   */
  export type Usuarios$Almacenes_Almacenes_UsuarioIdToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    where?: AlmacenesWhereInput
    orderBy?: AlmacenesOrderByWithRelationInput | AlmacenesOrderByWithRelationInput[]
    cursor?: AlmacenesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlmacenesScalarFieldEnum | AlmacenesScalarFieldEnum[]
  }

  /**
   * Usuarios.Almacenes_Almacenes_ModificadoPorToUsuarios
   */
  export type Usuarios$Almacenes_Almacenes_ModificadoPorToUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Almacenes
     */
    select?: AlmacenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Almacenes
     */
    omit?: AlmacenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlmacenesInclude<ExtArgs> | null
    where?: AlmacenesWhereInput
    orderBy?: AlmacenesOrderByWithRelationInput | AlmacenesOrderByWithRelationInput[]
    cursor?: AlmacenesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlmacenesScalarFieldEnum | AlmacenesScalarFieldEnum[]
  }

  /**
   * Usuarios.Inventario
   */
  export type Usuarios$InventarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventario
     */
    select?: InventarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventario
     */
    omit?: InventarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventarioInclude<ExtArgs> | null
    where?: InventarioWhereInput
    orderBy?: InventarioOrderByWithRelationInput | InventarioOrderByWithRelationInput[]
    cursor?: InventarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventarioScalarFieldEnum | InventarioScalarFieldEnum[]
  }

  /**
   * Usuarios.RolesUSuario
   */
  export type Usuarios$RolesUSuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesUSuario
     */
    select?: RolesUSuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesUSuario
     */
    omit?: RolesUSuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesUSuarioInclude<ExtArgs> | null
    where?: RolesUSuarioWhereInput
  }

  /**
   * Usuarios without action
   */
  export type UsuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
  }


  /**
   * Model Ventas
   */

  export type AggregateVentas = {
    _count: VentasCountAggregateOutputType | null
    _avg: VentasAvgAggregateOutputType | null
    _sum: VentasSumAggregateOutputType | null
    _min: VentasMinAggregateOutputType | null
    _max: VentasMaxAggregateOutputType | null
  }

  export type VentasAvgAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
    Cantidad: number | null
    ClienteId: number | null
    MetodoPagoId: number | null
  }

  export type VentasSumAggregateOutputType = {
    Id: number | null
    ProductoId: number | null
    Cantidad: number | null
    ClienteId: number | null
    MetodoPagoId: number | null
  }

  export type VentasMinAggregateOutputType = {
    Id: number | null
    Folio: string | null
    ProductoId: number | null
    Cantidad: number | null
    ClienteId: number | null
    MetodoPagoId: number | null
    Pagado: boolean | null
    FechaPago: Date | null
    Observaciones: string | null
    CreadoFecha: Date | null
  }

  export type VentasMaxAggregateOutputType = {
    Id: number | null
    Folio: string | null
    ProductoId: number | null
    Cantidad: number | null
    ClienteId: number | null
    MetodoPagoId: number | null
    Pagado: boolean | null
    FechaPago: Date | null
    Observaciones: string | null
    CreadoFecha: Date | null
  }

  export type VentasCountAggregateOutputType = {
    Id: number
    Folio: number
    ProductoId: number
    Cantidad: number
    ClienteId: number
    MetodoPagoId: number
    Pagado: number
    FechaPago: number
    Observaciones: number
    CreadoFecha: number
    _all: number
  }


  export type VentasAvgAggregateInputType = {
    Id?: true
    ProductoId?: true
    Cantidad?: true
    ClienteId?: true
    MetodoPagoId?: true
  }

  export type VentasSumAggregateInputType = {
    Id?: true
    ProductoId?: true
    Cantidad?: true
    ClienteId?: true
    MetodoPagoId?: true
  }

  export type VentasMinAggregateInputType = {
    Id?: true
    Folio?: true
    ProductoId?: true
    Cantidad?: true
    ClienteId?: true
    MetodoPagoId?: true
    Pagado?: true
    FechaPago?: true
    Observaciones?: true
    CreadoFecha?: true
  }

  export type VentasMaxAggregateInputType = {
    Id?: true
    Folio?: true
    ProductoId?: true
    Cantidad?: true
    ClienteId?: true
    MetodoPagoId?: true
    Pagado?: true
    FechaPago?: true
    Observaciones?: true
    CreadoFecha?: true
  }

  export type VentasCountAggregateInputType = {
    Id?: true
    Folio?: true
    ProductoId?: true
    Cantidad?: true
    ClienteId?: true
    MetodoPagoId?: true
    Pagado?: true
    FechaPago?: true
    Observaciones?: true
    CreadoFecha?: true
    _all?: true
  }

  export type VentasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ventas to aggregate.
     */
    where?: VentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentasOrderByWithRelationInput | VentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ventas
    **/
    _count?: true | VentasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VentasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VentasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentasMaxAggregateInputType
  }

  export type GetVentasAggregateType<T extends VentasAggregateArgs> = {
        [P in keyof T & keyof AggregateVentas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVentas[P]>
      : GetScalarType<T[P], AggregateVentas[P]>
  }




  export type VentasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentasWhereInput
    orderBy?: VentasOrderByWithAggregationInput | VentasOrderByWithAggregationInput[]
    by: VentasScalarFieldEnum[] | VentasScalarFieldEnum
    having?: VentasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentasCountAggregateInputType | true
    _avg?: VentasAvgAggregateInputType
    _sum?: VentasSumAggregateInputType
    _min?: VentasMinAggregateInputType
    _max?: VentasMaxAggregateInputType
  }

  export type VentasGroupByOutputType = {
    Id: number
    Folio: string
    ProductoId: number
    Cantidad: number
    ClienteId: number | null
    MetodoPagoId: number
    Pagado: boolean
    FechaPago: Date | null
    Observaciones: string | null
    CreadoFecha: Date
    _count: VentasCountAggregateOutputType | null
    _avg: VentasAvgAggregateOutputType | null
    _sum: VentasSumAggregateOutputType | null
    _min: VentasMinAggregateOutputType | null
    _max: VentasMaxAggregateOutputType | null
  }

  type GetVentasGroupByPayload<T extends VentasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentasGroupByOutputType[P]>
            : GetScalarType<T[P], VentasGroupByOutputType[P]>
        }
      >
    >


  export type VentasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Folio?: boolean
    ProductoId?: boolean
    Cantidad?: boolean
    ClienteId?: boolean
    MetodoPagoId?: boolean
    Pagado?: boolean
    FechaPago?: boolean
    Observaciones?: boolean
    CreadoFecha?: boolean
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
    Clientes?: boolean | Ventas$ClientesArgs<ExtArgs>
    MetodosPago?: boolean | MetodosPagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventas"]>



  export type VentasSelectScalar = {
    Id?: boolean
    Folio?: boolean
    ProductoId?: boolean
    Cantidad?: boolean
    ClienteId?: boolean
    MetodoPagoId?: boolean
    Pagado?: boolean
    FechaPago?: boolean
    Observaciones?: boolean
    CreadoFecha?: boolean
  }

  export type VentasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Folio" | "ProductoId" | "Cantidad" | "ClienteId" | "MetodoPagoId" | "Pagado" | "FechaPago" | "Observaciones" | "CreadoFecha", ExtArgs["result"]["ventas"]>
  export type VentasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Productos?: boolean | ProductosDefaultArgs<ExtArgs>
    Clientes?: boolean | Ventas$ClientesArgs<ExtArgs>
    MetodosPago?: boolean | MetodosPagoDefaultArgs<ExtArgs>
  }

  export type $VentasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ventas"
    objects: {
      Productos: Prisma.$ProductosPayload<ExtArgs>
      Clientes: Prisma.$ClientesPayload<ExtArgs> | null
      MetodosPago: Prisma.$MetodosPagoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Folio: string
      ProductoId: number
      Cantidad: number
      ClienteId: number | null
      MetodoPagoId: number
      Pagado: boolean
      FechaPago: Date | null
      Observaciones: string | null
      CreadoFecha: Date
    }, ExtArgs["result"]["ventas"]>
    composites: {}
  }

  type VentasGetPayload<S extends boolean | null | undefined | VentasDefaultArgs> = $Result.GetResult<Prisma.$VentasPayload, S>

  type VentasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VentasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VentasCountAggregateInputType | true
    }

  export interface VentasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ventas'], meta: { name: 'Ventas' } }
    /**
     * Find zero or one Ventas that matches the filter.
     * @param {VentasFindUniqueArgs} args - Arguments to find a Ventas
     * @example
     * // Get one Ventas
     * const ventas = await prisma.ventas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentasFindUniqueArgs>(args: SelectSubset<T, VentasFindUniqueArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ventas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VentasFindUniqueOrThrowArgs} args - Arguments to find a Ventas
     * @example
     * // Get one Ventas
     * const ventas = await prisma.ventas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentasFindUniqueOrThrowArgs>(args: SelectSubset<T, VentasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentasFindFirstArgs} args - Arguments to find a Ventas
     * @example
     * // Get one Ventas
     * const ventas = await prisma.ventas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentasFindFirstArgs>(args?: SelectSubset<T, VentasFindFirstArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ventas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentasFindFirstOrThrowArgs} args - Arguments to find a Ventas
     * @example
     * // Get one Ventas
     * const ventas = await prisma.ventas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentasFindFirstOrThrowArgs>(args?: SelectSubset<T, VentasFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ventas
     * const ventas = await prisma.ventas.findMany()
     * 
     * // Get first 10 Ventas
     * const ventas = await prisma.ventas.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const ventasWithIdOnly = await prisma.ventas.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends VentasFindManyArgs>(args?: SelectSubset<T, VentasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ventas.
     * @param {VentasCreateArgs} args - Arguments to create a Ventas.
     * @example
     * // Create one Ventas
     * const Ventas = await prisma.ventas.create({
     *   data: {
     *     // ... data to create a Ventas
     *   }
     * })
     * 
     */
    create<T extends VentasCreateArgs>(args: SelectSubset<T, VentasCreateArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ventas.
     * @param {VentasCreateManyArgs} args - Arguments to create many Ventas.
     * @example
     * // Create many Ventas
     * const ventas = await prisma.ventas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentasCreateManyArgs>(args?: SelectSubset<T, VentasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ventas.
     * @param {VentasDeleteArgs} args - Arguments to delete one Ventas.
     * @example
     * // Delete one Ventas
     * const Ventas = await prisma.ventas.delete({
     *   where: {
     *     // ... filter to delete one Ventas
     *   }
     * })
     * 
     */
    delete<T extends VentasDeleteArgs>(args: SelectSubset<T, VentasDeleteArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ventas.
     * @param {VentasUpdateArgs} args - Arguments to update one Ventas.
     * @example
     * // Update one Ventas
     * const ventas = await prisma.ventas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentasUpdateArgs>(args: SelectSubset<T, VentasUpdateArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ventas.
     * @param {VentasDeleteManyArgs} args - Arguments to filter Ventas to delete.
     * @example
     * // Delete a few Ventas
     * const { count } = await prisma.ventas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentasDeleteManyArgs>(args?: SelectSubset<T, VentasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ventas
     * const ventas = await prisma.ventas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentasUpdateManyArgs>(args: SelectSubset<T, VentasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ventas.
     * @param {VentasUpsertArgs} args - Arguments to update or create a Ventas.
     * @example
     * // Update or create a Ventas
     * const ventas = await prisma.ventas.upsert({
     *   create: {
     *     // ... data to create a Ventas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ventas we want to update
     *   }
     * })
     */
    upsert<T extends VentasUpsertArgs>(args: SelectSubset<T, VentasUpsertArgs<ExtArgs>>): Prisma__VentasClient<$Result.GetResult<Prisma.$VentasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentasCountArgs} args - Arguments to filter Ventas to count.
     * @example
     * // Count the number of Ventas
     * const count = await prisma.ventas.count({
     *   where: {
     *     // ... the filter for the Ventas we want to count
     *   }
     * })
    **/
    count<T extends VentasCountArgs>(
      args?: Subset<T, VentasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentasAggregateArgs>(args: Subset<T, VentasAggregateArgs>): Prisma.PrismaPromise<GetVentasAggregateType<T>>

    /**
     * Group by Ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentasGroupByArgs['orderBy'] }
        : { orderBy?: VentasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ventas model
   */
  readonly fields: VentasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ventas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Productos<T extends ProductosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductosDefaultArgs<ExtArgs>>): Prisma__ProductosClient<$Result.GetResult<Prisma.$ProductosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Clientes<T extends Ventas$ClientesArgs<ExtArgs> = {}>(args?: Subset<T, Ventas$ClientesArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    MetodosPago<T extends MetodosPagoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MetodosPagoDefaultArgs<ExtArgs>>): Prisma__MetodosPagoClient<$Result.GetResult<Prisma.$MetodosPagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ventas model
   */
  interface VentasFieldRefs {
    readonly Id: FieldRef<"Ventas", 'Int'>
    readonly Folio: FieldRef<"Ventas", 'String'>
    readonly ProductoId: FieldRef<"Ventas", 'Int'>
    readonly Cantidad: FieldRef<"Ventas", 'Int'>
    readonly ClienteId: FieldRef<"Ventas", 'Int'>
    readonly MetodoPagoId: FieldRef<"Ventas", 'Int'>
    readonly Pagado: FieldRef<"Ventas", 'Boolean'>
    readonly FechaPago: FieldRef<"Ventas", 'DateTime'>
    readonly Observaciones: FieldRef<"Ventas", 'String'>
    readonly CreadoFecha: FieldRef<"Ventas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ventas findUnique
   */
  export type VentasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * Filter, which Ventas to fetch.
     */
    where: VentasWhereUniqueInput
  }

  /**
   * Ventas findUniqueOrThrow
   */
  export type VentasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * Filter, which Ventas to fetch.
     */
    where: VentasWhereUniqueInput
  }

  /**
   * Ventas findFirst
   */
  export type VentasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * Filter, which Ventas to fetch.
     */
    where?: VentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentasOrderByWithRelationInput | VentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventas.
     */
    cursor?: VentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventas.
     */
    distinct?: VentasScalarFieldEnum | VentasScalarFieldEnum[]
  }

  /**
   * Ventas findFirstOrThrow
   */
  export type VentasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * Filter, which Ventas to fetch.
     */
    where?: VentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentasOrderByWithRelationInput | VentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventas.
     */
    cursor?: VentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventas.
     */
    distinct?: VentasScalarFieldEnum | VentasScalarFieldEnum[]
  }

  /**
   * Ventas findMany
   */
  export type VentasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * Filter, which Ventas to fetch.
     */
    where?: VentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventas to fetch.
     */
    orderBy?: VentasOrderByWithRelationInput | VentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ventas.
     */
    cursor?: VentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventas.
     */
    skip?: number
    distinct?: VentasScalarFieldEnum | VentasScalarFieldEnum[]
  }

  /**
   * Ventas create
   */
  export type VentasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * The data needed to create a Ventas.
     */
    data: XOR<VentasCreateInput, VentasUncheckedCreateInput>
  }

  /**
   * Ventas createMany
   */
  export type VentasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ventas.
     */
    data: VentasCreateManyInput | VentasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ventas update
   */
  export type VentasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * The data needed to update a Ventas.
     */
    data: XOR<VentasUpdateInput, VentasUncheckedUpdateInput>
    /**
     * Choose, which Ventas to update.
     */
    where: VentasWhereUniqueInput
  }

  /**
   * Ventas updateMany
   */
  export type VentasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ventas.
     */
    data: XOR<VentasUpdateManyMutationInput, VentasUncheckedUpdateManyInput>
    /**
     * Filter which Ventas to update
     */
    where?: VentasWhereInput
    /**
     * Limit how many Ventas to update.
     */
    limit?: number
  }

  /**
   * Ventas upsert
   */
  export type VentasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * The filter to search for the Ventas to update in case it exists.
     */
    where: VentasWhereUniqueInput
    /**
     * In case the Ventas found by the `where` argument doesn't exist, create a new Ventas with this data.
     */
    create: XOR<VentasCreateInput, VentasUncheckedCreateInput>
    /**
     * In case the Ventas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentasUpdateInput, VentasUncheckedUpdateInput>
  }

  /**
   * Ventas delete
   */
  export type VentasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
    /**
     * Filter which Ventas to delete.
     */
    where: VentasWhereUniqueInput
  }

  /**
   * Ventas deleteMany
   */
  export type VentasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ventas to delete
     */
    where?: VentasWhereInput
    /**
     * Limit how many Ventas to delete.
     */
    limit?: number
  }

  /**
   * Ventas.Clientes
   */
  export type Ventas$ClientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clientes
     */
    omit?: ClientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientesInclude<ExtArgs> | null
    where?: ClientesWhereInput
  }

  /**
   * Ventas without action
   */
  export type VentasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ventas
     */
    select?: VentasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ventas
     */
    omit?: VentasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentasInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AlmacenesScalarFieldEnum: {
    Id: 'Id',
    Code: 'Code',
    Nombre: 'Nombre',
    Existencia_bolsas: 'Existencia_bolsas',
    Existencia_kg: 'Existencia_kg',
    CreadoFecha: 'CreadoFecha',
    UsuarioId: 'UsuarioId',
    FechaModificacion: 'FechaModificacion',
    ModificadoPor: 'ModificadoPor'
  };

  export type AlmacenesScalarFieldEnum = (typeof AlmacenesScalarFieldEnum)[keyof typeof AlmacenesScalarFieldEnum]


  export const CategoriasProductoScalarFieldEnum: {
    Id: 'Id',
    Code: 'Code',
    Nombre: 'Nombre'
  };

  export type CategoriasProductoScalarFieldEnum = (typeof CategoriasProductoScalarFieldEnum)[keyof typeof CategoriasProductoScalarFieldEnum]


  export const ClientesScalarFieldEnum: {
    Id: 'Id',
    Nombre: 'Nombre',
    Telefono: 'Telefono'
  };

  export type ClientesScalarFieldEnum = (typeof ClientesScalarFieldEnum)[keyof typeof ClientesScalarFieldEnum]


  export const ComprasScalarFieldEnum: {
    Id: 'Id',
    Folio: 'Folio',
    TipoCompraId: 'TipoCompraId',
    ProveedorId: 'ProveedorId',
    ProductoId: 'ProductoId',
    InsumoId: 'InsumoId',
    Cantidad: 'Cantidad',
    CantidadRecibida: 'CantidadRecibida',
    CostoUnitario: 'CostoUnitario',
    PrecioUnitario: 'PrecioUnitario',
    FechaRecepcion: 'FechaRecepcion',
    CreadoFecha: 'CreadoFecha'
  };

  export type ComprasScalarFieldEnum = (typeof ComprasScalarFieldEnum)[keyof typeof ComprasScalarFieldEnum]


  export const ImagenesProductosScalarFieldEnum: {
    Id: 'Id',
    URLImagen: 'URLImagen',
    ProductoId: 'ProductoId'
  };

  export type ImagenesProductosScalarFieldEnum = (typeof ImagenesProductosScalarFieldEnum)[keyof typeof ImagenesProductosScalarFieldEnum]


  export const InsumosScalarFieldEnum: {
    Id: 'Id',
    Nombre: 'Nombre',
    Descripcion: 'Descripcion',
    Cantidad: 'Cantidad',
    CantidadRecibida: 'CantidadRecibida',
    CostoUnitario: 'CostoUnitario'
  };

  export type InsumosScalarFieldEnum = (typeof InsumosScalarFieldEnum)[keyof typeof InsumosScalarFieldEnum]


  export const InventarioScalarFieldEnum: {
    Id: 'Id',
    CompraId: 'CompraId',
    ProductoId: 'ProductoId',
    CantidadRecibida: 'CantidadRecibida',
    AlmacenActualId: 'AlmacenActualId',
    FechaSurtido: 'FechaSurtido',
    SurtidoPorAlmacenId: 'SurtidoPorAlmacenId',
    RecibidoPorAlmacenId: 'RecibidoPorAlmacenId',
    CreadoFecha: 'CreadoFecha',
    CreadoPor: 'CreadoPor'
  };

  export type InventarioScalarFieldEnum = (typeof InventarioScalarFieldEnum)[keyof typeof InventarioScalarFieldEnum]


  export const ListasPreciosScalarFieldEnum: {
    Id: 'Id',
    ProductoId: 'ProductoId',
    UnidadMedidaId: 'UnidadMedidaId',
    CostoUnitario: 'CostoUnitario',
    Utilidad: 'Utilidad',
    PrecioUnitario: 'PrecioUnitario',
    CreadoFecha: 'CreadoFecha',
    Vigente: 'Vigente'
  };

  export type ListasPreciosScalarFieldEnum = (typeof ListasPreciosScalarFieldEnum)[keyof typeof ListasPreciosScalarFieldEnum]


  export const MetodosPagoScalarFieldEnum: {
    Id: 'Id',
    code: 'code',
    Nombre: 'Nombre'
  };

  export type MetodosPagoScalarFieldEnum = (typeof MetodosPagoScalarFieldEnum)[keyof typeof MetodosPagoScalarFieldEnum]


  export const ProductosScalarFieldEnum: {
    Id: 'Id',
    Nombre: 'Nombre',
    Descripcion: 'Descripcion',
    Cantidad: 'Cantidad',
    EsPieza: 'EsPieza',
    CategoriaId: 'CategoriaId'
  };

  export type ProductosScalarFieldEnum = (typeof ProductosScalarFieldEnum)[keyof typeof ProductosScalarFieldEnum]


  export const ProveedoresScalarFieldEnum: {
    Id: 'Id',
    Nombre: 'Nombre'
  };

  export type ProveedoresScalarFieldEnum = (typeof ProveedoresScalarFieldEnum)[keyof typeof ProveedoresScalarFieldEnum]


  export const RolesUSuarioScalarFieldEnum: {
    Id: 'Id',
    Nombre: 'Nombre'
  };

  export type RolesUSuarioScalarFieldEnum = (typeof RolesUSuarioScalarFieldEnum)[keyof typeof RolesUSuarioScalarFieldEnum]


  export const TiposCompraScalarFieldEnum: {
    Id: 'Id',
    Code: 'Code',
    Nombre: 'Nombre'
  };

  export type TiposCompraScalarFieldEnum = (typeof TiposCompraScalarFieldEnum)[keyof typeof TiposCompraScalarFieldEnum]


  export const UnidadesMedidaScalarFieldEnum: {
    Id: 'Id',
    Code: 'Code',
    Nombre: 'Nombre'
  };

  export type UnidadesMedidaScalarFieldEnum = (typeof UnidadesMedidaScalarFieldEnum)[keyof typeof UnidadesMedidaScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    Id: 'Id',
    Nombre: 'Nombre',
    RoleId: 'RoleId',
    UsuariosLeier: 'UsuariosLeier',
    Contrase_a: 'Contrase_a',
    CreadoFecha: 'CreadoFecha'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const VentasScalarFieldEnum: {
    Id: 'Id',
    Folio: 'Folio',
    ProductoId: 'ProductoId',
    Cantidad: 'Cantidad',
    ClienteId: 'ClienteId',
    MetodoPagoId: 'MetodoPagoId',
    Pagado: 'Pagado',
    FechaPago: 'FechaPago',
    Observaciones: 'Observaciones',
    CreadoFecha: 'CreadoFecha'
  };

  export type VentasScalarFieldEnum = (typeof VentasScalarFieldEnum)[keyof typeof VentasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AlmacenesOrderByRelevanceFieldEnum: {
    Code: 'Code',
    Nombre: 'Nombre'
  };

  export type AlmacenesOrderByRelevanceFieldEnum = (typeof AlmacenesOrderByRelevanceFieldEnum)[keyof typeof AlmacenesOrderByRelevanceFieldEnum]


  export const CategoriasProductoOrderByRelevanceFieldEnum: {
    Code: 'Code',
    Nombre: 'Nombre'
  };

  export type CategoriasProductoOrderByRelevanceFieldEnum = (typeof CategoriasProductoOrderByRelevanceFieldEnum)[keyof typeof CategoriasProductoOrderByRelevanceFieldEnum]


  export const ClientesOrderByRelevanceFieldEnum: {
    Nombre: 'Nombre',
    Telefono: 'Telefono'
  };

  export type ClientesOrderByRelevanceFieldEnum = (typeof ClientesOrderByRelevanceFieldEnum)[keyof typeof ClientesOrderByRelevanceFieldEnum]


  export const ComprasOrderByRelevanceFieldEnum: {
    Folio: 'Folio'
  };

  export type ComprasOrderByRelevanceFieldEnum = (typeof ComprasOrderByRelevanceFieldEnum)[keyof typeof ComprasOrderByRelevanceFieldEnum]


  export const ImagenesProductosOrderByRelevanceFieldEnum: {
    URLImagen: 'URLImagen'
  };

  export type ImagenesProductosOrderByRelevanceFieldEnum = (typeof ImagenesProductosOrderByRelevanceFieldEnum)[keyof typeof ImagenesProductosOrderByRelevanceFieldEnum]


  export const InsumosOrderByRelevanceFieldEnum: {
    Nombre: 'Nombre',
    Descripcion: 'Descripcion'
  };

  export type InsumosOrderByRelevanceFieldEnum = (typeof InsumosOrderByRelevanceFieldEnum)[keyof typeof InsumosOrderByRelevanceFieldEnum]


  export const MetodosPagoOrderByRelevanceFieldEnum: {
    code: 'code',
    Nombre: 'Nombre'
  };

  export type MetodosPagoOrderByRelevanceFieldEnum = (typeof MetodosPagoOrderByRelevanceFieldEnum)[keyof typeof MetodosPagoOrderByRelevanceFieldEnum]


  export const ProductosOrderByRelevanceFieldEnum: {
    Nombre: 'Nombre',
    Descripcion: 'Descripcion'
  };

  export type ProductosOrderByRelevanceFieldEnum = (typeof ProductosOrderByRelevanceFieldEnum)[keyof typeof ProductosOrderByRelevanceFieldEnum]


  export const ProveedoresOrderByRelevanceFieldEnum: {
    Nombre: 'Nombre'
  };

  export type ProveedoresOrderByRelevanceFieldEnum = (typeof ProveedoresOrderByRelevanceFieldEnum)[keyof typeof ProveedoresOrderByRelevanceFieldEnum]


  export const RolesUSuarioOrderByRelevanceFieldEnum: {
    Nombre: 'Nombre'
  };

  export type RolesUSuarioOrderByRelevanceFieldEnum = (typeof RolesUSuarioOrderByRelevanceFieldEnum)[keyof typeof RolesUSuarioOrderByRelevanceFieldEnum]


  export const TiposCompraOrderByRelevanceFieldEnum: {
    Code: 'Code',
    Nombre: 'Nombre'
  };

  export type TiposCompraOrderByRelevanceFieldEnum = (typeof TiposCompraOrderByRelevanceFieldEnum)[keyof typeof TiposCompraOrderByRelevanceFieldEnum]


  export const UnidadesMedidaOrderByRelevanceFieldEnum: {
    Code: 'Code',
    Nombre: 'Nombre'
  };

  export type UnidadesMedidaOrderByRelevanceFieldEnum = (typeof UnidadesMedidaOrderByRelevanceFieldEnum)[keyof typeof UnidadesMedidaOrderByRelevanceFieldEnum]


  export const UsuariosOrderByRelevanceFieldEnum: {
    Nombre: 'Nombre',
    UsuariosLeier: 'UsuariosLeier',
    Contrase_a: 'Contrase_a'
  };

  export type UsuariosOrderByRelevanceFieldEnum = (typeof UsuariosOrderByRelevanceFieldEnum)[keyof typeof UsuariosOrderByRelevanceFieldEnum]


  export const VentasOrderByRelevanceFieldEnum: {
    Folio: 'Folio',
    Observaciones: 'Observaciones'
  };

  export type VentasOrderByRelevanceFieldEnum = (typeof VentasOrderByRelevanceFieldEnum)[keyof typeof VentasOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AlmacenesWhereInput = {
    AND?: AlmacenesWhereInput | AlmacenesWhereInput[]
    OR?: AlmacenesWhereInput[]
    NOT?: AlmacenesWhereInput | AlmacenesWhereInput[]
    Id?: IntFilter<"Almacenes"> | number
    Code?: StringFilter<"Almacenes"> | string
    Nombre?: StringFilter<"Almacenes"> | string
    Existencia_bolsas?: IntFilter<"Almacenes"> | number
    Existencia_kg?: IntFilter<"Almacenes"> | number
    CreadoFecha?: DateTimeFilter<"Almacenes"> | Date | string
    UsuarioId?: IntFilter<"Almacenes"> | number
    FechaModificacion?: DateTimeNullableFilter<"Almacenes"> | Date | string | null
    ModificadoPor?: IntNullableFilter<"Almacenes"> | number | null
    Usuarios_Almacenes_UsuarioIdToUsuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
    Usuarios_Almacenes_ModificadoPorToUsuarios?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioListRelationFilter
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioListRelationFilter
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioListRelationFilter
  }

  export type AlmacenesOrderByWithRelationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    Existencia_bolsas?: SortOrder
    Existencia_kg?: SortOrder
    CreadoFecha?: SortOrder
    UsuarioId?: SortOrder
    FechaModificacion?: SortOrderInput | SortOrder
    ModificadoPor?: SortOrderInput | SortOrder
    Usuarios_Almacenes_UsuarioIdToUsuarios?: UsuariosOrderByWithRelationInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosOrderByWithRelationInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioOrderByRelationAggregateInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioOrderByRelationAggregateInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioOrderByRelationAggregateInput
    _relevance?: AlmacenesOrderByRelevanceInput
  }

  export type AlmacenesWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: AlmacenesWhereInput | AlmacenesWhereInput[]
    OR?: AlmacenesWhereInput[]
    NOT?: AlmacenesWhereInput | AlmacenesWhereInput[]
    Code?: StringFilter<"Almacenes"> | string
    Nombre?: StringFilter<"Almacenes"> | string
    Existencia_bolsas?: IntFilter<"Almacenes"> | number
    Existencia_kg?: IntFilter<"Almacenes"> | number
    CreadoFecha?: DateTimeFilter<"Almacenes"> | Date | string
    UsuarioId?: IntFilter<"Almacenes"> | number
    FechaModificacion?: DateTimeNullableFilter<"Almacenes"> | Date | string | null
    ModificadoPor?: IntNullableFilter<"Almacenes"> | number | null
    Usuarios_Almacenes_UsuarioIdToUsuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
    Usuarios_Almacenes_ModificadoPorToUsuarios?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioListRelationFilter
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioListRelationFilter
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioListRelationFilter
  }, "Id">

  export type AlmacenesOrderByWithAggregationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    Existencia_bolsas?: SortOrder
    Existencia_kg?: SortOrder
    CreadoFecha?: SortOrder
    UsuarioId?: SortOrder
    FechaModificacion?: SortOrderInput | SortOrder
    ModificadoPor?: SortOrderInput | SortOrder
    _count?: AlmacenesCountOrderByAggregateInput
    _avg?: AlmacenesAvgOrderByAggregateInput
    _max?: AlmacenesMaxOrderByAggregateInput
    _min?: AlmacenesMinOrderByAggregateInput
    _sum?: AlmacenesSumOrderByAggregateInput
  }

  export type AlmacenesScalarWhereWithAggregatesInput = {
    AND?: AlmacenesScalarWhereWithAggregatesInput | AlmacenesScalarWhereWithAggregatesInput[]
    OR?: AlmacenesScalarWhereWithAggregatesInput[]
    NOT?: AlmacenesScalarWhereWithAggregatesInput | AlmacenesScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Almacenes"> | number
    Code?: StringWithAggregatesFilter<"Almacenes"> | string
    Nombre?: StringWithAggregatesFilter<"Almacenes"> | string
    Existencia_bolsas?: IntWithAggregatesFilter<"Almacenes"> | number
    Existencia_kg?: IntWithAggregatesFilter<"Almacenes"> | number
    CreadoFecha?: DateTimeWithAggregatesFilter<"Almacenes"> | Date | string
    UsuarioId?: IntWithAggregatesFilter<"Almacenes"> | number
    FechaModificacion?: DateTimeNullableWithAggregatesFilter<"Almacenes"> | Date | string | null
    ModificadoPor?: IntNullableWithAggregatesFilter<"Almacenes"> | number | null
  }

  export type CategoriasProductoWhereInput = {
    AND?: CategoriasProductoWhereInput | CategoriasProductoWhereInput[]
    OR?: CategoriasProductoWhereInput[]
    NOT?: CategoriasProductoWhereInput | CategoriasProductoWhereInput[]
    Id?: IntFilter<"CategoriasProducto"> | number
    Code?: StringFilter<"CategoriasProducto"> | string
    Nombre?: StringFilter<"CategoriasProducto"> | string
    Productos?: ProductosListRelationFilter
  }

  export type CategoriasProductoOrderByWithRelationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    Productos?: ProductosOrderByRelationAggregateInput
    _relevance?: CategoriasProductoOrderByRelevanceInput
  }

  export type CategoriasProductoWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: CategoriasProductoWhereInput | CategoriasProductoWhereInput[]
    OR?: CategoriasProductoWhereInput[]
    NOT?: CategoriasProductoWhereInput | CategoriasProductoWhereInput[]
    Code?: StringFilter<"CategoriasProducto"> | string
    Nombre?: StringFilter<"CategoriasProducto"> | string
    Productos?: ProductosListRelationFilter
  }, "Id">

  export type CategoriasProductoOrderByWithAggregationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    _count?: CategoriasProductoCountOrderByAggregateInput
    _avg?: CategoriasProductoAvgOrderByAggregateInput
    _max?: CategoriasProductoMaxOrderByAggregateInput
    _min?: CategoriasProductoMinOrderByAggregateInput
    _sum?: CategoriasProductoSumOrderByAggregateInput
  }

  export type CategoriasProductoScalarWhereWithAggregatesInput = {
    AND?: CategoriasProductoScalarWhereWithAggregatesInput | CategoriasProductoScalarWhereWithAggregatesInput[]
    OR?: CategoriasProductoScalarWhereWithAggregatesInput[]
    NOT?: CategoriasProductoScalarWhereWithAggregatesInput | CategoriasProductoScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"CategoriasProducto"> | number
    Code?: StringWithAggregatesFilter<"CategoriasProducto"> | string
    Nombre?: StringWithAggregatesFilter<"CategoriasProducto"> | string
  }

  export type ClientesWhereInput = {
    AND?: ClientesWhereInput | ClientesWhereInput[]
    OR?: ClientesWhereInput[]
    NOT?: ClientesWhereInput | ClientesWhereInput[]
    Id?: IntFilter<"Clientes"> | number
    Nombre?: StringFilter<"Clientes"> | string
    Telefono?: StringNullableFilter<"Clientes"> | string | null
    Ventas?: VentasListRelationFilter
  }

  export type ClientesOrderByWithRelationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Telefono?: SortOrderInput | SortOrder
    Ventas?: VentasOrderByRelationAggregateInput
    _relevance?: ClientesOrderByRelevanceInput
  }

  export type ClientesWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: ClientesWhereInput | ClientesWhereInput[]
    OR?: ClientesWhereInput[]
    NOT?: ClientesWhereInput | ClientesWhereInput[]
    Nombre?: StringFilter<"Clientes"> | string
    Telefono?: StringNullableFilter<"Clientes"> | string | null
    Ventas?: VentasListRelationFilter
  }, "Id">

  export type ClientesOrderByWithAggregationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Telefono?: SortOrderInput | SortOrder
    _count?: ClientesCountOrderByAggregateInput
    _avg?: ClientesAvgOrderByAggregateInput
    _max?: ClientesMaxOrderByAggregateInput
    _min?: ClientesMinOrderByAggregateInput
    _sum?: ClientesSumOrderByAggregateInput
  }

  export type ClientesScalarWhereWithAggregatesInput = {
    AND?: ClientesScalarWhereWithAggregatesInput | ClientesScalarWhereWithAggregatesInput[]
    OR?: ClientesScalarWhereWithAggregatesInput[]
    NOT?: ClientesScalarWhereWithAggregatesInput | ClientesScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Clientes"> | number
    Nombre?: StringWithAggregatesFilter<"Clientes"> | string
    Telefono?: StringNullableWithAggregatesFilter<"Clientes"> | string | null
  }

  export type ComprasWhereInput = {
    AND?: ComprasWhereInput | ComprasWhereInput[]
    OR?: ComprasWhereInput[]
    NOT?: ComprasWhereInput | ComprasWhereInput[]
    Id?: IntFilter<"Compras"> | number
    Folio?: StringFilter<"Compras"> | string
    TipoCompraId?: IntFilter<"Compras"> | number
    ProveedorId?: IntFilter<"Compras"> | number
    ProductoId?: IntNullableFilter<"Compras"> | number | null
    InsumoId?: IntNullableFilter<"Compras"> | number | null
    Cantidad?: IntFilter<"Compras"> | number
    CantidadRecibida?: IntFilter<"Compras"> | number
    CostoUnitario?: DecimalFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFilter<"Compras"> | Date | string
    CreadoFecha?: DateTimeFilter<"Compras"> | Date | string
    TiposCompra?: XOR<TiposCompraScalarRelationFilter, TiposCompraWhereInput>
    Proveedores?: XOR<ProveedoresScalarRelationFilter, ProveedoresWhereInput>
    Productos?: XOR<ProductosNullableScalarRelationFilter, ProductosWhereInput> | null
    Insumos?: XOR<InsumosNullableScalarRelationFilter, InsumosWhereInput> | null
    Inventario?: InventarioListRelationFilter
  }

  export type ComprasOrderByWithRelationInput = {
    Id?: SortOrder
    Folio?: SortOrder
    TipoCompraId?: SortOrder
    ProveedorId?: SortOrder
    ProductoId?: SortOrderInput | SortOrder
    InsumoId?: SortOrderInput | SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
    PrecioUnitario?: SortOrder
    FechaRecepcion?: SortOrder
    CreadoFecha?: SortOrder
    TiposCompra?: TiposCompraOrderByWithRelationInput
    Proveedores?: ProveedoresOrderByWithRelationInput
    Productos?: ProductosOrderByWithRelationInput
    Insumos?: InsumosOrderByWithRelationInput
    Inventario?: InventarioOrderByRelationAggregateInput
    _relevance?: ComprasOrderByRelevanceInput
  }

  export type ComprasWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: ComprasWhereInput | ComprasWhereInput[]
    OR?: ComprasWhereInput[]
    NOT?: ComprasWhereInput | ComprasWhereInput[]
    Folio?: StringFilter<"Compras"> | string
    TipoCompraId?: IntFilter<"Compras"> | number
    ProveedorId?: IntFilter<"Compras"> | number
    ProductoId?: IntNullableFilter<"Compras"> | number | null
    InsumoId?: IntNullableFilter<"Compras"> | number | null
    Cantidad?: IntFilter<"Compras"> | number
    CantidadRecibida?: IntFilter<"Compras"> | number
    CostoUnitario?: DecimalFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFilter<"Compras"> | Date | string
    CreadoFecha?: DateTimeFilter<"Compras"> | Date | string
    TiposCompra?: XOR<TiposCompraScalarRelationFilter, TiposCompraWhereInput>
    Proveedores?: XOR<ProveedoresScalarRelationFilter, ProveedoresWhereInput>
    Productos?: XOR<ProductosNullableScalarRelationFilter, ProductosWhereInput> | null
    Insumos?: XOR<InsumosNullableScalarRelationFilter, InsumosWhereInput> | null
    Inventario?: InventarioListRelationFilter
  }, "Id">

  export type ComprasOrderByWithAggregationInput = {
    Id?: SortOrder
    Folio?: SortOrder
    TipoCompraId?: SortOrder
    ProveedorId?: SortOrder
    ProductoId?: SortOrderInput | SortOrder
    InsumoId?: SortOrderInput | SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
    PrecioUnitario?: SortOrder
    FechaRecepcion?: SortOrder
    CreadoFecha?: SortOrder
    _count?: ComprasCountOrderByAggregateInput
    _avg?: ComprasAvgOrderByAggregateInput
    _max?: ComprasMaxOrderByAggregateInput
    _min?: ComprasMinOrderByAggregateInput
    _sum?: ComprasSumOrderByAggregateInput
  }

  export type ComprasScalarWhereWithAggregatesInput = {
    AND?: ComprasScalarWhereWithAggregatesInput | ComprasScalarWhereWithAggregatesInput[]
    OR?: ComprasScalarWhereWithAggregatesInput[]
    NOT?: ComprasScalarWhereWithAggregatesInput | ComprasScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Compras"> | number
    Folio?: StringWithAggregatesFilter<"Compras"> | string
    TipoCompraId?: IntWithAggregatesFilter<"Compras"> | number
    ProveedorId?: IntWithAggregatesFilter<"Compras"> | number
    ProductoId?: IntNullableWithAggregatesFilter<"Compras"> | number | null
    InsumoId?: IntNullableWithAggregatesFilter<"Compras"> | number | null
    Cantidad?: IntWithAggregatesFilter<"Compras"> | number
    CantidadRecibida?: IntWithAggregatesFilter<"Compras"> | number
    CostoUnitario?: DecimalWithAggregatesFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalWithAggregatesFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeWithAggregatesFilter<"Compras"> | Date | string
    CreadoFecha?: DateTimeWithAggregatesFilter<"Compras"> | Date | string
  }

  export type ImagenesProductosWhereInput = {
    AND?: ImagenesProductosWhereInput | ImagenesProductosWhereInput[]
    OR?: ImagenesProductosWhereInput[]
    NOT?: ImagenesProductosWhereInput | ImagenesProductosWhereInput[]
    Id?: IntFilter<"ImagenesProductos"> | number
    URLImagen?: StringNullableFilter<"ImagenesProductos"> | string | null
    ProductoId?: IntFilter<"ImagenesProductos"> | number
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
  }

  export type ImagenesProductosOrderByWithRelationInput = {
    Id?: SortOrder
    URLImagen?: SortOrderInput | SortOrder
    ProductoId?: SortOrder
    Productos?: ProductosOrderByWithRelationInput
    _relevance?: ImagenesProductosOrderByRelevanceInput
  }

  export type ImagenesProductosWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: ImagenesProductosWhereInput | ImagenesProductosWhereInput[]
    OR?: ImagenesProductosWhereInput[]
    NOT?: ImagenesProductosWhereInput | ImagenesProductosWhereInput[]
    URLImagen?: StringNullableFilter<"ImagenesProductos"> | string | null
    ProductoId?: IntFilter<"ImagenesProductos"> | number
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
  }, "Id">

  export type ImagenesProductosOrderByWithAggregationInput = {
    Id?: SortOrder
    URLImagen?: SortOrderInput | SortOrder
    ProductoId?: SortOrder
    _count?: ImagenesProductosCountOrderByAggregateInput
    _avg?: ImagenesProductosAvgOrderByAggregateInput
    _max?: ImagenesProductosMaxOrderByAggregateInput
    _min?: ImagenesProductosMinOrderByAggregateInput
    _sum?: ImagenesProductosSumOrderByAggregateInput
  }

  export type ImagenesProductosScalarWhereWithAggregatesInput = {
    AND?: ImagenesProductosScalarWhereWithAggregatesInput | ImagenesProductosScalarWhereWithAggregatesInput[]
    OR?: ImagenesProductosScalarWhereWithAggregatesInput[]
    NOT?: ImagenesProductosScalarWhereWithAggregatesInput | ImagenesProductosScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"ImagenesProductos"> | number
    URLImagen?: StringNullableWithAggregatesFilter<"ImagenesProductos"> | string | null
    ProductoId?: IntWithAggregatesFilter<"ImagenesProductos"> | number
  }

  export type InsumosWhereInput = {
    AND?: InsumosWhereInput | InsumosWhereInput[]
    OR?: InsumosWhereInput[]
    NOT?: InsumosWhereInput | InsumosWhereInput[]
    Id?: IntFilter<"Insumos"> | number
    Nombre?: StringFilter<"Insumos"> | string
    Descripcion?: StringNullableFilter<"Insumos"> | string | null
    Cantidad?: IntFilter<"Insumos"> | number
    CantidadRecibida?: IntNullableFilter<"Insumos"> | number | null
    CostoUnitario?: DecimalFilter<"Insumos"> | Decimal | DecimalJsLike | number | string
    Compras?: ComprasListRelationFilter
  }

  export type InsumosOrderByWithRelationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrderInput | SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrderInput | SortOrder
    CostoUnitario?: SortOrder
    Compras?: ComprasOrderByRelationAggregateInput
    _relevance?: InsumosOrderByRelevanceInput
  }

  export type InsumosWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: InsumosWhereInput | InsumosWhereInput[]
    OR?: InsumosWhereInput[]
    NOT?: InsumosWhereInput | InsumosWhereInput[]
    Nombre?: StringFilter<"Insumos"> | string
    Descripcion?: StringNullableFilter<"Insumos"> | string | null
    Cantidad?: IntFilter<"Insumos"> | number
    CantidadRecibida?: IntNullableFilter<"Insumos"> | number | null
    CostoUnitario?: DecimalFilter<"Insumos"> | Decimal | DecimalJsLike | number | string
    Compras?: ComprasListRelationFilter
  }, "Id">

  export type InsumosOrderByWithAggregationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrderInput | SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrderInput | SortOrder
    CostoUnitario?: SortOrder
    _count?: InsumosCountOrderByAggregateInput
    _avg?: InsumosAvgOrderByAggregateInput
    _max?: InsumosMaxOrderByAggregateInput
    _min?: InsumosMinOrderByAggregateInput
    _sum?: InsumosSumOrderByAggregateInput
  }

  export type InsumosScalarWhereWithAggregatesInput = {
    AND?: InsumosScalarWhereWithAggregatesInput | InsumosScalarWhereWithAggregatesInput[]
    OR?: InsumosScalarWhereWithAggregatesInput[]
    NOT?: InsumosScalarWhereWithAggregatesInput | InsumosScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Insumos"> | number
    Nombre?: StringWithAggregatesFilter<"Insumos"> | string
    Descripcion?: StringNullableWithAggregatesFilter<"Insumos"> | string | null
    Cantidad?: IntWithAggregatesFilter<"Insumos"> | number
    CantidadRecibida?: IntNullableWithAggregatesFilter<"Insumos"> | number | null
    CostoUnitario?: DecimalWithAggregatesFilter<"Insumos"> | Decimal | DecimalJsLike | number | string
  }

  export type InventarioWhereInput = {
    AND?: InventarioWhereInput | InventarioWhereInput[]
    OR?: InventarioWhereInput[]
    NOT?: InventarioWhereInput | InventarioWhereInput[]
    Id?: IntFilter<"Inventario"> | number
    CompraId?: IntFilter<"Inventario"> | number
    ProductoId?: IntFilter<"Inventario"> | number
    CantidadRecibida?: IntFilter<"Inventario"> | number
    AlmacenActualId?: IntFilter<"Inventario"> | number
    FechaSurtido?: DateTimeFilter<"Inventario"> | Date | string
    SurtidoPorAlmacenId?: IntFilter<"Inventario"> | number
    RecibidoPorAlmacenId?: IntFilter<"Inventario"> | number
    CreadoFecha?: DateTimeFilter<"Inventario"> | Date | string
    CreadoPor?: IntFilter<"Inventario"> | number
    Compras?: XOR<ComprasScalarRelationFilter, ComprasWhereInput>
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: XOR<AlmacenesScalarRelationFilter, AlmacenesWhereInput>
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: XOR<AlmacenesScalarRelationFilter, AlmacenesWhereInput>
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: XOR<AlmacenesScalarRelationFilter, AlmacenesWhereInput>
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }

  export type InventarioOrderByWithRelationInput = {
    Id?: SortOrder
    CompraId?: SortOrder
    ProductoId?: SortOrder
    CantidadRecibida?: SortOrder
    AlmacenActualId?: SortOrder
    FechaSurtido?: SortOrder
    SurtidoPorAlmacenId?: SortOrder
    RecibidoPorAlmacenId?: SortOrder
    CreadoFecha?: SortOrder
    CreadoPor?: SortOrder
    Compras?: ComprasOrderByWithRelationInput
    Productos?: ProductosOrderByWithRelationInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: AlmacenesOrderByWithRelationInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: AlmacenesOrderByWithRelationInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: AlmacenesOrderByWithRelationInput
    Usuarios?: UsuariosOrderByWithRelationInput
  }

  export type InventarioWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: InventarioWhereInput | InventarioWhereInput[]
    OR?: InventarioWhereInput[]
    NOT?: InventarioWhereInput | InventarioWhereInput[]
    CompraId?: IntFilter<"Inventario"> | number
    ProductoId?: IntFilter<"Inventario"> | number
    CantidadRecibida?: IntFilter<"Inventario"> | number
    AlmacenActualId?: IntFilter<"Inventario"> | number
    FechaSurtido?: DateTimeFilter<"Inventario"> | Date | string
    SurtidoPorAlmacenId?: IntFilter<"Inventario"> | number
    RecibidoPorAlmacenId?: IntFilter<"Inventario"> | number
    CreadoFecha?: DateTimeFilter<"Inventario"> | Date | string
    CreadoPor?: IntFilter<"Inventario"> | number
    Compras?: XOR<ComprasScalarRelationFilter, ComprasWhereInput>
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: XOR<AlmacenesScalarRelationFilter, AlmacenesWhereInput>
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: XOR<AlmacenesScalarRelationFilter, AlmacenesWhereInput>
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: XOR<AlmacenesScalarRelationFilter, AlmacenesWhereInput>
    Usuarios?: XOR<UsuariosScalarRelationFilter, UsuariosWhereInput>
  }, "Id">

  export type InventarioOrderByWithAggregationInput = {
    Id?: SortOrder
    CompraId?: SortOrder
    ProductoId?: SortOrder
    CantidadRecibida?: SortOrder
    AlmacenActualId?: SortOrder
    FechaSurtido?: SortOrder
    SurtidoPorAlmacenId?: SortOrder
    RecibidoPorAlmacenId?: SortOrder
    CreadoFecha?: SortOrder
    CreadoPor?: SortOrder
    _count?: InventarioCountOrderByAggregateInput
    _avg?: InventarioAvgOrderByAggregateInput
    _max?: InventarioMaxOrderByAggregateInput
    _min?: InventarioMinOrderByAggregateInput
    _sum?: InventarioSumOrderByAggregateInput
  }

  export type InventarioScalarWhereWithAggregatesInput = {
    AND?: InventarioScalarWhereWithAggregatesInput | InventarioScalarWhereWithAggregatesInput[]
    OR?: InventarioScalarWhereWithAggregatesInput[]
    NOT?: InventarioScalarWhereWithAggregatesInput | InventarioScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Inventario"> | number
    CompraId?: IntWithAggregatesFilter<"Inventario"> | number
    ProductoId?: IntWithAggregatesFilter<"Inventario"> | number
    CantidadRecibida?: IntWithAggregatesFilter<"Inventario"> | number
    AlmacenActualId?: IntWithAggregatesFilter<"Inventario"> | number
    FechaSurtido?: DateTimeWithAggregatesFilter<"Inventario"> | Date | string
    SurtidoPorAlmacenId?: IntWithAggregatesFilter<"Inventario"> | number
    RecibidoPorAlmacenId?: IntWithAggregatesFilter<"Inventario"> | number
    CreadoFecha?: DateTimeWithAggregatesFilter<"Inventario"> | Date | string
    CreadoPor?: IntWithAggregatesFilter<"Inventario"> | number
  }

  export type ListasPreciosWhereInput = {
    AND?: ListasPreciosWhereInput | ListasPreciosWhereInput[]
    OR?: ListasPreciosWhereInput[]
    NOT?: ListasPreciosWhereInput | ListasPreciosWhereInput[]
    Id?: IntFilter<"ListasPrecios"> | number
    ProductoId?: IntFilter<"ListasPrecios"> | number
    UnidadMedidaId?: IntFilter<"ListasPrecios"> | number
    CostoUnitario?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFilter<"ListasPrecios"> | Date | string
    Vigente?: BoolFilter<"ListasPrecios"> | boolean
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
    UnidadesMedida?: XOR<UnidadesMedidaScalarRelationFilter, UnidadesMedidaWhereInput>
  }

  export type ListasPreciosOrderByWithRelationInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    UnidadMedidaId?: SortOrder
    CostoUnitario?: SortOrder
    Utilidad?: SortOrder
    PrecioUnitario?: SortOrder
    CreadoFecha?: SortOrder
    Vigente?: SortOrder
    Productos?: ProductosOrderByWithRelationInput
    UnidadesMedida?: UnidadesMedidaOrderByWithRelationInput
  }

  export type ListasPreciosWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: ListasPreciosWhereInput | ListasPreciosWhereInput[]
    OR?: ListasPreciosWhereInput[]
    NOT?: ListasPreciosWhereInput | ListasPreciosWhereInput[]
    ProductoId?: IntFilter<"ListasPrecios"> | number
    UnidadMedidaId?: IntFilter<"ListasPrecios"> | number
    CostoUnitario?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFilter<"ListasPrecios"> | Date | string
    Vigente?: BoolFilter<"ListasPrecios"> | boolean
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
    UnidadesMedida?: XOR<UnidadesMedidaScalarRelationFilter, UnidadesMedidaWhereInput>
  }, "Id">

  export type ListasPreciosOrderByWithAggregationInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    UnidadMedidaId?: SortOrder
    CostoUnitario?: SortOrder
    Utilidad?: SortOrder
    PrecioUnitario?: SortOrder
    CreadoFecha?: SortOrder
    Vigente?: SortOrder
    _count?: ListasPreciosCountOrderByAggregateInput
    _avg?: ListasPreciosAvgOrderByAggregateInput
    _max?: ListasPreciosMaxOrderByAggregateInput
    _min?: ListasPreciosMinOrderByAggregateInput
    _sum?: ListasPreciosSumOrderByAggregateInput
  }

  export type ListasPreciosScalarWhereWithAggregatesInput = {
    AND?: ListasPreciosScalarWhereWithAggregatesInput | ListasPreciosScalarWhereWithAggregatesInput[]
    OR?: ListasPreciosScalarWhereWithAggregatesInput[]
    NOT?: ListasPreciosScalarWhereWithAggregatesInput | ListasPreciosScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"ListasPrecios"> | number
    ProductoId?: IntWithAggregatesFilter<"ListasPrecios"> | number
    UnidadMedidaId?: IntWithAggregatesFilter<"ListasPrecios"> | number
    CostoUnitario?: DecimalWithAggregatesFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalWithAggregatesFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalWithAggregatesFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeWithAggregatesFilter<"ListasPrecios"> | Date | string
    Vigente?: BoolWithAggregatesFilter<"ListasPrecios"> | boolean
  }

  export type MetodosPagoWhereInput = {
    AND?: MetodosPagoWhereInput | MetodosPagoWhereInput[]
    OR?: MetodosPagoWhereInput[]
    NOT?: MetodosPagoWhereInput | MetodosPagoWhereInput[]
    Id?: IntFilter<"MetodosPago"> | number
    code?: StringFilter<"MetodosPago"> | string
    Nombre?: StringFilter<"MetodosPago"> | string
    Ventas?: VentasListRelationFilter
  }

  export type MetodosPagoOrderByWithRelationInput = {
    Id?: SortOrder
    code?: SortOrder
    Nombre?: SortOrder
    Ventas?: VentasOrderByRelationAggregateInput
    _relevance?: MetodosPagoOrderByRelevanceInput
  }

  export type MetodosPagoWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: MetodosPagoWhereInput | MetodosPagoWhereInput[]
    OR?: MetodosPagoWhereInput[]
    NOT?: MetodosPagoWhereInput | MetodosPagoWhereInput[]
    code?: StringFilter<"MetodosPago"> | string
    Nombre?: StringFilter<"MetodosPago"> | string
    Ventas?: VentasListRelationFilter
  }, "Id">

  export type MetodosPagoOrderByWithAggregationInput = {
    Id?: SortOrder
    code?: SortOrder
    Nombre?: SortOrder
    _count?: MetodosPagoCountOrderByAggregateInput
    _avg?: MetodosPagoAvgOrderByAggregateInput
    _max?: MetodosPagoMaxOrderByAggregateInput
    _min?: MetodosPagoMinOrderByAggregateInput
    _sum?: MetodosPagoSumOrderByAggregateInput
  }

  export type MetodosPagoScalarWhereWithAggregatesInput = {
    AND?: MetodosPagoScalarWhereWithAggregatesInput | MetodosPagoScalarWhereWithAggregatesInput[]
    OR?: MetodosPagoScalarWhereWithAggregatesInput[]
    NOT?: MetodosPagoScalarWhereWithAggregatesInput | MetodosPagoScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"MetodosPago"> | number
    code?: StringWithAggregatesFilter<"MetodosPago"> | string
    Nombre?: StringWithAggregatesFilter<"MetodosPago"> | string
  }

  export type ProductosWhereInput = {
    AND?: ProductosWhereInput | ProductosWhereInput[]
    OR?: ProductosWhereInput[]
    NOT?: ProductosWhereInput | ProductosWhereInput[]
    Id?: IntFilter<"Productos"> | number
    Nombre?: StringFilter<"Productos"> | string
    Descripcion?: StringNullableFilter<"Productos"> | string | null
    Cantidad?: IntFilter<"Productos"> | number
    EsPieza?: BoolFilter<"Productos"> | boolean
    CategoriaId?: IntFilter<"Productos"> | number
    Compras?: ComprasListRelationFilter
    ImagenesProductos?: ImagenesProductosListRelationFilter
    Inventario?: InventarioListRelationFilter
    ListasPrecios?: ListasPreciosListRelationFilter
    CategoriasProducto?: XOR<CategoriasProductoScalarRelationFilter, CategoriasProductoWhereInput>
    Ventas?: VentasListRelationFilter
  }

  export type ProductosOrderByWithRelationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrderInput | SortOrder
    Cantidad?: SortOrder
    EsPieza?: SortOrder
    CategoriaId?: SortOrder
    Compras?: ComprasOrderByRelationAggregateInput
    ImagenesProductos?: ImagenesProductosOrderByRelationAggregateInput
    Inventario?: InventarioOrderByRelationAggregateInput
    ListasPrecios?: ListasPreciosOrderByRelationAggregateInput
    CategoriasProducto?: CategoriasProductoOrderByWithRelationInput
    Ventas?: VentasOrderByRelationAggregateInput
    _relevance?: ProductosOrderByRelevanceInput
  }

  export type ProductosWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: ProductosWhereInput | ProductosWhereInput[]
    OR?: ProductosWhereInput[]
    NOT?: ProductosWhereInput | ProductosWhereInput[]
    Nombre?: StringFilter<"Productos"> | string
    Descripcion?: StringNullableFilter<"Productos"> | string | null
    Cantidad?: IntFilter<"Productos"> | number
    EsPieza?: BoolFilter<"Productos"> | boolean
    CategoriaId?: IntFilter<"Productos"> | number
    Compras?: ComprasListRelationFilter
    ImagenesProductos?: ImagenesProductosListRelationFilter
    Inventario?: InventarioListRelationFilter
    ListasPrecios?: ListasPreciosListRelationFilter
    CategoriasProducto?: XOR<CategoriasProductoScalarRelationFilter, CategoriasProductoWhereInput>
    Ventas?: VentasListRelationFilter
  }, "Id">

  export type ProductosOrderByWithAggregationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrderInput | SortOrder
    Cantidad?: SortOrder
    EsPieza?: SortOrder
    CategoriaId?: SortOrder
    _count?: ProductosCountOrderByAggregateInput
    _avg?: ProductosAvgOrderByAggregateInput
    _max?: ProductosMaxOrderByAggregateInput
    _min?: ProductosMinOrderByAggregateInput
    _sum?: ProductosSumOrderByAggregateInput
  }

  export type ProductosScalarWhereWithAggregatesInput = {
    AND?: ProductosScalarWhereWithAggregatesInput | ProductosScalarWhereWithAggregatesInput[]
    OR?: ProductosScalarWhereWithAggregatesInput[]
    NOT?: ProductosScalarWhereWithAggregatesInput | ProductosScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Productos"> | number
    Nombre?: StringWithAggregatesFilter<"Productos"> | string
    Descripcion?: StringNullableWithAggregatesFilter<"Productos"> | string | null
    Cantidad?: IntWithAggregatesFilter<"Productos"> | number
    EsPieza?: BoolWithAggregatesFilter<"Productos"> | boolean
    CategoriaId?: IntWithAggregatesFilter<"Productos"> | number
  }

  export type ProveedoresWhereInput = {
    AND?: ProveedoresWhereInput | ProveedoresWhereInput[]
    OR?: ProveedoresWhereInput[]
    NOT?: ProveedoresWhereInput | ProveedoresWhereInput[]
    Id?: IntFilter<"Proveedores"> | number
    Nombre?: StringFilter<"Proveedores"> | string
    Compras?: ComprasListRelationFilter
  }

  export type ProveedoresOrderByWithRelationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Compras?: ComprasOrderByRelationAggregateInput
    _relevance?: ProveedoresOrderByRelevanceInput
  }

  export type ProveedoresWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: ProveedoresWhereInput | ProveedoresWhereInput[]
    OR?: ProveedoresWhereInput[]
    NOT?: ProveedoresWhereInput | ProveedoresWhereInput[]
    Nombre?: StringFilter<"Proveedores"> | string
    Compras?: ComprasListRelationFilter
  }, "Id">

  export type ProveedoresOrderByWithAggregationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    _count?: ProveedoresCountOrderByAggregateInput
    _avg?: ProveedoresAvgOrderByAggregateInput
    _max?: ProveedoresMaxOrderByAggregateInput
    _min?: ProveedoresMinOrderByAggregateInput
    _sum?: ProveedoresSumOrderByAggregateInput
  }

  export type ProveedoresScalarWhereWithAggregatesInput = {
    AND?: ProveedoresScalarWhereWithAggregatesInput | ProveedoresScalarWhereWithAggregatesInput[]
    OR?: ProveedoresScalarWhereWithAggregatesInput[]
    NOT?: ProveedoresScalarWhereWithAggregatesInput | ProveedoresScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Proveedores"> | number
    Nombre?: StringWithAggregatesFilter<"Proveedores"> | string
  }

  export type RolesUSuarioWhereInput = {
    AND?: RolesUSuarioWhereInput | RolesUSuarioWhereInput[]
    OR?: RolesUSuarioWhereInput[]
    NOT?: RolesUSuarioWhereInput | RolesUSuarioWhereInput[]
    Id?: IntFilter<"RolesUSuario"> | number
    Nombre?: StringFilter<"RolesUSuario"> | string
    Usuarios?: UsuariosListRelationFilter
  }

  export type RolesUSuarioOrderByWithRelationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Usuarios?: UsuariosOrderByRelationAggregateInput
    _relevance?: RolesUSuarioOrderByRelevanceInput
  }

  export type RolesUSuarioWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: RolesUSuarioWhereInput | RolesUSuarioWhereInput[]
    OR?: RolesUSuarioWhereInput[]
    NOT?: RolesUSuarioWhereInput | RolesUSuarioWhereInput[]
    Nombre?: StringFilter<"RolesUSuario"> | string
    Usuarios?: UsuariosListRelationFilter
  }, "Id">

  export type RolesUSuarioOrderByWithAggregationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    _count?: RolesUSuarioCountOrderByAggregateInput
    _avg?: RolesUSuarioAvgOrderByAggregateInput
    _max?: RolesUSuarioMaxOrderByAggregateInput
    _min?: RolesUSuarioMinOrderByAggregateInput
    _sum?: RolesUSuarioSumOrderByAggregateInput
  }

  export type RolesUSuarioScalarWhereWithAggregatesInput = {
    AND?: RolesUSuarioScalarWhereWithAggregatesInput | RolesUSuarioScalarWhereWithAggregatesInput[]
    OR?: RolesUSuarioScalarWhereWithAggregatesInput[]
    NOT?: RolesUSuarioScalarWhereWithAggregatesInput | RolesUSuarioScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"RolesUSuario"> | number
    Nombre?: StringWithAggregatesFilter<"RolesUSuario"> | string
  }

  export type TiposCompraWhereInput = {
    AND?: TiposCompraWhereInput | TiposCompraWhereInput[]
    OR?: TiposCompraWhereInput[]
    NOT?: TiposCompraWhereInput | TiposCompraWhereInput[]
    Id?: IntFilter<"TiposCompra"> | number
    Code?: StringFilter<"TiposCompra"> | string
    Nombre?: StringFilter<"TiposCompra"> | string
    Compras?: ComprasListRelationFilter
  }

  export type TiposCompraOrderByWithRelationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    Compras?: ComprasOrderByRelationAggregateInput
    _relevance?: TiposCompraOrderByRelevanceInput
  }

  export type TiposCompraWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: TiposCompraWhereInput | TiposCompraWhereInput[]
    OR?: TiposCompraWhereInput[]
    NOT?: TiposCompraWhereInput | TiposCompraWhereInput[]
    Code?: StringFilter<"TiposCompra"> | string
    Nombre?: StringFilter<"TiposCompra"> | string
    Compras?: ComprasListRelationFilter
  }, "Id">

  export type TiposCompraOrderByWithAggregationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    _count?: TiposCompraCountOrderByAggregateInput
    _avg?: TiposCompraAvgOrderByAggregateInput
    _max?: TiposCompraMaxOrderByAggregateInput
    _min?: TiposCompraMinOrderByAggregateInput
    _sum?: TiposCompraSumOrderByAggregateInput
  }

  export type TiposCompraScalarWhereWithAggregatesInput = {
    AND?: TiposCompraScalarWhereWithAggregatesInput | TiposCompraScalarWhereWithAggregatesInput[]
    OR?: TiposCompraScalarWhereWithAggregatesInput[]
    NOT?: TiposCompraScalarWhereWithAggregatesInput | TiposCompraScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"TiposCompra"> | number
    Code?: StringWithAggregatesFilter<"TiposCompra"> | string
    Nombre?: StringWithAggregatesFilter<"TiposCompra"> | string
  }

  export type UnidadesMedidaWhereInput = {
    AND?: UnidadesMedidaWhereInput | UnidadesMedidaWhereInput[]
    OR?: UnidadesMedidaWhereInput[]
    NOT?: UnidadesMedidaWhereInput | UnidadesMedidaWhereInput[]
    Id?: IntFilter<"UnidadesMedida"> | number
    Code?: StringFilter<"UnidadesMedida"> | string
    Nombre?: StringNullableFilter<"UnidadesMedida"> | string | null
    ListasPrecios?: ListasPreciosListRelationFilter
  }

  export type UnidadesMedidaOrderByWithRelationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrderInput | SortOrder
    ListasPrecios?: ListasPreciosOrderByRelationAggregateInput
    _relevance?: UnidadesMedidaOrderByRelevanceInput
  }

  export type UnidadesMedidaWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: UnidadesMedidaWhereInput | UnidadesMedidaWhereInput[]
    OR?: UnidadesMedidaWhereInput[]
    NOT?: UnidadesMedidaWhereInput | UnidadesMedidaWhereInput[]
    Code?: StringFilter<"UnidadesMedida"> | string
    Nombre?: StringNullableFilter<"UnidadesMedida"> | string | null
    ListasPrecios?: ListasPreciosListRelationFilter
  }, "Id">

  export type UnidadesMedidaOrderByWithAggregationInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrderInput | SortOrder
    _count?: UnidadesMedidaCountOrderByAggregateInput
    _avg?: UnidadesMedidaAvgOrderByAggregateInput
    _max?: UnidadesMedidaMaxOrderByAggregateInput
    _min?: UnidadesMedidaMinOrderByAggregateInput
    _sum?: UnidadesMedidaSumOrderByAggregateInput
  }

  export type UnidadesMedidaScalarWhereWithAggregatesInput = {
    AND?: UnidadesMedidaScalarWhereWithAggregatesInput | UnidadesMedidaScalarWhereWithAggregatesInput[]
    OR?: UnidadesMedidaScalarWhereWithAggregatesInput[]
    NOT?: UnidadesMedidaScalarWhereWithAggregatesInput | UnidadesMedidaScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"UnidadesMedida"> | number
    Code?: StringWithAggregatesFilter<"UnidadesMedida"> | string
    Nombre?: StringNullableWithAggregatesFilter<"UnidadesMedida"> | string | null
  }

  export type UsuariosWhereInput = {
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    Id?: IntFilter<"Usuarios"> | number
    Nombre?: StringFilter<"Usuarios"> | string
    RoleId?: IntNullableFilter<"Usuarios"> | number | null
    UsuariosLeier?: StringNullableFilter<"Usuarios"> | string | null
    Contrase_a?: StringNullableFilter<"Usuarios"> | string | null
    CreadoFecha?: DateTimeFilter<"Usuarios"> | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesListRelationFilter
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesListRelationFilter
    Inventario?: InventarioListRelationFilter
    RolesUSuario?: XOR<RolesUSuarioNullableScalarRelationFilter, RolesUSuarioWhereInput> | null
  }

  export type UsuariosOrderByWithRelationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    RoleId?: SortOrderInput | SortOrder
    UsuariosLeier?: SortOrderInput | SortOrder
    Contrase_a?: SortOrderInput | SortOrder
    CreadoFecha?: SortOrder
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesOrderByRelationAggregateInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesOrderByRelationAggregateInput
    Inventario?: InventarioOrderByRelationAggregateInput
    RolesUSuario?: RolesUSuarioOrderByWithRelationInput
    _relevance?: UsuariosOrderByRelevanceInput
  }

  export type UsuariosWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    Nombre?: StringFilter<"Usuarios"> | string
    RoleId?: IntNullableFilter<"Usuarios"> | number | null
    UsuariosLeier?: StringNullableFilter<"Usuarios"> | string | null
    Contrase_a?: StringNullableFilter<"Usuarios"> | string | null
    CreadoFecha?: DateTimeFilter<"Usuarios"> | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesListRelationFilter
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesListRelationFilter
    Inventario?: InventarioListRelationFilter
    RolesUSuario?: XOR<RolesUSuarioNullableScalarRelationFilter, RolesUSuarioWhereInput> | null
  }, "Id">

  export type UsuariosOrderByWithAggregationInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    RoleId?: SortOrderInput | SortOrder
    UsuariosLeier?: SortOrderInput | SortOrder
    Contrase_a?: SortOrderInput | SortOrder
    CreadoFecha?: SortOrder
    _count?: UsuariosCountOrderByAggregateInput
    _avg?: UsuariosAvgOrderByAggregateInput
    _max?: UsuariosMaxOrderByAggregateInput
    _min?: UsuariosMinOrderByAggregateInput
    _sum?: UsuariosSumOrderByAggregateInput
  }

  export type UsuariosScalarWhereWithAggregatesInput = {
    AND?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    OR?: UsuariosScalarWhereWithAggregatesInput[]
    NOT?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Usuarios"> | number
    Nombre?: StringWithAggregatesFilter<"Usuarios"> | string
    RoleId?: IntNullableWithAggregatesFilter<"Usuarios"> | number | null
    UsuariosLeier?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    Contrase_a?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    CreadoFecha?: DateTimeWithAggregatesFilter<"Usuarios"> | Date | string
  }

  export type VentasWhereInput = {
    AND?: VentasWhereInput | VentasWhereInput[]
    OR?: VentasWhereInput[]
    NOT?: VentasWhereInput | VentasWhereInput[]
    Id?: IntFilter<"Ventas"> | number
    Folio?: StringFilter<"Ventas"> | string
    ProductoId?: IntFilter<"Ventas"> | number
    Cantidad?: IntFilter<"Ventas"> | number
    ClienteId?: IntNullableFilter<"Ventas"> | number | null
    MetodoPagoId?: IntFilter<"Ventas"> | number
    Pagado?: BoolFilter<"Ventas"> | boolean
    FechaPago?: DateTimeNullableFilter<"Ventas"> | Date | string | null
    Observaciones?: StringNullableFilter<"Ventas"> | string | null
    CreadoFecha?: DateTimeFilter<"Ventas"> | Date | string
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
    Clientes?: XOR<ClientesNullableScalarRelationFilter, ClientesWhereInput> | null
    MetodosPago?: XOR<MetodosPagoScalarRelationFilter, MetodosPagoWhereInput>
  }

  export type VentasOrderByWithRelationInput = {
    Id?: SortOrder
    Folio?: SortOrder
    ProductoId?: SortOrder
    Cantidad?: SortOrder
    ClienteId?: SortOrderInput | SortOrder
    MetodoPagoId?: SortOrder
    Pagado?: SortOrder
    FechaPago?: SortOrderInput | SortOrder
    Observaciones?: SortOrderInput | SortOrder
    CreadoFecha?: SortOrder
    Productos?: ProductosOrderByWithRelationInput
    Clientes?: ClientesOrderByWithRelationInput
    MetodosPago?: MetodosPagoOrderByWithRelationInput
    _relevance?: VentasOrderByRelevanceInput
  }

  export type VentasWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: VentasWhereInput | VentasWhereInput[]
    OR?: VentasWhereInput[]
    NOT?: VentasWhereInput | VentasWhereInput[]
    Folio?: StringFilter<"Ventas"> | string
    ProductoId?: IntFilter<"Ventas"> | number
    Cantidad?: IntFilter<"Ventas"> | number
    ClienteId?: IntNullableFilter<"Ventas"> | number | null
    MetodoPagoId?: IntFilter<"Ventas"> | number
    Pagado?: BoolFilter<"Ventas"> | boolean
    FechaPago?: DateTimeNullableFilter<"Ventas"> | Date | string | null
    Observaciones?: StringNullableFilter<"Ventas"> | string | null
    CreadoFecha?: DateTimeFilter<"Ventas"> | Date | string
    Productos?: XOR<ProductosScalarRelationFilter, ProductosWhereInput>
    Clientes?: XOR<ClientesNullableScalarRelationFilter, ClientesWhereInput> | null
    MetodosPago?: XOR<MetodosPagoScalarRelationFilter, MetodosPagoWhereInput>
  }, "Id">

  export type VentasOrderByWithAggregationInput = {
    Id?: SortOrder
    Folio?: SortOrder
    ProductoId?: SortOrder
    Cantidad?: SortOrder
    ClienteId?: SortOrderInput | SortOrder
    MetodoPagoId?: SortOrder
    Pagado?: SortOrder
    FechaPago?: SortOrderInput | SortOrder
    Observaciones?: SortOrderInput | SortOrder
    CreadoFecha?: SortOrder
    _count?: VentasCountOrderByAggregateInput
    _avg?: VentasAvgOrderByAggregateInput
    _max?: VentasMaxOrderByAggregateInput
    _min?: VentasMinOrderByAggregateInput
    _sum?: VentasSumOrderByAggregateInput
  }

  export type VentasScalarWhereWithAggregatesInput = {
    AND?: VentasScalarWhereWithAggregatesInput | VentasScalarWhereWithAggregatesInput[]
    OR?: VentasScalarWhereWithAggregatesInput[]
    NOT?: VentasScalarWhereWithAggregatesInput | VentasScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Ventas"> | number
    Folio?: StringWithAggregatesFilter<"Ventas"> | string
    ProductoId?: IntWithAggregatesFilter<"Ventas"> | number
    Cantidad?: IntWithAggregatesFilter<"Ventas"> | number
    ClienteId?: IntNullableWithAggregatesFilter<"Ventas"> | number | null
    MetodoPagoId?: IntWithAggregatesFilter<"Ventas"> | number
    Pagado?: BoolWithAggregatesFilter<"Ventas"> | boolean
    FechaPago?: DateTimeNullableWithAggregatesFilter<"Ventas"> | Date | string | null
    Observaciones?: StringNullableWithAggregatesFilter<"Ventas"> | string | null
    CreadoFecha?: DateTimeWithAggregatesFilter<"Ventas"> | Date | string
  }

  export type AlmacenesCreateInput = {
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesUncheckedCreateInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    UsuarioId: number
    FechaModificacion?: Date | string | null
    ModificadoPor?: number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesUpdateInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios?: UsuariosUpdateOneRequiredWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosNestedInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosUpdateOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    UsuarioId?: IntFieldUpdateOperationsInput | number
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModificadoPor?: NullableIntFieldUpdateOperationsInput | number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesCreateManyInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    UsuarioId: number
    FechaModificacion?: Date | string | null
    ModificadoPor?: number | null
  }

  export type AlmacenesUpdateManyMutationInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlmacenesUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    UsuarioId?: IntFieldUpdateOperationsInput | number
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModificadoPor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoriasProductoCreateInput = {
    Code: string
    Nombre: string
    Productos?: ProductosCreateNestedManyWithoutCategoriasProductoInput
  }

  export type CategoriasProductoUncheckedCreateInput = {
    Id?: number
    Code: string
    Nombre: string
    Productos?: ProductosUncheckedCreateNestedManyWithoutCategoriasProductoInput
  }

  export type CategoriasProductoUpdateInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Productos?: ProductosUpdateManyWithoutCategoriasProductoNestedInput
  }

  export type CategoriasProductoUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Productos?: ProductosUncheckedUpdateManyWithoutCategoriasProductoNestedInput
  }

  export type CategoriasProductoCreateManyInput = {
    Id?: number
    Code: string
    Nombre: string
  }

  export type CategoriasProductoUpdateManyMutationInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriasProductoUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ClientesCreateInput = {
    Nombre: string
    Telefono?: string | null
    Ventas?: VentasCreateNestedManyWithoutClientesInput
  }

  export type ClientesUncheckedCreateInput = {
    Id?: number
    Nombre: string
    Telefono?: string | null
    Ventas?: VentasUncheckedCreateNestedManyWithoutClientesInput
  }

  export type ClientesUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Telefono?: NullableStringFieldUpdateOperationsInput | string | null
    Ventas?: VentasUpdateManyWithoutClientesNestedInput
  }

  export type ClientesUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Telefono?: NullableStringFieldUpdateOperationsInput | string | null
    Ventas?: VentasUncheckedUpdateManyWithoutClientesNestedInput
  }

  export type ClientesCreateManyInput = {
    Id?: number
    Nombre: string
    Telefono?: string | null
  }

  export type ClientesUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientesUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComprasCreateInput = {
    Folio: string
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    TiposCompra: TiposCompraCreateNestedOneWithoutComprasInput
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
    Productos?: ProductosCreateNestedOneWithoutComprasInput
    Insumos?: InsumosCreateNestedOneWithoutComprasInput
    Inventario?: InventarioCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    ProductoId?: number | null
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    Inventario?: InventarioUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasUpdateInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    TiposCompra?: TiposCompraUpdateOneRequiredWithoutComprasNestedInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasNestedInput
    Productos?: ProductosUpdateOneWithoutComprasNestedInput
    Insumos?: InsumosUpdateOneWithoutComprasNestedInput
    Inventario?: InventarioUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProveedorId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Inventario?: InventarioUncheckedUpdateManyWithoutComprasNestedInput
  }

  export type ComprasCreateManyInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    ProductoId?: number | null
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
  }

  export type ComprasUpdateManyMutationInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprasUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProveedorId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagenesProductosCreateInput = {
    URLImagen?: string | null
    Productos: ProductosCreateNestedOneWithoutImagenesProductosInput
  }

  export type ImagenesProductosUncheckedCreateInput = {
    Id?: number
    URLImagen?: string | null
    ProductoId: number
  }

  export type ImagenesProductosUpdateInput = {
    URLImagen?: NullableStringFieldUpdateOperationsInput | string | null
    Productos?: ProductosUpdateOneRequiredWithoutImagenesProductosNestedInput
  }

  export type ImagenesProductosUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    URLImagen?: NullableStringFieldUpdateOperationsInput | string | null
    ProductoId?: IntFieldUpdateOperationsInput | number
  }

  export type ImagenesProductosCreateManyInput = {
    Id?: number
    URLImagen?: string | null
    ProductoId: number
  }

  export type ImagenesProductosUpdateManyMutationInput = {
    URLImagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImagenesProductosUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    URLImagen?: NullableStringFieldUpdateOperationsInput | string | null
    ProductoId?: IntFieldUpdateOperationsInput | number
  }

  export type InsumosCreateInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    CantidadRecibida?: number | null
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Compras?: ComprasCreateNestedManyWithoutInsumosInput
  }

  export type InsumosUncheckedCreateInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    CantidadRecibida?: number | null
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Compras?: ComprasUncheckedCreateNestedManyWithoutInsumosInput
  }

  export type InsumosUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: NullableIntFieldUpdateOperationsInput | number | null
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Compras?: ComprasUpdateManyWithoutInsumosNestedInput
  }

  export type InsumosUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: NullableIntFieldUpdateOperationsInput | number | null
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Compras?: ComprasUncheckedUpdateManyWithoutInsumosNestedInput
  }

  export type InsumosCreateManyInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    CantidadRecibida?: number | null
    CostoUnitario: Decimal | DecimalJsLike | number | string
  }

  export type InsumosUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: NullableIntFieldUpdateOperationsInput | number | null
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InsumosUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: NullableIntFieldUpdateOperationsInput | number | null
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventarioCreateInput = {
    CantidadRecibida: number
    FechaSurtido: Date | string
    CreadoFecha: Date | string
    Compras: ComprasCreateNestedOneWithoutInventarioInput
    Productos: ProductosCreateNestedOneWithoutInventarioInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    Usuarios: UsuariosCreateNestedOneWithoutInventarioInput
  }

  export type InventarioUncheckedCreateInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioUpdateInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Compras?: ComprasUpdateOneRequiredWithoutInventarioNestedInput
    Productos?: ProductosUpdateOneRequiredWithoutInventarioNestedInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
    Usuarios?: UsuariosUpdateOneRequiredWithoutInventarioNestedInput
  }

  export type InventarioUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioCreateManyInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioUpdateManyMutationInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type ListasPreciosCreateInput = {
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
    Productos: ProductosCreateNestedOneWithoutListasPreciosInput
    UnidadesMedida: UnidadesMedidaCreateNestedOneWithoutListasPreciosInput
  }

  export type ListasPreciosUncheckedCreateInput = {
    Id?: number
    ProductoId: number
    UnidadMedidaId: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
  }

  export type ListasPreciosUpdateInput = {
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
    Productos?: ProductosUpdateOneRequiredWithoutListasPreciosNestedInput
    UnidadesMedida?: UnidadesMedidaUpdateOneRequiredWithoutListasPreciosNestedInput
  }

  export type ListasPreciosUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    UnidadMedidaId?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ListasPreciosCreateManyInput = {
    Id?: number
    ProductoId: number
    UnidadMedidaId: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
  }

  export type ListasPreciosUpdateManyMutationInput = {
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ListasPreciosUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    UnidadMedidaId?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MetodosPagoCreateInput = {
    code: string
    Nombre: string
    Ventas?: VentasCreateNestedManyWithoutMetodosPagoInput
  }

  export type MetodosPagoUncheckedCreateInput = {
    Id?: number
    code: string
    Nombre: string
    Ventas?: VentasUncheckedCreateNestedManyWithoutMetodosPagoInput
  }

  export type MetodosPagoUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Ventas?: VentasUpdateManyWithoutMetodosPagoNestedInput
  }

  export type MetodosPagoUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Ventas?: VentasUncheckedUpdateManyWithoutMetodosPagoNestedInput
  }

  export type MetodosPagoCreateManyInput = {
    Id?: number
    code: string
    Nombre: string
  }

  export type MetodosPagoUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MetodosPagoUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductosCreateInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    Compras?: ComprasCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosCreateNestedManyWithoutProductosInput
    Inventario?: InventarioCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosCreateNestedManyWithoutProductosInput
    CategoriasProducto: CategoriasProductoCreateNestedOneWithoutProductosInput
    Ventas?: VentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    CategoriaId: number
    Compras?: ComprasUncheckedCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosUncheckedCreateNestedManyWithoutProductosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosUncheckedCreateNestedManyWithoutProductosInput
    Ventas?: VentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUpdateManyWithoutProductosNestedInput
    CategoriasProducto?: CategoriasProductoUpdateOneRequiredWithoutProductosNestedInput
    Ventas?: VentasUpdateManyWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    CategoriaId?: IntFieldUpdateOperationsInput | number
    Compras?: ComprasUncheckedUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUncheckedUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUncheckedUpdateManyWithoutProductosNestedInput
    Ventas?: VentasUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type ProductosCreateManyInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    CategoriaId: number
  }

  export type ProductosUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductosUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    CategoriaId?: IntFieldUpdateOperationsInput | number
  }

  export type ProveedoresCreateInput = {
    Nombre: string
    Compras?: ComprasCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresUncheckedCreateInput = {
    Id?: number
    Nombre: string
    Compras?: ComprasUncheckedCreateNestedManyWithoutProveedoresInput
  }

  export type ProveedoresUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Compras?: ComprasUpdateManyWithoutProveedoresNestedInput
  }

  export type ProveedoresUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Compras?: ComprasUncheckedUpdateManyWithoutProveedoresNestedInput
  }

  export type ProveedoresCreateManyInput = {
    Id?: number
    Nombre: string
  }

  export type ProveedoresUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProveedoresUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUSuarioCreateInput = {
    Nombre: string
    Usuarios?: UsuariosCreateNestedManyWithoutRolesUSuarioInput
  }

  export type RolesUSuarioUncheckedCreateInput = {
    Id?: number
    Nombre: string
    Usuarios?: UsuariosUncheckedCreateNestedManyWithoutRolesUSuarioInput
  }

  export type RolesUSuarioUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Usuarios?: UsuariosUpdateManyWithoutRolesUSuarioNestedInput
  }

  export type RolesUSuarioUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Usuarios?: UsuariosUncheckedUpdateManyWithoutRolesUSuarioNestedInput
  }

  export type RolesUSuarioCreateManyInput = {
    Id?: number
    Nombre: string
  }

  export type RolesUSuarioUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUSuarioUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TiposCompraCreateInput = {
    Code: string
    Nombre: string
    Compras?: ComprasCreateNestedManyWithoutTiposCompraInput
  }

  export type TiposCompraUncheckedCreateInput = {
    Id?: number
    Code: string
    Nombre: string
    Compras?: ComprasUncheckedCreateNestedManyWithoutTiposCompraInput
  }

  export type TiposCompraUpdateInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Compras?: ComprasUpdateManyWithoutTiposCompraNestedInput
  }

  export type TiposCompraUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Compras?: ComprasUncheckedUpdateManyWithoutTiposCompraNestedInput
  }

  export type TiposCompraCreateManyInput = {
    Id?: number
    Code: string
    Nombre: string
  }

  export type TiposCompraUpdateManyMutationInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TiposCompraUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UnidadesMedidaCreateInput = {
    Code: string
    Nombre?: string | null
    ListasPrecios?: ListasPreciosCreateNestedManyWithoutUnidadesMedidaInput
  }

  export type UnidadesMedidaUncheckedCreateInput = {
    Id?: number
    Code: string
    Nombre?: string | null
    ListasPrecios?: ListasPreciosUncheckedCreateNestedManyWithoutUnidadesMedidaInput
  }

  export type UnidadesMedidaUpdateInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    ListasPrecios?: ListasPreciosUpdateManyWithoutUnidadesMedidaNestedInput
  }

  export type UnidadesMedidaUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
    ListasPrecios?: ListasPreciosUncheckedUpdateManyWithoutUnidadesMedidaNestedInput
  }

  export type UnidadesMedidaCreateManyInput = {
    Id?: number
    Code: string
    Nombre?: string | null
  }

  export type UnidadesMedidaUpdateManyMutationInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnidadesMedidaUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuariosCreateInput = {
    Nombre: string
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
    Inventario?: InventarioCreateNestedManyWithoutUsuariosInput
    RolesUSuario?: RolesUSuarioCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateInput = {
    Id?: number
    Nombre: string
    RoleId?: number | null
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario?: InventarioUpdateManyWithoutUsuariosNestedInput
    RolesUSuario?: RolesUSuarioUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosCreateManyInput = {
    Id?: number
    Nombre: string
    RoleId?: number | null
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
  }

  export type UsuariosUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentasCreateInput = {
    Folio: string
    Cantidad: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
    Productos: ProductosCreateNestedOneWithoutVentasInput
    Clientes?: ClientesCreateNestedOneWithoutVentasInput
    MetodosPago: MetodosPagoCreateNestedOneWithoutVentasInput
  }

  export type VentasUncheckedCreateInput = {
    Id?: number
    Folio: string
    ProductoId: number
    Cantidad: number
    ClienteId?: number | null
    MetodoPagoId: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type VentasUpdateInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Productos?: ProductosUpdateOneRequiredWithoutVentasNestedInput
    Clientes?: ClientesUpdateOneWithoutVentasNestedInput
    MetodosPago?: MetodosPagoUpdateOneRequiredWithoutVentasNestedInput
  }

  export type VentasUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProductoId?: IntFieldUpdateOperationsInput | number
    Cantidad?: IntFieldUpdateOperationsInput | number
    ClienteId?: NullableIntFieldUpdateOperationsInput | number | null
    MetodoPagoId?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentasCreateManyInput = {
    Id?: number
    Folio: string
    ProductoId: number
    Cantidad: number
    ClienteId?: number | null
    MetodoPagoId: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type VentasUpdateManyMutationInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentasUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProductoId?: IntFieldUpdateOperationsInput | number
    Cantidad?: IntFieldUpdateOperationsInput | number
    ClienteId?: NullableIntFieldUpdateOperationsInput | number | null
    MetodoPagoId?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UsuariosScalarRelationFilter = {
    is?: UsuariosWhereInput
    isNot?: UsuariosWhereInput
  }

  export type UsuariosNullableScalarRelationFilter = {
    is?: UsuariosWhereInput | null
    isNot?: UsuariosWhereInput | null
  }

  export type InventarioListRelationFilter = {
    every?: InventarioWhereInput
    some?: InventarioWhereInput
    none?: InventarioWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InventarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlmacenesOrderByRelevanceInput = {
    fields: AlmacenesOrderByRelevanceFieldEnum | AlmacenesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AlmacenesCountOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    Existencia_bolsas?: SortOrder
    Existencia_kg?: SortOrder
    CreadoFecha?: SortOrder
    UsuarioId?: SortOrder
    FechaModificacion?: SortOrder
    ModificadoPor?: SortOrder
  }

  export type AlmacenesAvgOrderByAggregateInput = {
    Id?: SortOrder
    Existencia_bolsas?: SortOrder
    Existencia_kg?: SortOrder
    UsuarioId?: SortOrder
    ModificadoPor?: SortOrder
  }

  export type AlmacenesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    Existencia_bolsas?: SortOrder
    Existencia_kg?: SortOrder
    CreadoFecha?: SortOrder
    UsuarioId?: SortOrder
    FechaModificacion?: SortOrder
    ModificadoPor?: SortOrder
  }

  export type AlmacenesMinOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
    Existencia_bolsas?: SortOrder
    Existencia_kg?: SortOrder
    CreadoFecha?: SortOrder
    UsuarioId?: SortOrder
    FechaModificacion?: SortOrder
    ModificadoPor?: SortOrder
  }

  export type AlmacenesSumOrderByAggregateInput = {
    Id?: SortOrder
    Existencia_bolsas?: SortOrder
    Existencia_kg?: SortOrder
    UsuarioId?: SortOrder
    ModificadoPor?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductosListRelationFilter = {
    every?: ProductosWhereInput
    some?: ProductosWhereInput
    none?: ProductosWhereInput
  }

  export type ProductosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriasProductoOrderByRelevanceInput = {
    fields: CategoriasProductoOrderByRelevanceFieldEnum | CategoriasProductoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoriasProductoCountOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type CategoriasProductoAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type CategoriasProductoMaxOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type CategoriasProductoMinOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type CategoriasProductoSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type VentasListRelationFilter = {
    every?: VentasWhereInput
    some?: VentasWhereInput
    none?: VentasWhereInput
  }

  export type VentasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientesOrderByRelevanceInput = {
    fields: ClientesOrderByRelevanceFieldEnum | ClientesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientesCountOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Telefono?: SortOrder
  }

  export type ClientesAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type ClientesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Telefono?: SortOrder
  }

  export type ClientesMinOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Telefono?: SortOrder
  }

  export type ClientesSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TiposCompraScalarRelationFilter = {
    is?: TiposCompraWhereInput
    isNot?: TiposCompraWhereInput
  }

  export type ProveedoresScalarRelationFilter = {
    is?: ProveedoresWhereInput
    isNot?: ProveedoresWhereInput
  }

  export type ProductosNullableScalarRelationFilter = {
    is?: ProductosWhereInput | null
    isNot?: ProductosWhereInput | null
  }

  export type InsumosNullableScalarRelationFilter = {
    is?: InsumosWhereInput | null
    isNot?: InsumosWhereInput | null
  }

  export type ComprasOrderByRelevanceInput = {
    fields: ComprasOrderByRelevanceFieldEnum | ComprasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComprasCountOrderByAggregateInput = {
    Id?: SortOrder
    Folio?: SortOrder
    TipoCompraId?: SortOrder
    ProveedorId?: SortOrder
    ProductoId?: SortOrder
    InsumoId?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
    PrecioUnitario?: SortOrder
    FechaRecepcion?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type ComprasAvgOrderByAggregateInput = {
    Id?: SortOrder
    TipoCompraId?: SortOrder
    ProveedorId?: SortOrder
    ProductoId?: SortOrder
    InsumoId?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
    PrecioUnitario?: SortOrder
  }

  export type ComprasMaxOrderByAggregateInput = {
    Id?: SortOrder
    Folio?: SortOrder
    TipoCompraId?: SortOrder
    ProveedorId?: SortOrder
    ProductoId?: SortOrder
    InsumoId?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
    PrecioUnitario?: SortOrder
    FechaRecepcion?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type ComprasMinOrderByAggregateInput = {
    Id?: SortOrder
    Folio?: SortOrder
    TipoCompraId?: SortOrder
    ProveedorId?: SortOrder
    ProductoId?: SortOrder
    InsumoId?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
    PrecioUnitario?: SortOrder
    FechaRecepcion?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type ComprasSumOrderByAggregateInput = {
    Id?: SortOrder
    TipoCompraId?: SortOrder
    ProveedorId?: SortOrder
    ProductoId?: SortOrder
    InsumoId?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
    PrecioUnitario?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProductosScalarRelationFilter = {
    is?: ProductosWhereInput
    isNot?: ProductosWhereInput
  }

  export type ImagenesProductosOrderByRelevanceInput = {
    fields: ImagenesProductosOrderByRelevanceFieldEnum | ImagenesProductosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImagenesProductosCountOrderByAggregateInput = {
    Id?: SortOrder
    URLImagen?: SortOrder
    ProductoId?: SortOrder
  }

  export type ImagenesProductosAvgOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
  }

  export type ImagenesProductosMaxOrderByAggregateInput = {
    Id?: SortOrder
    URLImagen?: SortOrder
    ProductoId?: SortOrder
  }

  export type ImagenesProductosMinOrderByAggregateInput = {
    Id?: SortOrder
    URLImagen?: SortOrder
    ProductoId?: SortOrder
  }

  export type ImagenesProductosSumOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
  }

  export type ComprasListRelationFilter = {
    every?: ComprasWhereInput
    some?: ComprasWhereInput
    none?: ComprasWhereInput
  }

  export type ComprasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsumosOrderByRelevanceInput = {
    fields: InsumosOrderByRelevanceFieldEnum | InsumosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InsumosCountOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
  }

  export type InsumosAvgOrderByAggregateInput = {
    Id?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
  }

  export type InsumosMaxOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
  }

  export type InsumosMinOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
  }

  export type InsumosSumOrderByAggregateInput = {
    Id?: SortOrder
    Cantidad?: SortOrder
    CantidadRecibida?: SortOrder
    CostoUnitario?: SortOrder
  }

  export type ComprasScalarRelationFilter = {
    is?: ComprasWhereInput
    isNot?: ComprasWhereInput
  }

  export type AlmacenesScalarRelationFilter = {
    is?: AlmacenesWhereInput
    isNot?: AlmacenesWhereInput
  }

  export type InventarioCountOrderByAggregateInput = {
    Id?: SortOrder
    CompraId?: SortOrder
    ProductoId?: SortOrder
    CantidadRecibida?: SortOrder
    AlmacenActualId?: SortOrder
    FechaSurtido?: SortOrder
    SurtidoPorAlmacenId?: SortOrder
    RecibidoPorAlmacenId?: SortOrder
    CreadoFecha?: SortOrder
    CreadoPor?: SortOrder
  }

  export type InventarioAvgOrderByAggregateInput = {
    Id?: SortOrder
    CompraId?: SortOrder
    ProductoId?: SortOrder
    CantidadRecibida?: SortOrder
    AlmacenActualId?: SortOrder
    SurtidoPorAlmacenId?: SortOrder
    RecibidoPorAlmacenId?: SortOrder
    CreadoPor?: SortOrder
  }

  export type InventarioMaxOrderByAggregateInput = {
    Id?: SortOrder
    CompraId?: SortOrder
    ProductoId?: SortOrder
    CantidadRecibida?: SortOrder
    AlmacenActualId?: SortOrder
    FechaSurtido?: SortOrder
    SurtidoPorAlmacenId?: SortOrder
    RecibidoPorAlmacenId?: SortOrder
    CreadoFecha?: SortOrder
    CreadoPor?: SortOrder
  }

  export type InventarioMinOrderByAggregateInput = {
    Id?: SortOrder
    CompraId?: SortOrder
    ProductoId?: SortOrder
    CantidadRecibida?: SortOrder
    AlmacenActualId?: SortOrder
    FechaSurtido?: SortOrder
    SurtidoPorAlmacenId?: SortOrder
    RecibidoPorAlmacenId?: SortOrder
    CreadoFecha?: SortOrder
    CreadoPor?: SortOrder
  }

  export type InventarioSumOrderByAggregateInput = {
    Id?: SortOrder
    CompraId?: SortOrder
    ProductoId?: SortOrder
    CantidadRecibida?: SortOrder
    AlmacenActualId?: SortOrder
    SurtidoPorAlmacenId?: SortOrder
    RecibidoPorAlmacenId?: SortOrder
    CreadoPor?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UnidadesMedidaScalarRelationFilter = {
    is?: UnidadesMedidaWhereInput
    isNot?: UnidadesMedidaWhereInput
  }

  export type ListasPreciosCountOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    UnidadMedidaId?: SortOrder
    CostoUnitario?: SortOrder
    Utilidad?: SortOrder
    PrecioUnitario?: SortOrder
    CreadoFecha?: SortOrder
    Vigente?: SortOrder
  }

  export type ListasPreciosAvgOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    UnidadMedidaId?: SortOrder
    CostoUnitario?: SortOrder
    Utilidad?: SortOrder
    PrecioUnitario?: SortOrder
  }

  export type ListasPreciosMaxOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    UnidadMedidaId?: SortOrder
    CostoUnitario?: SortOrder
    Utilidad?: SortOrder
    PrecioUnitario?: SortOrder
    CreadoFecha?: SortOrder
    Vigente?: SortOrder
  }

  export type ListasPreciosMinOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    UnidadMedidaId?: SortOrder
    CostoUnitario?: SortOrder
    Utilidad?: SortOrder
    PrecioUnitario?: SortOrder
    CreadoFecha?: SortOrder
    Vigente?: SortOrder
  }

  export type ListasPreciosSumOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    UnidadMedidaId?: SortOrder
    CostoUnitario?: SortOrder
    Utilidad?: SortOrder
    PrecioUnitario?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MetodosPagoOrderByRelevanceInput = {
    fields: MetodosPagoOrderByRelevanceFieldEnum | MetodosPagoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MetodosPagoCountOrderByAggregateInput = {
    Id?: SortOrder
    code?: SortOrder
    Nombre?: SortOrder
  }

  export type MetodosPagoAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type MetodosPagoMaxOrderByAggregateInput = {
    Id?: SortOrder
    code?: SortOrder
    Nombre?: SortOrder
  }

  export type MetodosPagoMinOrderByAggregateInput = {
    Id?: SortOrder
    code?: SortOrder
    Nombre?: SortOrder
  }

  export type MetodosPagoSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type ImagenesProductosListRelationFilter = {
    every?: ImagenesProductosWhereInput
    some?: ImagenesProductosWhereInput
    none?: ImagenesProductosWhereInput
  }

  export type ListasPreciosListRelationFilter = {
    every?: ListasPreciosWhereInput
    some?: ListasPreciosWhereInput
    none?: ListasPreciosWhereInput
  }

  export type CategoriasProductoScalarRelationFilter = {
    is?: CategoriasProductoWhereInput
    isNot?: CategoriasProductoWhereInput
  }

  export type ImagenesProductosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListasPreciosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductosOrderByRelevanceInput = {
    fields: ProductosOrderByRelevanceFieldEnum | ProductosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductosCountOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrder
    Cantidad?: SortOrder
    EsPieza?: SortOrder
    CategoriaId?: SortOrder
  }

  export type ProductosAvgOrderByAggregateInput = {
    Id?: SortOrder
    Cantidad?: SortOrder
    CategoriaId?: SortOrder
  }

  export type ProductosMaxOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrder
    Cantidad?: SortOrder
    EsPieza?: SortOrder
    CategoriaId?: SortOrder
  }

  export type ProductosMinOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    Descripcion?: SortOrder
    Cantidad?: SortOrder
    EsPieza?: SortOrder
    CategoriaId?: SortOrder
  }

  export type ProductosSumOrderByAggregateInput = {
    Id?: SortOrder
    Cantidad?: SortOrder
    CategoriaId?: SortOrder
  }

  export type ProveedoresOrderByRelevanceInput = {
    fields: ProveedoresOrderByRelevanceFieldEnum | ProveedoresOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProveedoresCountOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
  }

  export type ProveedoresAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type ProveedoresMaxOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
  }

  export type ProveedoresMinOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
  }

  export type ProveedoresSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UsuariosListRelationFilter = {
    every?: UsuariosWhereInput
    some?: UsuariosWhereInput
    none?: UsuariosWhereInput
  }

  export type UsuariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesUSuarioOrderByRelevanceInput = {
    fields: RolesUSuarioOrderByRelevanceFieldEnum | RolesUSuarioOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolesUSuarioCountOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
  }

  export type RolesUSuarioAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type RolesUSuarioMaxOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
  }

  export type RolesUSuarioMinOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
  }

  export type RolesUSuarioSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type TiposCompraOrderByRelevanceInput = {
    fields: TiposCompraOrderByRelevanceFieldEnum | TiposCompraOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TiposCompraCountOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type TiposCompraAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type TiposCompraMaxOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type TiposCompraMinOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type TiposCompraSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UnidadesMedidaOrderByRelevanceInput = {
    fields: UnidadesMedidaOrderByRelevanceFieldEnum | UnidadesMedidaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnidadesMedidaCountOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type UnidadesMedidaAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UnidadesMedidaMaxOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type UnidadesMedidaMinOrderByAggregateInput = {
    Id?: SortOrder
    Code?: SortOrder
    Nombre?: SortOrder
  }

  export type UnidadesMedidaSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AlmacenesListRelationFilter = {
    every?: AlmacenesWhereInput
    some?: AlmacenesWhereInput
    none?: AlmacenesWhereInput
  }

  export type RolesUSuarioNullableScalarRelationFilter = {
    is?: RolesUSuarioWhereInput | null
    isNot?: RolesUSuarioWhereInput | null
  }

  export type AlmacenesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuariosOrderByRelevanceInput = {
    fields: UsuariosOrderByRelevanceFieldEnum | UsuariosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsuariosCountOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    RoleId?: SortOrder
    UsuariosLeier?: SortOrder
    Contrase_a?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type UsuariosAvgOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
  }

  export type UsuariosMaxOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    RoleId?: SortOrder
    UsuariosLeier?: SortOrder
    Contrase_a?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type UsuariosMinOrderByAggregateInput = {
    Id?: SortOrder
    Nombre?: SortOrder
    RoleId?: SortOrder
    UsuariosLeier?: SortOrder
    Contrase_a?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type UsuariosSumOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
  }

  export type ClientesNullableScalarRelationFilter = {
    is?: ClientesWhereInput | null
    isNot?: ClientesWhereInput | null
  }

  export type MetodosPagoScalarRelationFilter = {
    is?: MetodosPagoWhereInput
    isNot?: MetodosPagoWhereInput
  }

  export type VentasOrderByRelevanceInput = {
    fields: VentasOrderByRelevanceFieldEnum | VentasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VentasCountOrderByAggregateInput = {
    Id?: SortOrder
    Folio?: SortOrder
    ProductoId?: SortOrder
    Cantidad?: SortOrder
    ClienteId?: SortOrder
    MetodoPagoId?: SortOrder
    Pagado?: SortOrder
    FechaPago?: SortOrder
    Observaciones?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type VentasAvgOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    Cantidad?: SortOrder
    ClienteId?: SortOrder
    MetodoPagoId?: SortOrder
  }

  export type VentasMaxOrderByAggregateInput = {
    Id?: SortOrder
    Folio?: SortOrder
    ProductoId?: SortOrder
    Cantidad?: SortOrder
    ClienteId?: SortOrder
    MetodoPagoId?: SortOrder
    Pagado?: SortOrder
    FechaPago?: SortOrder
    Observaciones?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type VentasMinOrderByAggregateInput = {
    Id?: SortOrder
    Folio?: SortOrder
    ProductoId?: SortOrder
    Cantidad?: SortOrder
    ClienteId?: SortOrder
    MetodoPagoId?: SortOrder
    Pagado?: SortOrder
    FechaPago?: SortOrder
    Observaciones?: SortOrder
    CreadoFecha?: SortOrder
  }

  export type VentasSumOrderByAggregateInput = {
    Id?: SortOrder
    ProductoId?: SortOrder
    Cantidad?: SortOrder
    ClienteId?: SortOrder
    MetodoPagoId?: SortOrder
  }

  export type UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    create?: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    create?: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type InventarioCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UsuariosUpdateOneRequiredWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    upsert?: UsuariosUpsertWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput, UsuariosUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>, UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>
  }

  export type UsuariosUpdateOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    upsert?: UsuariosUpsertWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput, UsuariosUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>, UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>
  }

  export type InventarioUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput = {
    create?: XOR<InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput> | InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[] | InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    createMany?: InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type ProductosCreateNestedManyWithoutCategoriasProductoInput = {
    create?: XOR<ProductosCreateWithoutCategoriasProductoInput, ProductosUncheckedCreateWithoutCategoriasProductoInput> | ProductosCreateWithoutCategoriasProductoInput[] | ProductosUncheckedCreateWithoutCategoriasProductoInput[]
    connectOrCreate?: ProductosCreateOrConnectWithoutCategoriasProductoInput | ProductosCreateOrConnectWithoutCategoriasProductoInput[]
    createMany?: ProductosCreateManyCategoriasProductoInputEnvelope
    connect?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
  }

  export type ProductosUncheckedCreateNestedManyWithoutCategoriasProductoInput = {
    create?: XOR<ProductosCreateWithoutCategoriasProductoInput, ProductosUncheckedCreateWithoutCategoriasProductoInput> | ProductosCreateWithoutCategoriasProductoInput[] | ProductosUncheckedCreateWithoutCategoriasProductoInput[]
    connectOrCreate?: ProductosCreateOrConnectWithoutCategoriasProductoInput | ProductosCreateOrConnectWithoutCategoriasProductoInput[]
    createMany?: ProductosCreateManyCategoriasProductoInputEnvelope
    connect?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
  }

  export type ProductosUpdateManyWithoutCategoriasProductoNestedInput = {
    create?: XOR<ProductosCreateWithoutCategoriasProductoInput, ProductosUncheckedCreateWithoutCategoriasProductoInput> | ProductosCreateWithoutCategoriasProductoInput[] | ProductosUncheckedCreateWithoutCategoriasProductoInput[]
    connectOrCreate?: ProductosCreateOrConnectWithoutCategoriasProductoInput | ProductosCreateOrConnectWithoutCategoriasProductoInput[]
    upsert?: ProductosUpsertWithWhereUniqueWithoutCategoriasProductoInput | ProductosUpsertWithWhereUniqueWithoutCategoriasProductoInput[]
    createMany?: ProductosCreateManyCategoriasProductoInputEnvelope
    set?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    disconnect?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    delete?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    connect?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    update?: ProductosUpdateWithWhereUniqueWithoutCategoriasProductoInput | ProductosUpdateWithWhereUniqueWithoutCategoriasProductoInput[]
    updateMany?: ProductosUpdateManyWithWhereWithoutCategoriasProductoInput | ProductosUpdateManyWithWhereWithoutCategoriasProductoInput[]
    deleteMany?: ProductosScalarWhereInput | ProductosScalarWhereInput[]
  }

  export type ProductosUncheckedUpdateManyWithoutCategoriasProductoNestedInput = {
    create?: XOR<ProductosCreateWithoutCategoriasProductoInput, ProductosUncheckedCreateWithoutCategoriasProductoInput> | ProductosCreateWithoutCategoriasProductoInput[] | ProductosUncheckedCreateWithoutCategoriasProductoInput[]
    connectOrCreate?: ProductosCreateOrConnectWithoutCategoriasProductoInput | ProductosCreateOrConnectWithoutCategoriasProductoInput[]
    upsert?: ProductosUpsertWithWhereUniqueWithoutCategoriasProductoInput | ProductosUpsertWithWhereUniqueWithoutCategoriasProductoInput[]
    createMany?: ProductosCreateManyCategoriasProductoInputEnvelope
    set?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    disconnect?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    delete?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    connect?: ProductosWhereUniqueInput | ProductosWhereUniqueInput[]
    update?: ProductosUpdateWithWhereUniqueWithoutCategoriasProductoInput | ProductosUpdateWithWhereUniqueWithoutCategoriasProductoInput[]
    updateMany?: ProductosUpdateManyWithWhereWithoutCategoriasProductoInput | ProductosUpdateManyWithWhereWithoutCategoriasProductoInput[]
    deleteMany?: ProductosScalarWhereInput | ProductosScalarWhereInput[]
  }

  export type VentasCreateNestedManyWithoutClientesInput = {
    create?: XOR<VentasCreateWithoutClientesInput, VentasUncheckedCreateWithoutClientesInput> | VentasCreateWithoutClientesInput[] | VentasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutClientesInput | VentasCreateOrConnectWithoutClientesInput[]
    createMany?: VentasCreateManyClientesInputEnvelope
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
  }

  export type VentasUncheckedCreateNestedManyWithoutClientesInput = {
    create?: XOR<VentasCreateWithoutClientesInput, VentasUncheckedCreateWithoutClientesInput> | VentasCreateWithoutClientesInput[] | VentasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutClientesInput | VentasCreateOrConnectWithoutClientesInput[]
    createMany?: VentasCreateManyClientesInputEnvelope
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type VentasUpdateManyWithoutClientesNestedInput = {
    create?: XOR<VentasCreateWithoutClientesInput, VentasUncheckedCreateWithoutClientesInput> | VentasCreateWithoutClientesInput[] | VentasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutClientesInput | VentasCreateOrConnectWithoutClientesInput[]
    upsert?: VentasUpsertWithWhereUniqueWithoutClientesInput | VentasUpsertWithWhereUniqueWithoutClientesInput[]
    createMany?: VentasCreateManyClientesInputEnvelope
    set?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    disconnect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    delete?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    update?: VentasUpdateWithWhereUniqueWithoutClientesInput | VentasUpdateWithWhereUniqueWithoutClientesInput[]
    updateMany?: VentasUpdateManyWithWhereWithoutClientesInput | VentasUpdateManyWithWhereWithoutClientesInput[]
    deleteMany?: VentasScalarWhereInput | VentasScalarWhereInput[]
  }

  export type VentasUncheckedUpdateManyWithoutClientesNestedInput = {
    create?: XOR<VentasCreateWithoutClientesInput, VentasUncheckedCreateWithoutClientesInput> | VentasCreateWithoutClientesInput[] | VentasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutClientesInput | VentasCreateOrConnectWithoutClientesInput[]
    upsert?: VentasUpsertWithWhereUniqueWithoutClientesInput | VentasUpsertWithWhereUniqueWithoutClientesInput[]
    createMany?: VentasCreateManyClientesInputEnvelope
    set?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    disconnect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    delete?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    update?: VentasUpdateWithWhereUniqueWithoutClientesInput | VentasUpdateWithWhereUniqueWithoutClientesInput[]
    updateMany?: VentasUpdateManyWithWhereWithoutClientesInput | VentasUpdateManyWithWhereWithoutClientesInput[]
    deleteMany?: VentasScalarWhereInput | VentasScalarWhereInput[]
  }

  export type TiposCompraCreateNestedOneWithoutComprasInput = {
    create?: XOR<TiposCompraCreateWithoutComprasInput, TiposCompraUncheckedCreateWithoutComprasInput>
    connectOrCreate?: TiposCompraCreateOrConnectWithoutComprasInput
    connect?: TiposCompraWhereUniqueInput
  }

  export type ProveedoresCreateNestedOneWithoutComprasInput = {
    create?: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
    connectOrCreate?: ProveedoresCreateOrConnectWithoutComprasInput
    connect?: ProveedoresWhereUniqueInput
  }

  export type ProductosCreateNestedOneWithoutComprasInput = {
    create?: XOR<ProductosCreateWithoutComprasInput, ProductosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutComprasInput
    connect?: ProductosWhereUniqueInput
  }

  export type InsumosCreateNestedOneWithoutComprasInput = {
    create?: XOR<InsumosCreateWithoutComprasInput, InsumosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: InsumosCreateOrConnectWithoutComprasInput
    connect?: InsumosWhereUniqueInput
  }

  export type InventarioCreateNestedManyWithoutComprasInput = {
    create?: XOR<InventarioCreateWithoutComprasInput, InventarioUncheckedCreateWithoutComprasInput> | InventarioCreateWithoutComprasInput[] | InventarioUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutComprasInput | InventarioCreateOrConnectWithoutComprasInput[]
    createMany?: InventarioCreateManyComprasInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutComprasInput = {
    create?: XOR<InventarioCreateWithoutComprasInput, InventarioUncheckedCreateWithoutComprasInput> | InventarioCreateWithoutComprasInput[] | InventarioUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutComprasInput | InventarioCreateOrConnectWithoutComprasInput[]
    createMany?: InventarioCreateManyComprasInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TiposCompraUpdateOneRequiredWithoutComprasNestedInput = {
    create?: XOR<TiposCompraCreateWithoutComprasInput, TiposCompraUncheckedCreateWithoutComprasInput>
    connectOrCreate?: TiposCompraCreateOrConnectWithoutComprasInput
    upsert?: TiposCompraUpsertWithoutComprasInput
    connect?: TiposCompraWhereUniqueInput
    update?: XOR<XOR<TiposCompraUpdateToOneWithWhereWithoutComprasInput, TiposCompraUpdateWithoutComprasInput>, TiposCompraUncheckedUpdateWithoutComprasInput>
  }

  export type ProveedoresUpdateOneRequiredWithoutComprasNestedInput = {
    create?: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
    connectOrCreate?: ProveedoresCreateOrConnectWithoutComprasInput
    upsert?: ProveedoresUpsertWithoutComprasInput
    connect?: ProveedoresWhereUniqueInput
    update?: XOR<XOR<ProveedoresUpdateToOneWithWhereWithoutComprasInput, ProveedoresUpdateWithoutComprasInput>, ProveedoresUncheckedUpdateWithoutComprasInput>
  }

  export type ProductosUpdateOneWithoutComprasNestedInput = {
    create?: XOR<ProductosCreateWithoutComprasInput, ProductosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutComprasInput
    upsert?: ProductosUpsertWithoutComprasInput
    disconnect?: ProductosWhereInput | boolean
    delete?: ProductosWhereInput | boolean
    connect?: ProductosWhereUniqueInput
    update?: XOR<XOR<ProductosUpdateToOneWithWhereWithoutComprasInput, ProductosUpdateWithoutComprasInput>, ProductosUncheckedUpdateWithoutComprasInput>
  }

  export type InsumosUpdateOneWithoutComprasNestedInput = {
    create?: XOR<InsumosCreateWithoutComprasInput, InsumosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: InsumosCreateOrConnectWithoutComprasInput
    upsert?: InsumosUpsertWithoutComprasInput
    disconnect?: InsumosWhereInput | boolean
    delete?: InsumosWhereInput | boolean
    connect?: InsumosWhereUniqueInput
    update?: XOR<XOR<InsumosUpdateToOneWithWhereWithoutComprasInput, InsumosUpdateWithoutComprasInput>, InsumosUncheckedUpdateWithoutComprasInput>
  }

  export type InventarioUpdateManyWithoutComprasNestedInput = {
    create?: XOR<InventarioCreateWithoutComprasInput, InventarioUncheckedCreateWithoutComprasInput> | InventarioCreateWithoutComprasInput[] | InventarioUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutComprasInput | InventarioCreateOrConnectWithoutComprasInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutComprasInput | InventarioUpsertWithWhereUniqueWithoutComprasInput[]
    createMany?: InventarioCreateManyComprasInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutComprasInput | InventarioUpdateWithWhereUniqueWithoutComprasInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutComprasInput | InventarioUpdateManyWithWhereWithoutComprasInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutComprasNestedInput = {
    create?: XOR<InventarioCreateWithoutComprasInput, InventarioUncheckedCreateWithoutComprasInput> | InventarioCreateWithoutComprasInput[] | InventarioUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutComprasInput | InventarioCreateOrConnectWithoutComprasInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutComprasInput | InventarioUpsertWithWhereUniqueWithoutComprasInput[]
    createMany?: InventarioCreateManyComprasInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutComprasInput | InventarioUpdateWithWhereUniqueWithoutComprasInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutComprasInput | InventarioUpdateManyWithWhereWithoutComprasInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type ProductosCreateNestedOneWithoutImagenesProductosInput = {
    create?: XOR<ProductosCreateWithoutImagenesProductosInput, ProductosUncheckedCreateWithoutImagenesProductosInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutImagenesProductosInput
    connect?: ProductosWhereUniqueInput
  }

  export type ProductosUpdateOneRequiredWithoutImagenesProductosNestedInput = {
    create?: XOR<ProductosCreateWithoutImagenesProductosInput, ProductosUncheckedCreateWithoutImagenesProductosInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutImagenesProductosInput
    upsert?: ProductosUpsertWithoutImagenesProductosInput
    connect?: ProductosWhereUniqueInput
    update?: XOR<XOR<ProductosUpdateToOneWithWhereWithoutImagenesProductosInput, ProductosUpdateWithoutImagenesProductosInput>, ProductosUncheckedUpdateWithoutImagenesProductosInput>
  }

  export type ComprasCreateNestedManyWithoutInsumosInput = {
    create?: XOR<ComprasCreateWithoutInsumosInput, ComprasUncheckedCreateWithoutInsumosInput> | ComprasCreateWithoutInsumosInput[] | ComprasUncheckedCreateWithoutInsumosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutInsumosInput | ComprasCreateOrConnectWithoutInsumosInput[]
    createMany?: ComprasCreateManyInsumosInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ComprasUncheckedCreateNestedManyWithoutInsumosInput = {
    create?: XOR<ComprasCreateWithoutInsumosInput, ComprasUncheckedCreateWithoutInsumosInput> | ComprasCreateWithoutInsumosInput[] | ComprasUncheckedCreateWithoutInsumosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutInsumosInput | ComprasCreateOrConnectWithoutInsumosInput[]
    createMany?: ComprasCreateManyInsumosInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ComprasUpdateManyWithoutInsumosNestedInput = {
    create?: XOR<ComprasCreateWithoutInsumosInput, ComprasUncheckedCreateWithoutInsumosInput> | ComprasCreateWithoutInsumosInput[] | ComprasUncheckedCreateWithoutInsumosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutInsumosInput | ComprasCreateOrConnectWithoutInsumosInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutInsumosInput | ComprasUpsertWithWhereUniqueWithoutInsumosInput[]
    createMany?: ComprasCreateManyInsumosInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutInsumosInput | ComprasUpdateWithWhereUniqueWithoutInsumosInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutInsumosInput | ComprasUpdateManyWithWhereWithoutInsumosInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type ComprasUncheckedUpdateManyWithoutInsumosNestedInput = {
    create?: XOR<ComprasCreateWithoutInsumosInput, ComprasUncheckedCreateWithoutInsumosInput> | ComprasCreateWithoutInsumosInput[] | ComprasUncheckedCreateWithoutInsumosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutInsumosInput | ComprasCreateOrConnectWithoutInsumosInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutInsumosInput | ComprasUpsertWithWhereUniqueWithoutInsumosInput[]
    createMany?: ComprasCreateManyInsumosInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutInsumosInput | ComprasUpdateWithWhereUniqueWithoutInsumosInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutInsumosInput | ComprasUpdateManyWithWhereWithoutInsumosInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type ComprasCreateNestedOneWithoutInventarioInput = {
    create?: XOR<ComprasCreateWithoutInventarioInput, ComprasUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: ComprasCreateOrConnectWithoutInventarioInput
    connect?: ComprasWhereUniqueInput
  }

  export type ProductosCreateNestedOneWithoutInventarioInput = {
    create?: XOR<ProductosCreateWithoutInventarioInput, ProductosUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutInventarioInput
    connect?: ProductosWhereUniqueInput
  }

  export type AlmacenesCreateNestedOneWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    create?: XOR<AlmacenesCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>
    connectOrCreate?: AlmacenesCreateOrConnectWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    connect?: AlmacenesWhereUniqueInput
  }

  export type AlmacenesCreateNestedOneWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    create?: XOR<AlmacenesCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
    connectOrCreate?: AlmacenesCreateOrConnectWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    connect?: AlmacenesWhereUniqueInput
  }

  export type AlmacenesCreateNestedOneWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    create?: XOR<AlmacenesCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
    connectOrCreate?: AlmacenesCreateOrConnectWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    connect?: AlmacenesWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutInventarioInput = {
    create?: XOR<UsuariosCreateWithoutInventarioInput, UsuariosUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutInventarioInput
    connect?: UsuariosWhereUniqueInput
  }

  export type ComprasUpdateOneRequiredWithoutInventarioNestedInput = {
    create?: XOR<ComprasCreateWithoutInventarioInput, ComprasUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: ComprasCreateOrConnectWithoutInventarioInput
    upsert?: ComprasUpsertWithoutInventarioInput
    connect?: ComprasWhereUniqueInput
    update?: XOR<XOR<ComprasUpdateToOneWithWhereWithoutInventarioInput, ComprasUpdateWithoutInventarioInput>, ComprasUncheckedUpdateWithoutInventarioInput>
  }

  export type ProductosUpdateOneRequiredWithoutInventarioNestedInput = {
    create?: XOR<ProductosCreateWithoutInventarioInput, ProductosUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutInventarioInput
    upsert?: ProductosUpsertWithoutInventarioInput
    connect?: ProductosWhereUniqueInput
    update?: XOR<XOR<ProductosUpdateToOneWithWhereWithoutInventarioInput, ProductosUpdateWithoutInventarioInput>, ProductosUncheckedUpdateWithoutInventarioInput>
  }

  export type AlmacenesUpdateOneRequiredWithoutInventario_Inventario_AlmacenActualIdToAlmacenesNestedInput = {
    create?: XOR<AlmacenesCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>
    connectOrCreate?: AlmacenesCreateOrConnectWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    upsert?: AlmacenesUpsertWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    connect?: AlmacenesWhereUniqueInput
    update?: XOR<XOR<AlmacenesUpdateToOneWithWhereWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput, AlmacenesUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>, AlmacenesUncheckedUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>
  }

  export type AlmacenesUpdateOneRequiredWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput = {
    create?: XOR<AlmacenesCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
    connectOrCreate?: AlmacenesCreateOrConnectWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    upsert?: AlmacenesUpsertWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    connect?: AlmacenesWhereUniqueInput
    update?: XOR<XOR<AlmacenesUpdateToOneWithWhereWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, AlmacenesUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>, AlmacenesUncheckedUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
  }

  export type AlmacenesUpdateOneRequiredWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput = {
    create?: XOR<AlmacenesCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
    connectOrCreate?: AlmacenesCreateOrConnectWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    upsert?: AlmacenesUpsertWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    connect?: AlmacenesWhereUniqueInput
    update?: XOR<XOR<AlmacenesUpdateToOneWithWhereWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, AlmacenesUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>, AlmacenesUncheckedUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
  }

  export type UsuariosUpdateOneRequiredWithoutInventarioNestedInput = {
    create?: XOR<UsuariosCreateWithoutInventarioInput, UsuariosUncheckedCreateWithoutInventarioInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutInventarioInput
    upsert?: UsuariosUpsertWithoutInventarioInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutInventarioInput, UsuariosUpdateWithoutInventarioInput>, UsuariosUncheckedUpdateWithoutInventarioInput>
  }

  export type ProductosCreateNestedOneWithoutListasPreciosInput = {
    create?: XOR<ProductosCreateWithoutListasPreciosInput, ProductosUncheckedCreateWithoutListasPreciosInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutListasPreciosInput
    connect?: ProductosWhereUniqueInput
  }

  export type UnidadesMedidaCreateNestedOneWithoutListasPreciosInput = {
    create?: XOR<UnidadesMedidaCreateWithoutListasPreciosInput, UnidadesMedidaUncheckedCreateWithoutListasPreciosInput>
    connectOrCreate?: UnidadesMedidaCreateOrConnectWithoutListasPreciosInput
    connect?: UnidadesMedidaWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductosUpdateOneRequiredWithoutListasPreciosNestedInput = {
    create?: XOR<ProductosCreateWithoutListasPreciosInput, ProductosUncheckedCreateWithoutListasPreciosInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutListasPreciosInput
    upsert?: ProductosUpsertWithoutListasPreciosInput
    connect?: ProductosWhereUniqueInput
    update?: XOR<XOR<ProductosUpdateToOneWithWhereWithoutListasPreciosInput, ProductosUpdateWithoutListasPreciosInput>, ProductosUncheckedUpdateWithoutListasPreciosInput>
  }

  export type UnidadesMedidaUpdateOneRequiredWithoutListasPreciosNestedInput = {
    create?: XOR<UnidadesMedidaCreateWithoutListasPreciosInput, UnidadesMedidaUncheckedCreateWithoutListasPreciosInput>
    connectOrCreate?: UnidadesMedidaCreateOrConnectWithoutListasPreciosInput
    upsert?: UnidadesMedidaUpsertWithoutListasPreciosInput
    connect?: UnidadesMedidaWhereUniqueInput
    update?: XOR<XOR<UnidadesMedidaUpdateToOneWithWhereWithoutListasPreciosInput, UnidadesMedidaUpdateWithoutListasPreciosInput>, UnidadesMedidaUncheckedUpdateWithoutListasPreciosInput>
  }

  export type VentasCreateNestedManyWithoutMetodosPagoInput = {
    create?: XOR<VentasCreateWithoutMetodosPagoInput, VentasUncheckedCreateWithoutMetodosPagoInput> | VentasCreateWithoutMetodosPagoInput[] | VentasUncheckedCreateWithoutMetodosPagoInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutMetodosPagoInput | VentasCreateOrConnectWithoutMetodosPagoInput[]
    createMany?: VentasCreateManyMetodosPagoInputEnvelope
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
  }

  export type VentasUncheckedCreateNestedManyWithoutMetodosPagoInput = {
    create?: XOR<VentasCreateWithoutMetodosPagoInput, VentasUncheckedCreateWithoutMetodosPagoInput> | VentasCreateWithoutMetodosPagoInput[] | VentasUncheckedCreateWithoutMetodosPagoInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutMetodosPagoInput | VentasCreateOrConnectWithoutMetodosPagoInput[]
    createMany?: VentasCreateManyMetodosPagoInputEnvelope
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
  }

  export type VentasUpdateManyWithoutMetodosPagoNestedInput = {
    create?: XOR<VentasCreateWithoutMetodosPagoInput, VentasUncheckedCreateWithoutMetodosPagoInput> | VentasCreateWithoutMetodosPagoInput[] | VentasUncheckedCreateWithoutMetodosPagoInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutMetodosPagoInput | VentasCreateOrConnectWithoutMetodosPagoInput[]
    upsert?: VentasUpsertWithWhereUniqueWithoutMetodosPagoInput | VentasUpsertWithWhereUniqueWithoutMetodosPagoInput[]
    createMany?: VentasCreateManyMetodosPagoInputEnvelope
    set?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    disconnect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    delete?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    update?: VentasUpdateWithWhereUniqueWithoutMetodosPagoInput | VentasUpdateWithWhereUniqueWithoutMetodosPagoInput[]
    updateMany?: VentasUpdateManyWithWhereWithoutMetodosPagoInput | VentasUpdateManyWithWhereWithoutMetodosPagoInput[]
    deleteMany?: VentasScalarWhereInput | VentasScalarWhereInput[]
  }

  export type VentasUncheckedUpdateManyWithoutMetodosPagoNestedInput = {
    create?: XOR<VentasCreateWithoutMetodosPagoInput, VentasUncheckedCreateWithoutMetodosPagoInput> | VentasCreateWithoutMetodosPagoInput[] | VentasUncheckedCreateWithoutMetodosPagoInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutMetodosPagoInput | VentasCreateOrConnectWithoutMetodosPagoInput[]
    upsert?: VentasUpsertWithWhereUniqueWithoutMetodosPagoInput | VentasUpsertWithWhereUniqueWithoutMetodosPagoInput[]
    createMany?: VentasCreateManyMetodosPagoInputEnvelope
    set?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    disconnect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    delete?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    update?: VentasUpdateWithWhereUniqueWithoutMetodosPagoInput | VentasUpdateWithWhereUniqueWithoutMetodosPagoInput[]
    updateMany?: VentasUpdateManyWithWhereWithoutMetodosPagoInput | VentasUpdateManyWithWhereWithoutMetodosPagoInput[]
    deleteMany?: VentasScalarWhereInput | VentasScalarWhereInput[]
  }

  export type ComprasCreateNestedManyWithoutProductosInput = {
    create?: XOR<ComprasCreateWithoutProductosInput, ComprasUncheckedCreateWithoutProductosInput> | ComprasCreateWithoutProductosInput[] | ComprasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProductosInput | ComprasCreateOrConnectWithoutProductosInput[]
    createMany?: ComprasCreateManyProductosInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ImagenesProductosCreateNestedManyWithoutProductosInput = {
    create?: XOR<ImagenesProductosCreateWithoutProductosInput, ImagenesProductosUncheckedCreateWithoutProductosInput> | ImagenesProductosCreateWithoutProductosInput[] | ImagenesProductosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ImagenesProductosCreateOrConnectWithoutProductosInput | ImagenesProductosCreateOrConnectWithoutProductosInput[]
    createMany?: ImagenesProductosCreateManyProductosInputEnvelope
    connect?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutProductosInput = {
    create?: XOR<InventarioCreateWithoutProductosInput, InventarioUncheckedCreateWithoutProductosInput> | InventarioCreateWithoutProductosInput[] | InventarioUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductosInput | InventarioCreateOrConnectWithoutProductosInput[]
    createMany?: InventarioCreateManyProductosInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type ListasPreciosCreateNestedManyWithoutProductosInput = {
    create?: XOR<ListasPreciosCreateWithoutProductosInput, ListasPreciosUncheckedCreateWithoutProductosInput> | ListasPreciosCreateWithoutProductosInput[] | ListasPreciosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutProductosInput | ListasPreciosCreateOrConnectWithoutProductosInput[]
    createMany?: ListasPreciosCreateManyProductosInputEnvelope
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
  }

  export type CategoriasProductoCreateNestedOneWithoutProductosInput = {
    create?: XOR<CategoriasProductoCreateWithoutProductosInput, CategoriasProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: CategoriasProductoCreateOrConnectWithoutProductosInput
    connect?: CategoriasProductoWhereUniqueInput
  }

  export type VentasCreateNestedManyWithoutProductosInput = {
    create?: XOR<VentasCreateWithoutProductosInput, VentasUncheckedCreateWithoutProductosInput> | VentasCreateWithoutProductosInput[] | VentasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutProductosInput | VentasCreateOrConnectWithoutProductosInput[]
    createMany?: VentasCreateManyProductosInputEnvelope
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
  }

  export type ComprasUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<ComprasCreateWithoutProductosInput, ComprasUncheckedCreateWithoutProductosInput> | ComprasCreateWithoutProductosInput[] | ComprasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProductosInput | ComprasCreateOrConnectWithoutProductosInput[]
    createMany?: ComprasCreateManyProductosInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ImagenesProductosUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<ImagenesProductosCreateWithoutProductosInput, ImagenesProductosUncheckedCreateWithoutProductosInput> | ImagenesProductosCreateWithoutProductosInput[] | ImagenesProductosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ImagenesProductosCreateOrConnectWithoutProductosInput | ImagenesProductosCreateOrConnectWithoutProductosInput[]
    createMany?: ImagenesProductosCreateManyProductosInputEnvelope
    connect?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<InventarioCreateWithoutProductosInput, InventarioUncheckedCreateWithoutProductosInput> | InventarioCreateWithoutProductosInput[] | InventarioUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductosInput | InventarioCreateOrConnectWithoutProductosInput[]
    createMany?: InventarioCreateManyProductosInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type ListasPreciosUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<ListasPreciosCreateWithoutProductosInput, ListasPreciosUncheckedCreateWithoutProductosInput> | ListasPreciosCreateWithoutProductosInput[] | ListasPreciosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutProductosInput | ListasPreciosCreateOrConnectWithoutProductosInput[]
    createMany?: ListasPreciosCreateManyProductosInputEnvelope
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
  }

  export type VentasUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<VentasCreateWithoutProductosInput, VentasUncheckedCreateWithoutProductosInput> | VentasCreateWithoutProductosInput[] | VentasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutProductosInput | VentasCreateOrConnectWithoutProductosInput[]
    createMany?: VentasCreateManyProductosInputEnvelope
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
  }

  export type ComprasUpdateManyWithoutProductosNestedInput = {
    create?: XOR<ComprasCreateWithoutProductosInput, ComprasUncheckedCreateWithoutProductosInput> | ComprasCreateWithoutProductosInput[] | ComprasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProductosInput | ComprasCreateOrConnectWithoutProductosInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutProductosInput | ComprasUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: ComprasCreateManyProductosInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutProductosInput | ComprasUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutProductosInput | ComprasUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type ImagenesProductosUpdateManyWithoutProductosNestedInput = {
    create?: XOR<ImagenesProductosCreateWithoutProductosInput, ImagenesProductosUncheckedCreateWithoutProductosInput> | ImagenesProductosCreateWithoutProductosInput[] | ImagenesProductosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ImagenesProductosCreateOrConnectWithoutProductosInput | ImagenesProductosCreateOrConnectWithoutProductosInput[]
    upsert?: ImagenesProductosUpsertWithWhereUniqueWithoutProductosInput | ImagenesProductosUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: ImagenesProductosCreateManyProductosInputEnvelope
    set?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    disconnect?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    delete?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    connect?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    update?: ImagenesProductosUpdateWithWhereUniqueWithoutProductosInput | ImagenesProductosUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: ImagenesProductosUpdateManyWithWhereWithoutProductosInput | ImagenesProductosUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: ImagenesProductosScalarWhereInput | ImagenesProductosScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutProductosNestedInput = {
    create?: XOR<InventarioCreateWithoutProductosInput, InventarioUncheckedCreateWithoutProductosInput> | InventarioCreateWithoutProductosInput[] | InventarioUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductosInput | InventarioCreateOrConnectWithoutProductosInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutProductosInput | InventarioUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: InventarioCreateManyProductosInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutProductosInput | InventarioUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutProductosInput | InventarioUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type ListasPreciosUpdateManyWithoutProductosNestedInput = {
    create?: XOR<ListasPreciosCreateWithoutProductosInput, ListasPreciosUncheckedCreateWithoutProductosInput> | ListasPreciosCreateWithoutProductosInput[] | ListasPreciosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutProductosInput | ListasPreciosCreateOrConnectWithoutProductosInput[]
    upsert?: ListasPreciosUpsertWithWhereUniqueWithoutProductosInput | ListasPreciosUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: ListasPreciosCreateManyProductosInputEnvelope
    set?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    disconnect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    delete?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    update?: ListasPreciosUpdateWithWhereUniqueWithoutProductosInput | ListasPreciosUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: ListasPreciosUpdateManyWithWhereWithoutProductosInput | ListasPreciosUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: ListasPreciosScalarWhereInput | ListasPreciosScalarWhereInput[]
  }

  export type CategoriasProductoUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<CategoriasProductoCreateWithoutProductosInput, CategoriasProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: CategoriasProductoCreateOrConnectWithoutProductosInput
    upsert?: CategoriasProductoUpsertWithoutProductosInput
    connect?: CategoriasProductoWhereUniqueInput
    update?: XOR<XOR<CategoriasProductoUpdateToOneWithWhereWithoutProductosInput, CategoriasProductoUpdateWithoutProductosInput>, CategoriasProductoUncheckedUpdateWithoutProductosInput>
  }

  export type VentasUpdateManyWithoutProductosNestedInput = {
    create?: XOR<VentasCreateWithoutProductosInput, VentasUncheckedCreateWithoutProductosInput> | VentasCreateWithoutProductosInput[] | VentasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutProductosInput | VentasCreateOrConnectWithoutProductosInput[]
    upsert?: VentasUpsertWithWhereUniqueWithoutProductosInput | VentasUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: VentasCreateManyProductosInputEnvelope
    set?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    disconnect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    delete?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    update?: VentasUpdateWithWhereUniqueWithoutProductosInput | VentasUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: VentasUpdateManyWithWhereWithoutProductosInput | VentasUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: VentasScalarWhereInput | VentasScalarWhereInput[]
  }

  export type ComprasUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<ComprasCreateWithoutProductosInput, ComprasUncheckedCreateWithoutProductosInput> | ComprasCreateWithoutProductosInput[] | ComprasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProductosInput | ComprasCreateOrConnectWithoutProductosInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutProductosInput | ComprasUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: ComprasCreateManyProductosInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutProductosInput | ComprasUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutProductosInput | ComprasUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type ImagenesProductosUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<ImagenesProductosCreateWithoutProductosInput, ImagenesProductosUncheckedCreateWithoutProductosInput> | ImagenesProductosCreateWithoutProductosInput[] | ImagenesProductosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ImagenesProductosCreateOrConnectWithoutProductosInput | ImagenesProductosCreateOrConnectWithoutProductosInput[]
    upsert?: ImagenesProductosUpsertWithWhereUniqueWithoutProductosInput | ImagenesProductosUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: ImagenesProductosCreateManyProductosInputEnvelope
    set?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    disconnect?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    delete?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    connect?: ImagenesProductosWhereUniqueInput | ImagenesProductosWhereUniqueInput[]
    update?: ImagenesProductosUpdateWithWhereUniqueWithoutProductosInput | ImagenesProductosUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: ImagenesProductosUpdateManyWithWhereWithoutProductosInput | ImagenesProductosUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: ImagenesProductosScalarWhereInput | ImagenesProductosScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<InventarioCreateWithoutProductosInput, InventarioUncheckedCreateWithoutProductosInput> | InventarioCreateWithoutProductosInput[] | InventarioUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutProductosInput | InventarioCreateOrConnectWithoutProductosInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutProductosInput | InventarioUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: InventarioCreateManyProductosInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutProductosInput | InventarioUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutProductosInput | InventarioUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type ListasPreciosUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<ListasPreciosCreateWithoutProductosInput, ListasPreciosUncheckedCreateWithoutProductosInput> | ListasPreciosCreateWithoutProductosInput[] | ListasPreciosUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutProductosInput | ListasPreciosCreateOrConnectWithoutProductosInput[]
    upsert?: ListasPreciosUpsertWithWhereUniqueWithoutProductosInput | ListasPreciosUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: ListasPreciosCreateManyProductosInputEnvelope
    set?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    disconnect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    delete?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    update?: ListasPreciosUpdateWithWhereUniqueWithoutProductosInput | ListasPreciosUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: ListasPreciosUpdateManyWithWhereWithoutProductosInput | ListasPreciosUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: ListasPreciosScalarWhereInput | ListasPreciosScalarWhereInput[]
  }

  export type VentasUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<VentasCreateWithoutProductosInput, VentasUncheckedCreateWithoutProductosInput> | VentasCreateWithoutProductosInput[] | VentasUncheckedCreateWithoutProductosInput[]
    connectOrCreate?: VentasCreateOrConnectWithoutProductosInput | VentasCreateOrConnectWithoutProductosInput[]
    upsert?: VentasUpsertWithWhereUniqueWithoutProductosInput | VentasUpsertWithWhereUniqueWithoutProductosInput[]
    createMany?: VentasCreateManyProductosInputEnvelope
    set?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    disconnect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    delete?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    connect?: VentasWhereUniqueInput | VentasWhereUniqueInput[]
    update?: VentasUpdateWithWhereUniqueWithoutProductosInput | VentasUpdateWithWhereUniqueWithoutProductosInput[]
    updateMany?: VentasUpdateManyWithWhereWithoutProductosInput | VentasUpdateManyWithWhereWithoutProductosInput[]
    deleteMany?: VentasScalarWhereInput | VentasScalarWhereInput[]
  }

  export type ComprasCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput> | ComprasCreateWithoutProveedoresInput[] | ComprasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProveedoresInput | ComprasCreateOrConnectWithoutProveedoresInput[]
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ComprasUncheckedCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput> | ComprasCreateWithoutProveedoresInput[] | ComprasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProveedoresInput | ComprasCreateOrConnectWithoutProveedoresInput[]
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ComprasUpdateManyWithoutProveedoresNestedInput = {
    create?: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput> | ComprasCreateWithoutProveedoresInput[] | ComprasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProveedoresInput | ComprasCreateOrConnectWithoutProveedoresInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutProveedoresInput | ComprasUpsertWithWhereUniqueWithoutProveedoresInput[]
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutProveedoresInput | ComprasUpdateWithWhereUniqueWithoutProveedoresInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutProveedoresInput | ComprasUpdateManyWithWhereWithoutProveedoresInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type ComprasUncheckedUpdateManyWithoutProveedoresNestedInput = {
    create?: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput> | ComprasCreateWithoutProveedoresInput[] | ComprasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutProveedoresInput | ComprasCreateOrConnectWithoutProveedoresInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutProveedoresInput | ComprasUpsertWithWhereUniqueWithoutProveedoresInput[]
    createMany?: ComprasCreateManyProveedoresInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutProveedoresInput | ComprasUpdateWithWhereUniqueWithoutProveedoresInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutProveedoresInput | ComprasUpdateManyWithWhereWithoutProveedoresInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type UsuariosCreateNestedManyWithoutRolesUSuarioInput = {
    create?: XOR<UsuariosCreateWithoutRolesUSuarioInput, UsuariosUncheckedCreateWithoutRolesUSuarioInput> | UsuariosCreateWithoutRolesUSuarioInput[] | UsuariosUncheckedCreateWithoutRolesUSuarioInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesUSuarioInput | UsuariosCreateOrConnectWithoutRolesUSuarioInput[]
    createMany?: UsuariosCreateManyRolesUSuarioInputEnvelope
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
  }

  export type UsuariosUncheckedCreateNestedManyWithoutRolesUSuarioInput = {
    create?: XOR<UsuariosCreateWithoutRolesUSuarioInput, UsuariosUncheckedCreateWithoutRolesUSuarioInput> | UsuariosCreateWithoutRolesUSuarioInput[] | UsuariosUncheckedCreateWithoutRolesUSuarioInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesUSuarioInput | UsuariosCreateOrConnectWithoutRolesUSuarioInput[]
    createMany?: UsuariosCreateManyRolesUSuarioInputEnvelope
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
  }

  export type UsuariosUpdateManyWithoutRolesUSuarioNestedInput = {
    create?: XOR<UsuariosCreateWithoutRolesUSuarioInput, UsuariosUncheckedCreateWithoutRolesUSuarioInput> | UsuariosCreateWithoutRolesUSuarioInput[] | UsuariosUncheckedCreateWithoutRolesUSuarioInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesUSuarioInput | UsuariosCreateOrConnectWithoutRolesUSuarioInput[]
    upsert?: UsuariosUpsertWithWhereUniqueWithoutRolesUSuarioInput | UsuariosUpsertWithWhereUniqueWithoutRolesUSuarioInput[]
    createMany?: UsuariosCreateManyRolesUSuarioInputEnvelope
    set?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    disconnect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    delete?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    update?: UsuariosUpdateWithWhereUniqueWithoutRolesUSuarioInput | UsuariosUpdateWithWhereUniqueWithoutRolesUSuarioInput[]
    updateMany?: UsuariosUpdateManyWithWhereWithoutRolesUSuarioInput | UsuariosUpdateManyWithWhereWithoutRolesUSuarioInput[]
    deleteMany?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
  }

  export type UsuariosUncheckedUpdateManyWithoutRolesUSuarioNestedInput = {
    create?: XOR<UsuariosCreateWithoutRolesUSuarioInput, UsuariosUncheckedCreateWithoutRolesUSuarioInput> | UsuariosCreateWithoutRolesUSuarioInput[] | UsuariosUncheckedCreateWithoutRolesUSuarioInput[]
    connectOrCreate?: UsuariosCreateOrConnectWithoutRolesUSuarioInput | UsuariosCreateOrConnectWithoutRolesUSuarioInput[]
    upsert?: UsuariosUpsertWithWhereUniqueWithoutRolesUSuarioInput | UsuariosUpsertWithWhereUniqueWithoutRolesUSuarioInput[]
    createMany?: UsuariosCreateManyRolesUSuarioInputEnvelope
    set?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    disconnect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    delete?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    connect?: UsuariosWhereUniqueInput | UsuariosWhereUniqueInput[]
    update?: UsuariosUpdateWithWhereUniqueWithoutRolesUSuarioInput | UsuariosUpdateWithWhereUniqueWithoutRolesUSuarioInput[]
    updateMany?: UsuariosUpdateManyWithWhereWithoutRolesUSuarioInput | UsuariosUpdateManyWithWhereWithoutRolesUSuarioInput[]
    deleteMany?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
  }

  export type ComprasCreateNestedManyWithoutTiposCompraInput = {
    create?: XOR<ComprasCreateWithoutTiposCompraInput, ComprasUncheckedCreateWithoutTiposCompraInput> | ComprasCreateWithoutTiposCompraInput[] | ComprasUncheckedCreateWithoutTiposCompraInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutTiposCompraInput | ComprasCreateOrConnectWithoutTiposCompraInput[]
    createMany?: ComprasCreateManyTiposCompraInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ComprasUncheckedCreateNestedManyWithoutTiposCompraInput = {
    create?: XOR<ComprasCreateWithoutTiposCompraInput, ComprasUncheckedCreateWithoutTiposCompraInput> | ComprasCreateWithoutTiposCompraInput[] | ComprasUncheckedCreateWithoutTiposCompraInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutTiposCompraInput | ComprasCreateOrConnectWithoutTiposCompraInput[]
    createMany?: ComprasCreateManyTiposCompraInputEnvelope
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
  }

  export type ComprasUpdateManyWithoutTiposCompraNestedInput = {
    create?: XOR<ComprasCreateWithoutTiposCompraInput, ComprasUncheckedCreateWithoutTiposCompraInput> | ComprasCreateWithoutTiposCompraInput[] | ComprasUncheckedCreateWithoutTiposCompraInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutTiposCompraInput | ComprasCreateOrConnectWithoutTiposCompraInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutTiposCompraInput | ComprasUpsertWithWhereUniqueWithoutTiposCompraInput[]
    createMany?: ComprasCreateManyTiposCompraInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutTiposCompraInput | ComprasUpdateWithWhereUniqueWithoutTiposCompraInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutTiposCompraInput | ComprasUpdateManyWithWhereWithoutTiposCompraInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type ComprasUncheckedUpdateManyWithoutTiposCompraNestedInput = {
    create?: XOR<ComprasCreateWithoutTiposCompraInput, ComprasUncheckedCreateWithoutTiposCompraInput> | ComprasCreateWithoutTiposCompraInput[] | ComprasUncheckedCreateWithoutTiposCompraInput[]
    connectOrCreate?: ComprasCreateOrConnectWithoutTiposCompraInput | ComprasCreateOrConnectWithoutTiposCompraInput[]
    upsert?: ComprasUpsertWithWhereUniqueWithoutTiposCompraInput | ComprasUpsertWithWhereUniqueWithoutTiposCompraInput[]
    createMany?: ComprasCreateManyTiposCompraInputEnvelope
    set?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    disconnect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    delete?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    connect?: ComprasWhereUniqueInput | ComprasWhereUniqueInput[]
    update?: ComprasUpdateWithWhereUniqueWithoutTiposCompraInput | ComprasUpdateWithWhereUniqueWithoutTiposCompraInput[]
    updateMany?: ComprasUpdateManyWithWhereWithoutTiposCompraInput | ComprasUpdateManyWithWhereWithoutTiposCompraInput[]
    deleteMany?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
  }

  export type ListasPreciosCreateNestedManyWithoutUnidadesMedidaInput = {
    create?: XOR<ListasPreciosCreateWithoutUnidadesMedidaInput, ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput> | ListasPreciosCreateWithoutUnidadesMedidaInput[] | ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput | ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput[]
    createMany?: ListasPreciosCreateManyUnidadesMedidaInputEnvelope
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
  }

  export type ListasPreciosUncheckedCreateNestedManyWithoutUnidadesMedidaInput = {
    create?: XOR<ListasPreciosCreateWithoutUnidadesMedidaInput, ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput> | ListasPreciosCreateWithoutUnidadesMedidaInput[] | ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput | ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput[]
    createMany?: ListasPreciosCreateManyUnidadesMedidaInputEnvelope
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
  }

  export type ListasPreciosUpdateManyWithoutUnidadesMedidaNestedInput = {
    create?: XOR<ListasPreciosCreateWithoutUnidadesMedidaInput, ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput> | ListasPreciosCreateWithoutUnidadesMedidaInput[] | ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput | ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput[]
    upsert?: ListasPreciosUpsertWithWhereUniqueWithoutUnidadesMedidaInput | ListasPreciosUpsertWithWhereUniqueWithoutUnidadesMedidaInput[]
    createMany?: ListasPreciosCreateManyUnidadesMedidaInputEnvelope
    set?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    disconnect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    delete?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    update?: ListasPreciosUpdateWithWhereUniqueWithoutUnidadesMedidaInput | ListasPreciosUpdateWithWhereUniqueWithoutUnidadesMedidaInput[]
    updateMany?: ListasPreciosUpdateManyWithWhereWithoutUnidadesMedidaInput | ListasPreciosUpdateManyWithWhereWithoutUnidadesMedidaInput[]
    deleteMany?: ListasPreciosScalarWhereInput | ListasPreciosScalarWhereInput[]
  }

  export type ListasPreciosUncheckedUpdateManyWithoutUnidadesMedidaNestedInput = {
    create?: XOR<ListasPreciosCreateWithoutUnidadesMedidaInput, ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput> | ListasPreciosCreateWithoutUnidadesMedidaInput[] | ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput[]
    connectOrCreate?: ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput | ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput[]
    upsert?: ListasPreciosUpsertWithWhereUniqueWithoutUnidadesMedidaInput | ListasPreciosUpsertWithWhereUniqueWithoutUnidadesMedidaInput[]
    createMany?: ListasPreciosCreateManyUnidadesMedidaInputEnvelope
    set?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    disconnect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    delete?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    connect?: ListasPreciosWhereUniqueInput | ListasPreciosWhereUniqueInput[]
    update?: ListasPreciosUpdateWithWhereUniqueWithoutUnidadesMedidaInput | ListasPreciosUpdateWithWhereUniqueWithoutUnidadesMedidaInput[]
    updateMany?: ListasPreciosUpdateManyWithWhereWithoutUnidadesMedidaInput | ListasPreciosUpdateManyWithWhereWithoutUnidadesMedidaInput[]
    deleteMany?: ListasPreciosScalarWhereInput | ListasPreciosScalarWhereInput[]
  }

  export type AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInputEnvelope
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
  }

  export type AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInputEnvelope
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
  }

  export type InventarioCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<InventarioCreateWithoutUsuariosInput, InventarioUncheckedCreateWithoutUsuariosInput> | InventarioCreateWithoutUsuariosInput[] | InventarioUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuariosInput | InventarioCreateOrConnectWithoutUsuariosInput[]
    createMany?: InventarioCreateManyUsuariosInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type RolesUSuarioCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<RolesUSuarioCreateWithoutUsuariosInput, RolesUSuarioUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolesUSuarioCreateOrConnectWithoutUsuariosInput
    connect?: RolesUSuarioWhereUniqueInput
  }

  export type AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInputEnvelope
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
  }

  export type AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInputEnvelope
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
  }

  export type InventarioUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<InventarioCreateWithoutUsuariosInput, InventarioUncheckedCreateWithoutUsuariosInput> | InventarioCreateWithoutUsuariosInput[] | InventarioUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuariosInput | InventarioCreateOrConnectWithoutUsuariosInput[]
    createMany?: InventarioCreateManyUsuariosInputEnvelope
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
  }

  export type AlmacenesUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    upsert?: AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInputEnvelope
    set?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    disconnect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    delete?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    update?: AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    updateMany?: AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    deleteMany?: AlmacenesScalarWhereInput | AlmacenesScalarWhereInput[]
  }

  export type AlmacenesUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    upsert?: AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInputEnvelope
    set?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    disconnect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    delete?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    update?: AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    updateMany?: AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    deleteMany?: AlmacenesScalarWhereInput | AlmacenesScalarWhereInput[]
  }

  export type InventarioUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<InventarioCreateWithoutUsuariosInput, InventarioUncheckedCreateWithoutUsuariosInput> | InventarioCreateWithoutUsuariosInput[] | InventarioUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuariosInput | InventarioCreateOrConnectWithoutUsuariosInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutUsuariosInput | InventarioUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: InventarioCreateManyUsuariosInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutUsuariosInput | InventarioUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutUsuariosInput | InventarioUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type RolesUSuarioUpdateOneWithoutUsuariosNestedInput = {
    create?: XOR<RolesUSuarioCreateWithoutUsuariosInput, RolesUSuarioUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolesUSuarioCreateOrConnectWithoutUsuariosInput
    upsert?: RolesUSuarioUpsertWithoutUsuariosInput
    disconnect?: RolesUSuarioWhereInput | boolean
    delete?: RolesUSuarioWhereInput | boolean
    connect?: RolesUSuarioWhereUniqueInput
    update?: XOR<XOR<RolesUSuarioUpdateToOneWithWhereWithoutUsuariosInput, RolesUSuarioUpdateWithoutUsuariosInput>, RolesUSuarioUncheckedUpdateWithoutUsuariosInput>
  }

  export type AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    upsert?: AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInputEnvelope
    set?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    disconnect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    delete?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    update?: AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    updateMany?: AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    deleteMany?: AlmacenesScalarWhereInput | AlmacenesScalarWhereInput[]
  }

  export type AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput = {
    create?: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput> | AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[] | AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    connectOrCreate?: AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    upsert?: AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    createMany?: AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInputEnvelope
    set?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    disconnect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    delete?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    connect?: AlmacenesWhereUniqueInput | AlmacenesWhereUniqueInput[]
    update?: AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    updateMany?: AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    deleteMany?: AlmacenesScalarWhereInput | AlmacenesScalarWhereInput[]
  }

  export type InventarioUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<InventarioCreateWithoutUsuariosInput, InventarioUncheckedCreateWithoutUsuariosInput> | InventarioCreateWithoutUsuariosInput[] | InventarioUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: InventarioCreateOrConnectWithoutUsuariosInput | InventarioCreateOrConnectWithoutUsuariosInput[]
    upsert?: InventarioUpsertWithWhereUniqueWithoutUsuariosInput | InventarioUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: InventarioCreateManyUsuariosInputEnvelope
    set?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    disconnect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    delete?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    connect?: InventarioWhereUniqueInput | InventarioWhereUniqueInput[]
    update?: InventarioUpdateWithWhereUniqueWithoutUsuariosInput | InventarioUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: InventarioUpdateManyWithWhereWithoutUsuariosInput | InventarioUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
  }

  export type ProductosCreateNestedOneWithoutVentasInput = {
    create?: XOR<ProductosCreateWithoutVentasInput, ProductosUncheckedCreateWithoutVentasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutVentasInput
    connect?: ProductosWhereUniqueInput
  }

  export type ClientesCreateNestedOneWithoutVentasInput = {
    create?: XOR<ClientesCreateWithoutVentasInput, ClientesUncheckedCreateWithoutVentasInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutVentasInput
    connect?: ClientesWhereUniqueInput
  }

  export type MetodosPagoCreateNestedOneWithoutVentasInput = {
    create?: XOR<MetodosPagoCreateWithoutVentasInput, MetodosPagoUncheckedCreateWithoutVentasInput>
    connectOrCreate?: MetodosPagoCreateOrConnectWithoutVentasInput
    connect?: MetodosPagoWhereUniqueInput
  }

  export type ProductosUpdateOneRequiredWithoutVentasNestedInput = {
    create?: XOR<ProductosCreateWithoutVentasInput, ProductosUncheckedCreateWithoutVentasInput>
    connectOrCreate?: ProductosCreateOrConnectWithoutVentasInput
    upsert?: ProductosUpsertWithoutVentasInput
    connect?: ProductosWhereUniqueInput
    update?: XOR<XOR<ProductosUpdateToOneWithWhereWithoutVentasInput, ProductosUpdateWithoutVentasInput>, ProductosUncheckedUpdateWithoutVentasInput>
  }

  export type ClientesUpdateOneWithoutVentasNestedInput = {
    create?: XOR<ClientesCreateWithoutVentasInput, ClientesUncheckedCreateWithoutVentasInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutVentasInput
    upsert?: ClientesUpsertWithoutVentasInput
    disconnect?: ClientesWhereInput | boolean
    delete?: ClientesWhereInput | boolean
    connect?: ClientesWhereUniqueInput
    update?: XOR<XOR<ClientesUpdateToOneWithWhereWithoutVentasInput, ClientesUpdateWithoutVentasInput>, ClientesUncheckedUpdateWithoutVentasInput>
  }

  export type MetodosPagoUpdateOneRequiredWithoutVentasNestedInput = {
    create?: XOR<MetodosPagoCreateWithoutVentasInput, MetodosPagoUncheckedCreateWithoutVentasInput>
    connectOrCreate?: MetodosPagoCreateOrConnectWithoutVentasInput
    upsert?: MetodosPagoUpsertWithoutVentasInput
    connect?: MetodosPagoWhereUniqueInput
    update?: XOR<XOR<MetodosPagoUpdateToOneWithWhereWithoutVentasInput, MetodosPagoUpdateWithoutVentasInput>, MetodosPagoUncheckedUpdateWithoutVentasInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsuariosCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    Nombre: string
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
    Inventario?: InventarioCreateNestedManyWithoutUsuariosInput
    RolesUSuario?: RolesUSuarioCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    Id?: number
    Nombre: string
    RoleId?: number | null
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>
  }

  export type UsuariosCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    Nombre: string
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Inventario?: InventarioCreateNestedManyWithoutUsuariosInput
    RolesUSuario?: RolesUSuarioCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    Id?: number
    Nombre: string
    RoleId?: number | null
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>
  }

  export type InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    CantidadRecibida: number
    FechaSurtido: Date | string
    CreadoFecha: Date | string
    Compras: ComprasCreateNestedOneWithoutInventarioInput
    Productos: ProductosCreateNestedOneWithoutInventarioInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    Usuarios: UsuariosCreateNestedOneWithoutInventarioInput
  }

  export type InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioCreateOrConnectWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput>
  }

  export type InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInputEnvelope = {
    data: InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput | InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    CantidadRecibida: number
    FechaSurtido: Date | string
    CreadoFecha: Date | string
    Compras: ComprasCreateNestedOneWithoutInventarioInput
    Productos: ProductosCreateNestedOneWithoutInventarioInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    Usuarios: UsuariosCreateNestedOneWithoutInventarioInput
  }

  export type InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioCreateOrConnectWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
  }

  export type InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInputEnvelope = {
    data: InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput | InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    CantidadRecibida: number
    FechaSurtido: Date | string
    CreadoFecha: Date | string
    Compras: ComprasCreateNestedOneWithoutInventarioInput
    Productos: ProductosCreateNestedOneWithoutInventarioInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Usuarios: UsuariosCreateNestedOneWithoutInventarioInput
  }

  export type InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioCreateOrConnectWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
  }

  export type InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInputEnvelope = {
    data: InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput | InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput[]
    skipDuplicates?: boolean
  }

  export type UsuariosUpsertWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    update: XOR<UsuariosUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput, UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>
    create: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput, UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput>
  }

  export type UsuariosUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario?: InventarioUpdateManyWithoutUsuariosNestedInput
    RolesUSuario?: RolesUSuarioUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUpsertWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    update: XOR<UsuariosUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput, UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>
    create: XOR<UsuariosCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput, UsuariosUncheckedCreateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput, UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput>
  }

  export type UsuariosUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Inventario?: InventarioUpdateManyWithoutUsuariosNestedInput
    RolesUSuario?: RolesUSuarioUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedUpdateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput>
    create: XOR<InventarioCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput, InventarioUncheckedUpdateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput>
  }

  export type InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput>
  }

  export type InventarioScalarWhereInput = {
    AND?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
    OR?: InventarioScalarWhereInput[]
    NOT?: InventarioScalarWhereInput | InventarioScalarWhereInput[]
    Id?: IntFilter<"Inventario"> | number
    CompraId?: IntFilter<"Inventario"> | number
    ProductoId?: IntFilter<"Inventario"> | number
    CantidadRecibida?: IntFilter<"Inventario"> | number
    AlmacenActualId?: IntFilter<"Inventario"> | number
    FechaSurtido?: DateTimeFilter<"Inventario"> | Date | string
    SurtidoPorAlmacenId?: IntFilter<"Inventario"> | number
    RecibidoPorAlmacenId?: IntFilter<"Inventario"> | number
    CreadoFecha?: DateTimeFilter<"Inventario"> | Date | string
    CreadoPor?: IntFilter<"Inventario"> | number
  }

  export type InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedUpdateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
    create: XOR<InventarioCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedUpdateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
  }

  export type InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
  }

  export type InventarioUpsertWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedUpdateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
    create: XOR<InventarioCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedCreateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, InventarioUncheckedUpdateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
  }

  export type InventarioUpdateManyWithWhereWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
  }

  export type ProductosCreateWithoutCategoriasProductoInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    Compras?: ComprasCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosCreateNestedManyWithoutProductosInput
    Inventario?: InventarioCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosCreateNestedManyWithoutProductosInput
    Ventas?: VentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutCategoriasProductoInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    Compras?: ComprasUncheckedCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosUncheckedCreateNestedManyWithoutProductosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosUncheckedCreateNestedManyWithoutProductosInput
    Ventas?: VentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutCategoriasProductoInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutCategoriasProductoInput, ProductosUncheckedCreateWithoutCategoriasProductoInput>
  }

  export type ProductosCreateManyCategoriasProductoInputEnvelope = {
    data: ProductosCreateManyCategoriasProductoInput | ProductosCreateManyCategoriasProductoInput[]
    skipDuplicates?: boolean
  }

  export type ProductosUpsertWithWhereUniqueWithoutCategoriasProductoInput = {
    where: ProductosWhereUniqueInput
    update: XOR<ProductosUpdateWithoutCategoriasProductoInput, ProductosUncheckedUpdateWithoutCategoriasProductoInput>
    create: XOR<ProductosCreateWithoutCategoriasProductoInput, ProductosUncheckedCreateWithoutCategoriasProductoInput>
  }

  export type ProductosUpdateWithWhereUniqueWithoutCategoriasProductoInput = {
    where: ProductosWhereUniqueInput
    data: XOR<ProductosUpdateWithoutCategoriasProductoInput, ProductosUncheckedUpdateWithoutCategoriasProductoInput>
  }

  export type ProductosUpdateManyWithWhereWithoutCategoriasProductoInput = {
    where: ProductosScalarWhereInput
    data: XOR<ProductosUpdateManyMutationInput, ProductosUncheckedUpdateManyWithoutCategoriasProductoInput>
  }

  export type ProductosScalarWhereInput = {
    AND?: ProductosScalarWhereInput | ProductosScalarWhereInput[]
    OR?: ProductosScalarWhereInput[]
    NOT?: ProductosScalarWhereInput | ProductosScalarWhereInput[]
    Id?: IntFilter<"Productos"> | number
    Nombre?: StringFilter<"Productos"> | string
    Descripcion?: StringNullableFilter<"Productos"> | string | null
    Cantidad?: IntFilter<"Productos"> | number
    EsPieza?: BoolFilter<"Productos"> | boolean
    CategoriaId?: IntFilter<"Productos"> | number
  }

  export type VentasCreateWithoutClientesInput = {
    Folio: string
    Cantidad: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
    Productos: ProductosCreateNestedOneWithoutVentasInput
    MetodosPago: MetodosPagoCreateNestedOneWithoutVentasInput
  }

  export type VentasUncheckedCreateWithoutClientesInput = {
    Id?: number
    Folio: string
    ProductoId: number
    Cantidad: number
    MetodoPagoId: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type VentasCreateOrConnectWithoutClientesInput = {
    where: VentasWhereUniqueInput
    create: XOR<VentasCreateWithoutClientesInput, VentasUncheckedCreateWithoutClientesInput>
  }

  export type VentasCreateManyClientesInputEnvelope = {
    data: VentasCreateManyClientesInput | VentasCreateManyClientesInput[]
    skipDuplicates?: boolean
  }

  export type VentasUpsertWithWhereUniqueWithoutClientesInput = {
    where: VentasWhereUniqueInput
    update: XOR<VentasUpdateWithoutClientesInput, VentasUncheckedUpdateWithoutClientesInput>
    create: XOR<VentasCreateWithoutClientesInput, VentasUncheckedCreateWithoutClientesInput>
  }

  export type VentasUpdateWithWhereUniqueWithoutClientesInput = {
    where: VentasWhereUniqueInput
    data: XOR<VentasUpdateWithoutClientesInput, VentasUncheckedUpdateWithoutClientesInput>
  }

  export type VentasUpdateManyWithWhereWithoutClientesInput = {
    where: VentasScalarWhereInput
    data: XOR<VentasUpdateManyMutationInput, VentasUncheckedUpdateManyWithoutClientesInput>
  }

  export type VentasScalarWhereInput = {
    AND?: VentasScalarWhereInput | VentasScalarWhereInput[]
    OR?: VentasScalarWhereInput[]
    NOT?: VentasScalarWhereInput | VentasScalarWhereInput[]
    Id?: IntFilter<"Ventas"> | number
    Folio?: StringFilter<"Ventas"> | string
    ProductoId?: IntFilter<"Ventas"> | number
    Cantidad?: IntFilter<"Ventas"> | number
    ClienteId?: IntNullableFilter<"Ventas"> | number | null
    MetodoPagoId?: IntFilter<"Ventas"> | number
    Pagado?: BoolFilter<"Ventas"> | boolean
    FechaPago?: DateTimeNullableFilter<"Ventas"> | Date | string | null
    Observaciones?: StringNullableFilter<"Ventas"> | string | null
    CreadoFecha?: DateTimeFilter<"Ventas"> | Date | string
  }

  export type TiposCompraCreateWithoutComprasInput = {
    Code: string
    Nombre: string
  }

  export type TiposCompraUncheckedCreateWithoutComprasInput = {
    Id?: number
    Code: string
    Nombre: string
  }

  export type TiposCompraCreateOrConnectWithoutComprasInput = {
    where: TiposCompraWhereUniqueInput
    create: XOR<TiposCompraCreateWithoutComprasInput, TiposCompraUncheckedCreateWithoutComprasInput>
  }

  export type ProveedoresCreateWithoutComprasInput = {
    Nombre: string
  }

  export type ProveedoresUncheckedCreateWithoutComprasInput = {
    Id?: number
    Nombre: string
  }

  export type ProveedoresCreateOrConnectWithoutComprasInput = {
    where: ProveedoresWhereUniqueInput
    create: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
  }

  export type ProductosCreateWithoutComprasInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    ImagenesProductos?: ImagenesProductosCreateNestedManyWithoutProductosInput
    Inventario?: InventarioCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosCreateNestedManyWithoutProductosInput
    CategoriasProducto: CategoriasProductoCreateNestedOneWithoutProductosInput
    Ventas?: VentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutComprasInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    CategoriaId: number
    ImagenesProductos?: ImagenesProductosUncheckedCreateNestedManyWithoutProductosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosUncheckedCreateNestedManyWithoutProductosInput
    Ventas?: VentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutComprasInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutComprasInput, ProductosUncheckedCreateWithoutComprasInput>
  }

  export type InsumosCreateWithoutComprasInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    CantidadRecibida?: number | null
    CostoUnitario: Decimal | DecimalJsLike | number | string
  }

  export type InsumosUncheckedCreateWithoutComprasInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    CantidadRecibida?: number | null
    CostoUnitario: Decimal | DecimalJsLike | number | string
  }

  export type InsumosCreateOrConnectWithoutComprasInput = {
    where: InsumosWhereUniqueInput
    create: XOR<InsumosCreateWithoutComprasInput, InsumosUncheckedCreateWithoutComprasInput>
  }

  export type InventarioCreateWithoutComprasInput = {
    CantidadRecibida: number
    FechaSurtido: Date | string
    CreadoFecha: Date | string
    Productos: ProductosCreateNestedOneWithoutInventarioInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    Usuarios: UsuariosCreateNestedOneWithoutInventarioInput
  }

  export type InventarioUncheckedCreateWithoutComprasInput = {
    Id?: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioCreateOrConnectWithoutComprasInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutComprasInput, InventarioUncheckedCreateWithoutComprasInput>
  }

  export type InventarioCreateManyComprasInputEnvelope = {
    data: InventarioCreateManyComprasInput | InventarioCreateManyComprasInput[]
    skipDuplicates?: boolean
  }

  export type TiposCompraUpsertWithoutComprasInput = {
    update: XOR<TiposCompraUpdateWithoutComprasInput, TiposCompraUncheckedUpdateWithoutComprasInput>
    create: XOR<TiposCompraCreateWithoutComprasInput, TiposCompraUncheckedCreateWithoutComprasInput>
    where?: TiposCompraWhereInput
  }

  export type TiposCompraUpdateToOneWithWhereWithoutComprasInput = {
    where?: TiposCompraWhereInput
    data: XOR<TiposCompraUpdateWithoutComprasInput, TiposCompraUncheckedUpdateWithoutComprasInput>
  }

  export type TiposCompraUpdateWithoutComprasInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TiposCompraUncheckedUpdateWithoutComprasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProveedoresUpsertWithoutComprasInput = {
    update: XOR<ProveedoresUpdateWithoutComprasInput, ProveedoresUncheckedUpdateWithoutComprasInput>
    create: XOR<ProveedoresCreateWithoutComprasInput, ProveedoresUncheckedCreateWithoutComprasInput>
    where?: ProveedoresWhereInput
  }

  export type ProveedoresUpdateToOneWithWhereWithoutComprasInput = {
    where?: ProveedoresWhereInput
    data: XOR<ProveedoresUpdateWithoutComprasInput, ProveedoresUncheckedUpdateWithoutComprasInput>
  }

  export type ProveedoresUpdateWithoutComprasInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProveedoresUncheckedUpdateWithoutComprasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductosUpsertWithoutComprasInput = {
    update: XOR<ProductosUpdateWithoutComprasInput, ProductosUncheckedUpdateWithoutComprasInput>
    create: XOR<ProductosCreateWithoutComprasInput, ProductosUncheckedCreateWithoutComprasInput>
    where?: ProductosWhereInput
  }

  export type ProductosUpdateToOneWithWhereWithoutComprasInput = {
    where?: ProductosWhereInput
    data: XOR<ProductosUpdateWithoutComprasInput, ProductosUncheckedUpdateWithoutComprasInput>
  }

  export type ProductosUpdateWithoutComprasInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    ImagenesProductos?: ImagenesProductosUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUpdateManyWithoutProductosNestedInput
    CategoriasProducto?: CategoriasProductoUpdateOneRequiredWithoutProductosNestedInput
    Ventas?: VentasUpdateManyWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateWithoutComprasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    CategoriaId?: IntFieldUpdateOperationsInput | number
    ImagenesProductos?: ImagenesProductosUncheckedUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUncheckedUpdateManyWithoutProductosNestedInput
    Ventas?: VentasUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type InsumosUpsertWithoutComprasInput = {
    update: XOR<InsumosUpdateWithoutComprasInput, InsumosUncheckedUpdateWithoutComprasInput>
    create: XOR<InsumosCreateWithoutComprasInput, InsumosUncheckedCreateWithoutComprasInput>
    where?: InsumosWhereInput
  }

  export type InsumosUpdateToOneWithWhereWithoutComprasInput = {
    where?: InsumosWhereInput
    data: XOR<InsumosUpdateWithoutComprasInput, InsumosUncheckedUpdateWithoutComprasInput>
  }

  export type InsumosUpdateWithoutComprasInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: NullableIntFieldUpdateOperationsInput | number | null
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InsumosUncheckedUpdateWithoutComprasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: NullableIntFieldUpdateOperationsInput | number | null
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventarioUpsertWithWhereUniqueWithoutComprasInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutComprasInput, InventarioUncheckedUpdateWithoutComprasInput>
    create: XOR<InventarioCreateWithoutComprasInput, InventarioUncheckedCreateWithoutComprasInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutComprasInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutComprasInput, InventarioUncheckedUpdateWithoutComprasInput>
  }

  export type InventarioUpdateManyWithWhereWithoutComprasInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutComprasInput>
  }

  export type ProductosCreateWithoutImagenesProductosInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    Compras?: ComprasCreateNestedManyWithoutProductosInput
    Inventario?: InventarioCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosCreateNestedManyWithoutProductosInput
    CategoriasProducto: CategoriasProductoCreateNestedOneWithoutProductosInput
    Ventas?: VentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutImagenesProductosInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    CategoriaId: number
    Compras?: ComprasUncheckedCreateNestedManyWithoutProductosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosUncheckedCreateNestedManyWithoutProductosInput
    Ventas?: VentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutImagenesProductosInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutImagenesProductosInput, ProductosUncheckedCreateWithoutImagenesProductosInput>
  }

  export type ProductosUpsertWithoutImagenesProductosInput = {
    update: XOR<ProductosUpdateWithoutImagenesProductosInput, ProductosUncheckedUpdateWithoutImagenesProductosInput>
    create: XOR<ProductosCreateWithoutImagenesProductosInput, ProductosUncheckedCreateWithoutImagenesProductosInput>
    where?: ProductosWhereInput
  }

  export type ProductosUpdateToOneWithWhereWithoutImagenesProductosInput = {
    where?: ProductosWhereInput
    data: XOR<ProductosUpdateWithoutImagenesProductosInput, ProductosUncheckedUpdateWithoutImagenesProductosInput>
  }

  export type ProductosUpdateWithoutImagenesProductosInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUpdateManyWithoutProductosNestedInput
    CategoriasProducto?: CategoriasProductoUpdateOneRequiredWithoutProductosNestedInput
    Ventas?: VentasUpdateManyWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateWithoutImagenesProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    CategoriaId?: IntFieldUpdateOperationsInput | number
    Compras?: ComprasUncheckedUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUncheckedUpdateManyWithoutProductosNestedInput
    Ventas?: VentasUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type ComprasCreateWithoutInsumosInput = {
    Folio: string
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    TiposCompra: TiposCompraCreateNestedOneWithoutComprasInput
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
    Productos?: ProductosCreateNestedOneWithoutComprasInput
    Inventario?: InventarioCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutInsumosInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    ProductoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    Inventario?: InventarioUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasCreateOrConnectWithoutInsumosInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutInsumosInput, ComprasUncheckedCreateWithoutInsumosInput>
  }

  export type ComprasCreateManyInsumosInputEnvelope = {
    data: ComprasCreateManyInsumosInput | ComprasCreateManyInsumosInput[]
    skipDuplicates?: boolean
  }

  export type ComprasUpsertWithWhereUniqueWithoutInsumosInput = {
    where: ComprasWhereUniqueInput
    update: XOR<ComprasUpdateWithoutInsumosInput, ComprasUncheckedUpdateWithoutInsumosInput>
    create: XOR<ComprasCreateWithoutInsumosInput, ComprasUncheckedCreateWithoutInsumosInput>
  }

  export type ComprasUpdateWithWhereUniqueWithoutInsumosInput = {
    where: ComprasWhereUniqueInput
    data: XOR<ComprasUpdateWithoutInsumosInput, ComprasUncheckedUpdateWithoutInsumosInput>
  }

  export type ComprasUpdateManyWithWhereWithoutInsumosInput = {
    where: ComprasScalarWhereInput
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyWithoutInsumosInput>
  }

  export type ComprasScalarWhereInput = {
    AND?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
    OR?: ComprasScalarWhereInput[]
    NOT?: ComprasScalarWhereInput | ComprasScalarWhereInput[]
    Id?: IntFilter<"Compras"> | number
    Folio?: StringFilter<"Compras"> | string
    TipoCompraId?: IntFilter<"Compras"> | number
    ProveedorId?: IntFilter<"Compras"> | number
    ProductoId?: IntNullableFilter<"Compras"> | number | null
    InsumoId?: IntNullableFilter<"Compras"> | number | null
    Cantidad?: IntFilter<"Compras"> | number
    CantidadRecibida?: IntFilter<"Compras"> | number
    CostoUnitario?: DecimalFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFilter<"Compras"> | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFilter<"Compras"> | Date | string
    CreadoFecha?: DateTimeFilter<"Compras"> | Date | string
  }

  export type ComprasCreateWithoutInventarioInput = {
    Folio: string
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    TiposCompra: TiposCompraCreateNestedOneWithoutComprasInput
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
    Productos?: ProductosCreateNestedOneWithoutComprasInput
    Insumos?: InsumosCreateNestedOneWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutInventarioInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    ProductoId?: number | null
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
  }

  export type ComprasCreateOrConnectWithoutInventarioInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutInventarioInput, ComprasUncheckedCreateWithoutInventarioInput>
  }

  export type ProductosCreateWithoutInventarioInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    Compras?: ComprasCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosCreateNestedManyWithoutProductosInput
    CategoriasProducto: CategoriasProductoCreateNestedOneWithoutProductosInput
    Ventas?: VentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutInventarioInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    CategoriaId: number
    Compras?: ComprasUncheckedCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosUncheckedCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosUncheckedCreateNestedManyWithoutProductosInput
    Ventas?: VentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutInventarioInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutInventarioInput, ProductosUncheckedCreateWithoutInventarioInput>
  }

  export type AlmacenesCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesUncheckedCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    UsuarioId: number
    FechaModificacion?: Date | string | null
    ModificadoPor?: number | null
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesCreateOrConnectWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    where: AlmacenesWhereUniqueInput
    create: XOR<AlmacenesCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>
  }

  export type AlmacenesCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesUncheckedCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    UsuarioId: number
    FechaModificacion?: Date | string | null
    ModificadoPor?: number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesCreateOrConnectWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    where: AlmacenesWhereUniqueInput
    create: XOR<AlmacenesCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
  }

  export type AlmacenesCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesUncheckedCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    UsuarioId: number
    FechaModificacion?: Date | string | null
    ModificadoPor?: number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesCreateOrConnectWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    where: AlmacenesWhereUniqueInput
    create: XOR<AlmacenesCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
  }

  export type UsuariosCreateWithoutInventarioInput = {
    Nombre: string
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
    RolesUSuario?: RolesUSuarioCreateNestedOneWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutInventarioInput = {
    Id?: number
    Nombre: string
    RoleId?: number | null
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutInventarioInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutInventarioInput, UsuariosUncheckedCreateWithoutInventarioInput>
  }

  export type ComprasUpsertWithoutInventarioInput = {
    update: XOR<ComprasUpdateWithoutInventarioInput, ComprasUncheckedUpdateWithoutInventarioInput>
    create: XOR<ComprasCreateWithoutInventarioInput, ComprasUncheckedCreateWithoutInventarioInput>
    where?: ComprasWhereInput
  }

  export type ComprasUpdateToOneWithWhereWithoutInventarioInput = {
    where?: ComprasWhereInput
    data: XOR<ComprasUpdateWithoutInventarioInput, ComprasUncheckedUpdateWithoutInventarioInput>
  }

  export type ComprasUpdateWithoutInventarioInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    TiposCompra?: TiposCompraUpdateOneRequiredWithoutComprasNestedInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasNestedInput
    Productos?: ProductosUpdateOneWithoutComprasNestedInput
    Insumos?: InsumosUpdateOneWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateWithoutInventarioInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProveedorId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductosUpsertWithoutInventarioInput = {
    update: XOR<ProductosUpdateWithoutInventarioInput, ProductosUncheckedUpdateWithoutInventarioInput>
    create: XOR<ProductosCreateWithoutInventarioInput, ProductosUncheckedCreateWithoutInventarioInput>
    where?: ProductosWhereInput
  }

  export type ProductosUpdateToOneWithWhereWithoutInventarioInput = {
    where?: ProductosWhereInput
    data: XOR<ProductosUpdateWithoutInventarioInput, ProductosUncheckedUpdateWithoutInventarioInput>
  }

  export type ProductosUpdateWithoutInventarioInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUpdateManyWithoutProductosNestedInput
    CategoriasProducto?: CategoriasProductoUpdateOneRequiredWithoutProductosNestedInput
    Ventas?: VentasUpdateManyWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateWithoutInventarioInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    CategoriaId?: IntFieldUpdateOperationsInput | number
    Compras?: ComprasUncheckedUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUncheckedUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUncheckedUpdateManyWithoutProductosNestedInput
    Ventas?: VentasUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type AlmacenesUpsertWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    update: XOR<AlmacenesUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput, AlmacenesUncheckedUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>
    create: XOR<AlmacenesCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>
    where?: AlmacenesWhereInput
  }

  export type AlmacenesUpdateToOneWithWhereWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    where?: AlmacenesWhereInput
    data: XOR<AlmacenesUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput, AlmacenesUncheckedUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput>
  }

  export type AlmacenesUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios?: UsuariosUpdateOneRequiredWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosNestedInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosUpdateOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    UsuarioId?: IntFieldUpdateOperationsInput | number
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModificadoPor?: NullableIntFieldUpdateOperationsInput | number | null
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUpsertWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    update: XOR<AlmacenesUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
    create: XOR<AlmacenesCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
    where?: AlmacenesWhereInput
  }

  export type AlmacenesUpdateToOneWithWhereWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    where?: AlmacenesWhereInput
    data: XOR<AlmacenesUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput>
  }

  export type AlmacenesUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios?: UsuariosUpdateOneRequiredWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosNestedInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosUpdateOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    UsuarioId?: IntFieldUpdateOperationsInput | number
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModificadoPor?: NullableIntFieldUpdateOperationsInput | number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUpsertWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    update: XOR<AlmacenesUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
    create: XOR<AlmacenesCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedCreateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
    where?: AlmacenesWhereInput
  }

  export type AlmacenesUpdateToOneWithWhereWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    where?: AlmacenesWhereInput
    data: XOR<AlmacenesUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput, AlmacenesUncheckedUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput>
  }

  export type AlmacenesUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios?: UsuariosUpdateOneRequiredWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosNestedInput
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosUpdateOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    UsuarioId?: IntFieldUpdateOperationsInput | number
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModificadoPor?: NullableIntFieldUpdateOperationsInput | number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type UsuariosUpsertWithoutInventarioInput = {
    update: XOR<UsuariosUpdateWithoutInventarioInput, UsuariosUncheckedUpdateWithoutInventarioInput>
    create: XOR<UsuariosCreateWithoutInventarioInput, UsuariosUncheckedCreateWithoutInventarioInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutInventarioInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutInventarioInput, UsuariosUncheckedUpdateWithoutInventarioInput>
  }

  export type UsuariosUpdateWithoutInventarioInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
    RolesUSuario?: RolesUSuarioUpdateOneWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutInventarioInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    RoleId?: NullableIntFieldUpdateOperationsInput | number | null
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
  }

  export type ProductosCreateWithoutListasPreciosInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    Compras?: ComprasCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosCreateNestedManyWithoutProductosInput
    Inventario?: InventarioCreateNestedManyWithoutProductosInput
    CategoriasProducto: CategoriasProductoCreateNestedOneWithoutProductosInput
    Ventas?: VentasCreateNestedManyWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutListasPreciosInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    CategoriaId: number
    Compras?: ComprasUncheckedCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosUncheckedCreateNestedManyWithoutProductosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutProductosInput
    Ventas?: VentasUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutListasPreciosInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutListasPreciosInput, ProductosUncheckedCreateWithoutListasPreciosInput>
  }

  export type UnidadesMedidaCreateWithoutListasPreciosInput = {
    Code: string
    Nombre?: string | null
  }

  export type UnidadesMedidaUncheckedCreateWithoutListasPreciosInput = {
    Id?: number
    Code: string
    Nombre?: string | null
  }

  export type UnidadesMedidaCreateOrConnectWithoutListasPreciosInput = {
    where: UnidadesMedidaWhereUniqueInput
    create: XOR<UnidadesMedidaCreateWithoutListasPreciosInput, UnidadesMedidaUncheckedCreateWithoutListasPreciosInput>
  }

  export type ProductosUpsertWithoutListasPreciosInput = {
    update: XOR<ProductosUpdateWithoutListasPreciosInput, ProductosUncheckedUpdateWithoutListasPreciosInput>
    create: XOR<ProductosCreateWithoutListasPreciosInput, ProductosUncheckedCreateWithoutListasPreciosInput>
    where?: ProductosWhereInput
  }

  export type ProductosUpdateToOneWithWhereWithoutListasPreciosInput = {
    where?: ProductosWhereInput
    data: XOR<ProductosUpdateWithoutListasPreciosInput, ProductosUncheckedUpdateWithoutListasPreciosInput>
  }

  export type ProductosUpdateWithoutListasPreciosInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUpdateManyWithoutProductosNestedInput
    CategoriasProducto?: CategoriasProductoUpdateOneRequiredWithoutProductosNestedInput
    Ventas?: VentasUpdateManyWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateWithoutListasPreciosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    CategoriaId?: IntFieldUpdateOperationsInput | number
    Compras?: ComprasUncheckedUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUncheckedUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutProductosNestedInput
    Ventas?: VentasUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type UnidadesMedidaUpsertWithoutListasPreciosInput = {
    update: XOR<UnidadesMedidaUpdateWithoutListasPreciosInput, UnidadesMedidaUncheckedUpdateWithoutListasPreciosInput>
    create: XOR<UnidadesMedidaCreateWithoutListasPreciosInput, UnidadesMedidaUncheckedCreateWithoutListasPreciosInput>
    where?: UnidadesMedidaWhereInput
  }

  export type UnidadesMedidaUpdateToOneWithWhereWithoutListasPreciosInput = {
    where?: UnidadesMedidaWhereInput
    data: XOR<UnidadesMedidaUpdateWithoutListasPreciosInput, UnidadesMedidaUncheckedUpdateWithoutListasPreciosInput>
  }

  export type UnidadesMedidaUpdateWithoutListasPreciosInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnidadesMedidaUncheckedUpdateWithoutListasPreciosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VentasCreateWithoutMetodosPagoInput = {
    Folio: string
    Cantidad: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
    Productos: ProductosCreateNestedOneWithoutVentasInput
    Clientes?: ClientesCreateNestedOneWithoutVentasInput
  }

  export type VentasUncheckedCreateWithoutMetodosPagoInput = {
    Id?: number
    Folio: string
    ProductoId: number
    Cantidad: number
    ClienteId?: number | null
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type VentasCreateOrConnectWithoutMetodosPagoInput = {
    where: VentasWhereUniqueInput
    create: XOR<VentasCreateWithoutMetodosPagoInput, VentasUncheckedCreateWithoutMetodosPagoInput>
  }

  export type VentasCreateManyMetodosPagoInputEnvelope = {
    data: VentasCreateManyMetodosPagoInput | VentasCreateManyMetodosPagoInput[]
    skipDuplicates?: boolean
  }

  export type VentasUpsertWithWhereUniqueWithoutMetodosPagoInput = {
    where: VentasWhereUniqueInput
    update: XOR<VentasUpdateWithoutMetodosPagoInput, VentasUncheckedUpdateWithoutMetodosPagoInput>
    create: XOR<VentasCreateWithoutMetodosPagoInput, VentasUncheckedCreateWithoutMetodosPagoInput>
  }

  export type VentasUpdateWithWhereUniqueWithoutMetodosPagoInput = {
    where: VentasWhereUniqueInput
    data: XOR<VentasUpdateWithoutMetodosPagoInput, VentasUncheckedUpdateWithoutMetodosPagoInput>
  }

  export type VentasUpdateManyWithWhereWithoutMetodosPagoInput = {
    where: VentasScalarWhereInput
    data: XOR<VentasUpdateManyMutationInput, VentasUncheckedUpdateManyWithoutMetodosPagoInput>
  }

  export type ComprasCreateWithoutProductosInput = {
    Folio: string
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    TiposCompra: TiposCompraCreateNestedOneWithoutComprasInput
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
    Insumos?: InsumosCreateNestedOneWithoutComprasInput
    Inventario?: InventarioCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutProductosInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    Inventario?: InventarioUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasCreateOrConnectWithoutProductosInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutProductosInput, ComprasUncheckedCreateWithoutProductosInput>
  }

  export type ComprasCreateManyProductosInputEnvelope = {
    data: ComprasCreateManyProductosInput | ComprasCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type ImagenesProductosCreateWithoutProductosInput = {
    URLImagen?: string | null
  }

  export type ImagenesProductosUncheckedCreateWithoutProductosInput = {
    Id?: number
    URLImagen?: string | null
  }

  export type ImagenesProductosCreateOrConnectWithoutProductosInput = {
    where: ImagenesProductosWhereUniqueInput
    create: XOR<ImagenesProductosCreateWithoutProductosInput, ImagenesProductosUncheckedCreateWithoutProductosInput>
  }

  export type ImagenesProductosCreateManyProductosInputEnvelope = {
    data: ImagenesProductosCreateManyProductosInput | ImagenesProductosCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutProductosInput = {
    CantidadRecibida: number
    FechaSurtido: Date | string
    CreadoFecha: Date | string
    Compras: ComprasCreateNestedOneWithoutInventarioInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
    Usuarios: UsuariosCreateNestedOneWithoutInventarioInput
  }

  export type InventarioUncheckedCreateWithoutProductosInput = {
    Id?: number
    CompraId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioCreateOrConnectWithoutProductosInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutProductosInput, InventarioUncheckedCreateWithoutProductosInput>
  }

  export type InventarioCreateManyProductosInputEnvelope = {
    data: InventarioCreateManyProductosInput | InventarioCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type ListasPreciosCreateWithoutProductosInput = {
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
    UnidadesMedida: UnidadesMedidaCreateNestedOneWithoutListasPreciosInput
  }

  export type ListasPreciosUncheckedCreateWithoutProductosInput = {
    Id?: number
    UnidadMedidaId: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
  }

  export type ListasPreciosCreateOrConnectWithoutProductosInput = {
    where: ListasPreciosWhereUniqueInput
    create: XOR<ListasPreciosCreateWithoutProductosInput, ListasPreciosUncheckedCreateWithoutProductosInput>
  }

  export type ListasPreciosCreateManyProductosInputEnvelope = {
    data: ListasPreciosCreateManyProductosInput | ListasPreciosCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type CategoriasProductoCreateWithoutProductosInput = {
    Code: string
    Nombre: string
  }

  export type CategoriasProductoUncheckedCreateWithoutProductosInput = {
    Id?: number
    Code: string
    Nombre: string
  }

  export type CategoriasProductoCreateOrConnectWithoutProductosInput = {
    where: CategoriasProductoWhereUniqueInput
    create: XOR<CategoriasProductoCreateWithoutProductosInput, CategoriasProductoUncheckedCreateWithoutProductosInput>
  }

  export type VentasCreateWithoutProductosInput = {
    Folio: string
    Cantidad: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
    Clientes?: ClientesCreateNestedOneWithoutVentasInput
    MetodosPago: MetodosPagoCreateNestedOneWithoutVentasInput
  }

  export type VentasUncheckedCreateWithoutProductosInput = {
    Id?: number
    Folio: string
    Cantidad: number
    ClienteId?: number | null
    MetodoPagoId: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type VentasCreateOrConnectWithoutProductosInput = {
    where: VentasWhereUniqueInput
    create: XOR<VentasCreateWithoutProductosInput, VentasUncheckedCreateWithoutProductosInput>
  }

  export type VentasCreateManyProductosInputEnvelope = {
    data: VentasCreateManyProductosInput | VentasCreateManyProductosInput[]
    skipDuplicates?: boolean
  }

  export type ComprasUpsertWithWhereUniqueWithoutProductosInput = {
    where: ComprasWhereUniqueInput
    update: XOR<ComprasUpdateWithoutProductosInput, ComprasUncheckedUpdateWithoutProductosInput>
    create: XOR<ComprasCreateWithoutProductosInput, ComprasUncheckedCreateWithoutProductosInput>
  }

  export type ComprasUpdateWithWhereUniqueWithoutProductosInput = {
    where: ComprasWhereUniqueInput
    data: XOR<ComprasUpdateWithoutProductosInput, ComprasUncheckedUpdateWithoutProductosInput>
  }

  export type ComprasUpdateManyWithWhereWithoutProductosInput = {
    where: ComprasScalarWhereInput
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyWithoutProductosInput>
  }

  export type ImagenesProductosUpsertWithWhereUniqueWithoutProductosInput = {
    where: ImagenesProductosWhereUniqueInput
    update: XOR<ImagenesProductosUpdateWithoutProductosInput, ImagenesProductosUncheckedUpdateWithoutProductosInput>
    create: XOR<ImagenesProductosCreateWithoutProductosInput, ImagenesProductosUncheckedCreateWithoutProductosInput>
  }

  export type ImagenesProductosUpdateWithWhereUniqueWithoutProductosInput = {
    where: ImagenesProductosWhereUniqueInput
    data: XOR<ImagenesProductosUpdateWithoutProductosInput, ImagenesProductosUncheckedUpdateWithoutProductosInput>
  }

  export type ImagenesProductosUpdateManyWithWhereWithoutProductosInput = {
    where: ImagenesProductosScalarWhereInput
    data: XOR<ImagenesProductosUpdateManyMutationInput, ImagenesProductosUncheckedUpdateManyWithoutProductosInput>
  }

  export type ImagenesProductosScalarWhereInput = {
    AND?: ImagenesProductosScalarWhereInput | ImagenesProductosScalarWhereInput[]
    OR?: ImagenesProductosScalarWhereInput[]
    NOT?: ImagenesProductosScalarWhereInput | ImagenesProductosScalarWhereInput[]
    Id?: IntFilter<"ImagenesProductos"> | number
    URLImagen?: StringNullableFilter<"ImagenesProductos"> | string | null
    ProductoId?: IntFilter<"ImagenesProductos"> | number
  }

  export type InventarioUpsertWithWhereUniqueWithoutProductosInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutProductosInput, InventarioUncheckedUpdateWithoutProductosInput>
    create: XOR<InventarioCreateWithoutProductosInput, InventarioUncheckedCreateWithoutProductosInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutProductosInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutProductosInput, InventarioUncheckedUpdateWithoutProductosInput>
  }

  export type InventarioUpdateManyWithWhereWithoutProductosInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutProductosInput>
  }

  export type ListasPreciosUpsertWithWhereUniqueWithoutProductosInput = {
    where: ListasPreciosWhereUniqueInput
    update: XOR<ListasPreciosUpdateWithoutProductosInput, ListasPreciosUncheckedUpdateWithoutProductosInput>
    create: XOR<ListasPreciosCreateWithoutProductosInput, ListasPreciosUncheckedCreateWithoutProductosInput>
  }

  export type ListasPreciosUpdateWithWhereUniqueWithoutProductosInput = {
    where: ListasPreciosWhereUniqueInput
    data: XOR<ListasPreciosUpdateWithoutProductosInput, ListasPreciosUncheckedUpdateWithoutProductosInput>
  }

  export type ListasPreciosUpdateManyWithWhereWithoutProductosInput = {
    where: ListasPreciosScalarWhereInput
    data: XOR<ListasPreciosUpdateManyMutationInput, ListasPreciosUncheckedUpdateManyWithoutProductosInput>
  }

  export type ListasPreciosScalarWhereInput = {
    AND?: ListasPreciosScalarWhereInput | ListasPreciosScalarWhereInput[]
    OR?: ListasPreciosScalarWhereInput[]
    NOT?: ListasPreciosScalarWhereInput | ListasPreciosScalarWhereInput[]
    Id?: IntFilter<"ListasPrecios"> | number
    ProductoId?: IntFilter<"ListasPrecios"> | number
    UnidadMedidaId?: IntFilter<"ListasPrecios"> | number
    CostoUnitario?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFilter<"ListasPrecios"> | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFilter<"ListasPrecios"> | Date | string
    Vigente?: BoolFilter<"ListasPrecios"> | boolean
  }

  export type CategoriasProductoUpsertWithoutProductosInput = {
    update: XOR<CategoriasProductoUpdateWithoutProductosInput, CategoriasProductoUncheckedUpdateWithoutProductosInput>
    create: XOR<CategoriasProductoCreateWithoutProductosInput, CategoriasProductoUncheckedCreateWithoutProductosInput>
    where?: CategoriasProductoWhereInput
  }

  export type CategoriasProductoUpdateToOneWithWhereWithoutProductosInput = {
    where?: CategoriasProductoWhereInput
    data: XOR<CategoriasProductoUpdateWithoutProductosInput, CategoriasProductoUncheckedUpdateWithoutProductosInput>
  }

  export type CategoriasProductoUpdateWithoutProductosInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriasProductoUncheckedUpdateWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type VentasUpsertWithWhereUniqueWithoutProductosInput = {
    where: VentasWhereUniqueInput
    update: XOR<VentasUpdateWithoutProductosInput, VentasUncheckedUpdateWithoutProductosInput>
    create: XOR<VentasCreateWithoutProductosInput, VentasUncheckedCreateWithoutProductosInput>
  }

  export type VentasUpdateWithWhereUniqueWithoutProductosInput = {
    where: VentasWhereUniqueInput
    data: XOR<VentasUpdateWithoutProductosInput, VentasUncheckedUpdateWithoutProductosInput>
  }

  export type VentasUpdateManyWithWhereWithoutProductosInput = {
    where: VentasScalarWhereInput
    data: XOR<VentasUpdateManyMutationInput, VentasUncheckedUpdateManyWithoutProductosInput>
  }

  export type ComprasCreateWithoutProveedoresInput = {
    Folio: string
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    TiposCompra: TiposCompraCreateNestedOneWithoutComprasInput
    Productos?: ProductosCreateNestedOneWithoutComprasInput
    Insumos?: InsumosCreateNestedOneWithoutComprasInput
    Inventario?: InventarioCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutProveedoresInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProductoId?: number | null
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    Inventario?: InventarioUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasCreateOrConnectWithoutProveedoresInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput>
  }

  export type ComprasCreateManyProveedoresInputEnvelope = {
    data: ComprasCreateManyProveedoresInput | ComprasCreateManyProveedoresInput[]
    skipDuplicates?: boolean
  }

  export type ComprasUpsertWithWhereUniqueWithoutProveedoresInput = {
    where: ComprasWhereUniqueInput
    update: XOR<ComprasUpdateWithoutProveedoresInput, ComprasUncheckedUpdateWithoutProveedoresInput>
    create: XOR<ComprasCreateWithoutProveedoresInput, ComprasUncheckedCreateWithoutProveedoresInput>
  }

  export type ComprasUpdateWithWhereUniqueWithoutProveedoresInput = {
    where: ComprasWhereUniqueInput
    data: XOR<ComprasUpdateWithoutProveedoresInput, ComprasUncheckedUpdateWithoutProveedoresInput>
  }

  export type ComprasUpdateManyWithWhereWithoutProveedoresInput = {
    where: ComprasScalarWhereInput
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyWithoutProveedoresInput>
  }

  export type UsuariosCreateWithoutRolesUSuarioInput = {
    Nombre: string
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
    Inventario?: InventarioCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosUncheckedCreateWithoutRolesUSuarioInput = {
    Id?: number
    Nombre: string
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedCreateNestedManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type UsuariosCreateOrConnectWithoutRolesUSuarioInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutRolesUSuarioInput, UsuariosUncheckedCreateWithoutRolesUSuarioInput>
  }

  export type UsuariosCreateManyRolesUSuarioInputEnvelope = {
    data: UsuariosCreateManyRolesUSuarioInput | UsuariosCreateManyRolesUSuarioInput[]
    skipDuplicates?: boolean
  }

  export type UsuariosUpsertWithWhereUniqueWithoutRolesUSuarioInput = {
    where: UsuariosWhereUniqueInput
    update: XOR<UsuariosUpdateWithoutRolesUSuarioInput, UsuariosUncheckedUpdateWithoutRolesUSuarioInput>
    create: XOR<UsuariosCreateWithoutRolesUSuarioInput, UsuariosUncheckedCreateWithoutRolesUSuarioInput>
  }

  export type UsuariosUpdateWithWhereUniqueWithoutRolesUSuarioInput = {
    where: UsuariosWhereUniqueInput
    data: XOR<UsuariosUpdateWithoutRolesUSuarioInput, UsuariosUncheckedUpdateWithoutRolesUSuarioInput>
  }

  export type UsuariosUpdateManyWithWhereWithoutRolesUSuarioInput = {
    where: UsuariosScalarWhereInput
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyWithoutRolesUSuarioInput>
  }

  export type UsuariosScalarWhereInput = {
    AND?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
    OR?: UsuariosScalarWhereInput[]
    NOT?: UsuariosScalarWhereInput | UsuariosScalarWhereInput[]
    Id?: IntFilter<"Usuarios"> | number
    Nombre?: StringFilter<"Usuarios"> | string
    RoleId?: IntNullableFilter<"Usuarios"> | number | null
    UsuariosLeier?: StringNullableFilter<"Usuarios"> | string | null
    Contrase_a?: StringNullableFilter<"Usuarios"> | string | null
    CreadoFecha?: DateTimeFilter<"Usuarios"> | Date | string
  }

  export type ComprasCreateWithoutTiposCompraInput = {
    Folio: string
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    Proveedores: ProveedoresCreateNestedOneWithoutComprasInput
    Productos?: ProductosCreateNestedOneWithoutComprasInput
    Insumos?: InsumosCreateNestedOneWithoutComprasInput
    Inventario?: InventarioCreateNestedManyWithoutComprasInput
  }

  export type ComprasUncheckedCreateWithoutTiposCompraInput = {
    Id?: number
    Folio: string
    ProveedorId: number
    ProductoId?: number | null
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
    Inventario?: InventarioUncheckedCreateNestedManyWithoutComprasInput
  }

  export type ComprasCreateOrConnectWithoutTiposCompraInput = {
    where: ComprasWhereUniqueInput
    create: XOR<ComprasCreateWithoutTiposCompraInput, ComprasUncheckedCreateWithoutTiposCompraInput>
  }

  export type ComprasCreateManyTiposCompraInputEnvelope = {
    data: ComprasCreateManyTiposCompraInput | ComprasCreateManyTiposCompraInput[]
    skipDuplicates?: boolean
  }

  export type ComprasUpsertWithWhereUniqueWithoutTiposCompraInput = {
    where: ComprasWhereUniqueInput
    update: XOR<ComprasUpdateWithoutTiposCompraInput, ComprasUncheckedUpdateWithoutTiposCompraInput>
    create: XOR<ComprasCreateWithoutTiposCompraInput, ComprasUncheckedCreateWithoutTiposCompraInput>
  }

  export type ComprasUpdateWithWhereUniqueWithoutTiposCompraInput = {
    where: ComprasWhereUniqueInput
    data: XOR<ComprasUpdateWithoutTiposCompraInput, ComprasUncheckedUpdateWithoutTiposCompraInput>
  }

  export type ComprasUpdateManyWithWhereWithoutTiposCompraInput = {
    where: ComprasScalarWhereInput
    data: XOR<ComprasUpdateManyMutationInput, ComprasUncheckedUpdateManyWithoutTiposCompraInput>
  }

  export type ListasPreciosCreateWithoutUnidadesMedidaInput = {
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
    Productos: ProductosCreateNestedOneWithoutListasPreciosInput
  }

  export type ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput = {
    Id?: number
    ProductoId: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
  }

  export type ListasPreciosCreateOrConnectWithoutUnidadesMedidaInput = {
    where: ListasPreciosWhereUniqueInput
    create: XOR<ListasPreciosCreateWithoutUnidadesMedidaInput, ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput>
  }

  export type ListasPreciosCreateManyUnidadesMedidaInputEnvelope = {
    data: ListasPreciosCreateManyUnidadesMedidaInput | ListasPreciosCreateManyUnidadesMedidaInput[]
    skipDuplicates?: boolean
  }

  export type ListasPreciosUpsertWithWhereUniqueWithoutUnidadesMedidaInput = {
    where: ListasPreciosWhereUniqueInput
    update: XOR<ListasPreciosUpdateWithoutUnidadesMedidaInput, ListasPreciosUncheckedUpdateWithoutUnidadesMedidaInput>
    create: XOR<ListasPreciosCreateWithoutUnidadesMedidaInput, ListasPreciosUncheckedCreateWithoutUnidadesMedidaInput>
  }

  export type ListasPreciosUpdateWithWhereUniqueWithoutUnidadesMedidaInput = {
    where: ListasPreciosWhereUniqueInput
    data: XOR<ListasPreciosUpdateWithoutUnidadesMedidaInput, ListasPreciosUncheckedUpdateWithoutUnidadesMedidaInput>
  }

  export type ListasPreciosUpdateManyWithWhereWithoutUnidadesMedidaInput = {
    where: ListasPreciosScalarWhereInput
    data: XOR<ListasPreciosUpdateManyMutationInput, ListasPreciosUncheckedUpdateManyWithoutUnidadesMedidaInput>
  }

  export type AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    ModificadoPor?: number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    where: AlmacenesWhereUniqueInput
    create: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput>
  }

  export type AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInputEnvelope = {
    data: AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInput | AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios: UsuariosCreateNestedOneWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    UsuarioId: number
    FechaModificacion?: Date | string | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedCreateNestedManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type AlmacenesCreateOrConnectWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    where: AlmacenesWhereUniqueInput
    create: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput>
  }

  export type AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInputEnvelope = {
    data: AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInput | AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type InventarioCreateWithoutUsuariosInput = {
    CantidadRecibida: number
    FechaSurtido: Date | string
    CreadoFecha: Date | string
    Compras: ComprasCreateNestedOneWithoutInventarioInput
    Productos: ProductosCreateNestedOneWithoutInventarioInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_AlmacenActualIdToAlmacenesInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes: AlmacenesCreateNestedOneWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesInput
  }

  export type InventarioUncheckedCreateWithoutUsuariosInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
  }

  export type InventarioCreateOrConnectWithoutUsuariosInput = {
    where: InventarioWhereUniqueInput
    create: XOR<InventarioCreateWithoutUsuariosInput, InventarioUncheckedCreateWithoutUsuariosInput>
  }

  export type InventarioCreateManyUsuariosInputEnvelope = {
    data: InventarioCreateManyUsuariosInput | InventarioCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type RolesUSuarioCreateWithoutUsuariosInput = {
    Nombre: string
  }

  export type RolesUSuarioUncheckedCreateWithoutUsuariosInput = {
    Id?: number
    Nombre: string
  }

  export type RolesUSuarioCreateOrConnectWithoutUsuariosInput = {
    where: RolesUSuarioWhereUniqueInput
    create: XOR<RolesUSuarioCreateWithoutUsuariosInput, RolesUSuarioUncheckedCreateWithoutUsuariosInput>
  }

  export type AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    where: AlmacenesWhereUniqueInput
    update: XOR<AlmacenesUpdateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedUpdateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput>
    create: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput>
  }

  export type AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    where: AlmacenesWhereUniqueInput
    data: XOR<AlmacenesUpdateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput, AlmacenesUncheckedUpdateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput>
  }

  export type AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    where: AlmacenesScalarWhereInput
    data: XOR<AlmacenesUpdateManyMutationInput, AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput>
  }

  export type AlmacenesScalarWhereInput = {
    AND?: AlmacenesScalarWhereInput | AlmacenesScalarWhereInput[]
    OR?: AlmacenesScalarWhereInput[]
    NOT?: AlmacenesScalarWhereInput | AlmacenesScalarWhereInput[]
    Id?: IntFilter<"Almacenes"> | number
    Code?: StringFilter<"Almacenes"> | string
    Nombre?: StringFilter<"Almacenes"> | string
    Existencia_bolsas?: IntFilter<"Almacenes"> | number
    Existencia_kg?: IntFilter<"Almacenes"> | number
    CreadoFecha?: DateTimeFilter<"Almacenes"> | Date | string
    UsuarioId?: IntFilter<"Almacenes"> | number
    FechaModificacion?: DateTimeNullableFilter<"Almacenes"> | Date | string | null
    ModificadoPor?: IntNullableFilter<"Almacenes"> | number | null
  }

  export type AlmacenesUpsertWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    where: AlmacenesWhereUniqueInput
    update: XOR<AlmacenesUpdateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedUpdateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput>
    create: XOR<AlmacenesCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedCreateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput>
  }

  export type AlmacenesUpdateWithWhereUniqueWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    where: AlmacenesWhereUniqueInput
    data: XOR<AlmacenesUpdateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput, AlmacenesUncheckedUpdateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput>
  }

  export type AlmacenesUpdateManyWithWhereWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    where: AlmacenesScalarWhereInput
    data: XOR<AlmacenesUpdateManyMutationInput, AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput>
  }

  export type InventarioUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: InventarioWhereUniqueInput
    update: XOR<InventarioUpdateWithoutUsuariosInput, InventarioUncheckedUpdateWithoutUsuariosInput>
    create: XOR<InventarioCreateWithoutUsuariosInput, InventarioUncheckedCreateWithoutUsuariosInput>
  }

  export type InventarioUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: InventarioWhereUniqueInput
    data: XOR<InventarioUpdateWithoutUsuariosInput, InventarioUncheckedUpdateWithoutUsuariosInput>
  }

  export type InventarioUpdateManyWithWhereWithoutUsuariosInput = {
    where: InventarioScalarWhereInput
    data: XOR<InventarioUpdateManyMutationInput, InventarioUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type RolesUSuarioUpsertWithoutUsuariosInput = {
    update: XOR<RolesUSuarioUpdateWithoutUsuariosInput, RolesUSuarioUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RolesUSuarioCreateWithoutUsuariosInput, RolesUSuarioUncheckedCreateWithoutUsuariosInput>
    where?: RolesUSuarioWhereInput
  }

  export type RolesUSuarioUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: RolesUSuarioWhereInput
    data: XOR<RolesUSuarioUpdateWithoutUsuariosInput, RolesUSuarioUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolesUSuarioUpdateWithoutUsuariosInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUSuarioUncheckedUpdateWithoutUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductosCreateWithoutVentasInput = {
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    Compras?: ComprasCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosCreateNestedManyWithoutProductosInput
    Inventario?: InventarioCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosCreateNestedManyWithoutProductosInput
    CategoriasProducto: CategoriasProductoCreateNestedOneWithoutProductosInput
  }

  export type ProductosUncheckedCreateWithoutVentasInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
    CategoriaId: number
    Compras?: ComprasUncheckedCreateNestedManyWithoutProductosInput
    ImagenesProductos?: ImagenesProductosUncheckedCreateNestedManyWithoutProductosInput
    Inventario?: InventarioUncheckedCreateNestedManyWithoutProductosInput
    ListasPrecios?: ListasPreciosUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductosCreateOrConnectWithoutVentasInput = {
    where: ProductosWhereUniqueInput
    create: XOR<ProductosCreateWithoutVentasInput, ProductosUncheckedCreateWithoutVentasInput>
  }

  export type ClientesCreateWithoutVentasInput = {
    Nombre: string
    Telefono?: string | null
  }

  export type ClientesUncheckedCreateWithoutVentasInput = {
    Id?: number
    Nombre: string
    Telefono?: string | null
  }

  export type ClientesCreateOrConnectWithoutVentasInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutVentasInput, ClientesUncheckedCreateWithoutVentasInput>
  }

  export type MetodosPagoCreateWithoutVentasInput = {
    code: string
    Nombre: string
  }

  export type MetodosPagoUncheckedCreateWithoutVentasInput = {
    Id?: number
    code: string
    Nombre: string
  }

  export type MetodosPagoCreateOrConnectWithoutVentasInput = {
    where: MetodosPagoWhereUniqueInput
    create: XOR<MetodosPagoCreateWithoutVentasInput, MetodosPagoUncheckedCreateWithoutVentasInput>
  }

  export type ProductosUpsertWithoutVentasInput = {
    update: XOR<ProductosUpdateWithoutVentasInput, ProductosUncheckedUpdateWithoutVentasInput>
    create: XOR<ProductosCreateWithoutVentasInput, ProductosUncheckedCreateWithoutVentasInput>
    where?: ProductosWhereInput
  }

  export type ProductosUpdateToOneWithWhereWithoutVentasInput = {
    where?: ProductosWhereInput
    data: XOR<ProductosUpdateWithoutVentasInput, ProductosUncheckedUpdateWithoutVentasInput>
  }

  export type ProductosUpdateWithoutVentasInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUpdateManyWithoutProductosNestedInput
    CategoriasProducto?: CategoriasProductoUpdateOneRequiredWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateWithoutVentasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    CategoriaId?: IntFieldUpdateOperationsInput | number
    Compras?: ComprasUncheckedUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUncheckedUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type ClientesUpsertWithoutVentasInput = {
    update: XOR<ClientesUpdateWithoutVentasInput, ClientesUncheckedUpdateWithoutVentasInput>
    create: XOR<ClientesCreateWithoutVentasInput, ClientesUncheckedCreateWithoutVentasInput>
    where?: ClientesWhereInput
  }

  export type ClientesUpdateToOneWithWhereWithoutVentasInput = {
    where?: ClientesWhereInput
    data: XOR<ClientesUpdateWithoutVentasInput, ClientesUncheckedUpdateWithoutVentasInput>
  }

  export type ClientesUpdateWithoutVentasInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientesUncheckedUpdateWithoutVentasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MetodosPagoUpsertWithoutVentasInput = {
    update: XOR<MetodosPagoUpdateWithoutVentasInput, MetodosPagoUncheckedUpdateWithoutVentasInput>
    create: XOR<MetodosPagoCreateWithoutVentasInput, MetodosPagoUncheckedCreateWithoutVentasInput>
    where?: MetodosPagoWhereInput
  }

  export type MetodosPagoUpdateToOneWithWhereWithoutVentasInput = {
    where?: MetodosPagoWhereInput
    data: XOR<MetodosPagoUpdateWithoutVentasInput, MetodosPagoUncheckedUpdateWithoutVentasInput>
  }

  export type MetodosPagoUpdateWithoutVentasInput = {
    code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MetodosPagoUncheckedUpdateWithoutVentasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
  }

  export type InventarioCreateManyAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioCreateManyAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioCreateManyAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioUpdateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Compras?: ComprasUpdateOneRequiredWithoutInventarioNestedInput
    Productos?: ProductosUpdateOneRequiredWithoutInventarioNestedInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
    Usuarios?: UsuariosUpdateOneRequiredWithoutInventarioNestedInput
  }

  export type InventarioUncheckedUpdateWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioUpdateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Compras?: ComprasUpdateOneRequiredWithoutInventarioNestedInput
    Productos?: ProductosUpdateOneRequiredWithoutInventarioNestedInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
    Usuarios?: UsuariosUpdateOneRequiredWithoutInventarioNestedInput
  }

  export type InventarioUncheckedUpdateWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioUpdateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Compras?: ComprasUpdateOneRequiredWithoutInventarioNestedInput
    Productos?: ProductosUpdateOneRequiredWithoutInventarioNestedInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Usuarios?: UsuariosUpdateOneRequiredWithoutInventarioNestedInput
  }

  export type InventarioUncheckedUpdateWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type ProductosCreateManyCategoriasProductoInput = {
    Id?: number
    Nombre: string
    Descripcion?: string | null
    Cantidad: number
    EsPieza?: boolean
  }

  export type ProductosUpdateWithoutCategoriasProductoInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUpdateManyWithoutProductosNestedInput
    Ventas?: VentasUpdateManyWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateWithoutCategoriasProductoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
    Compras?: ComprasUncheckedUpdateManyWithoutProductosNestedInput
    ImagenesProductos?: ImagenesProductosUncheckedUpdateManyWithoutProductosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutProductosNestedInput
    ListasPrecios?: ListasPreciosUncheckedUpdateManyWithoutProductosNestedInput
    Ventas?: VentasUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type ProductosUncheckedUpdateManyWithoutCategoriasProductoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    Descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    EsPieza?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VentasCreateManyClientesInput = {
    Id?: number
    Folio: string
    ProductoId: number
    Cantidad: number
    MetodoPagoId: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type VentasUpdateWithoutClientesInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Productos?: ProductosUpdateOneRequiredWithoutVentasNestedInput
    MetodosPago?: MetodosPagoUpdateOneRequiredWithoutVentasNestedInput
  }

  export type VentasUncheckedUpdateWithoutClientesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProductoId?: IntFieldUpdateOperationsInput | number
    Cantidad?: IntFieldUpdateOperationsInput | number
    MetodoPagoId?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentasUncheckedUpdateManyWithoutClientesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProductoId?: IntFieldUpdateOperationsInput | number
    Cantidad?: IntFieldUpdateOperationsInput | number
    MetodoPagoId?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioCreateManyComprasInput = {
    Id?: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type InventarioUpdateWithoutComprasInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Productos?: ProductosUpdateOneRequiredWithoutInventarioNestedInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
    Usuarios?: UsuariosUpdateOneRequiredWithoutInventarioNestedInput
  }

  export type InventarioUncheckedUpdateWithoutComprasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioUncheckedUpdateManyWithoutComprasInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type ComprasCreateManyInsumosInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    ProductoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
  }

  export type ComprasUpdateWithoutInsumosInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    TiposCompra?: TiposCompraUpdateOneRequiredWithoutComprasNestedInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasNestedInput
    Productos?: ProductosUpdateOneWithoutComprasNestedInput
    Inventario?: InventarioUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateWithoutInsumosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProveedorId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Inventario?: InventarioUncheckedUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateManyWithoutInsumosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProveedorId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentasCreateManyMetodosPagoInput = {
    Id?: number
    Folio: string
    ProductoId: number
    Cantidad: number
    ClienteId?: number | null
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type VentasUpdateWithoutMetodosPagoInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Productos?: ProductosUpdateOneRequiredWithoutVentasNestedInput
    Clientes?: ClientesUpdateOneWithoutVentasNestedInput
  }

  export type VentasUncheckedUpdateWithoutMetodosPagoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProductoId?: IntFieldUpdateOperationsInput | number
    Cantidad?: IntFieldUpdateOperationsInput | number
    ClienteId?: NullableIntFieldUpdateOperationsInput | number | null
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentasUncheckedUpdateManyWithoutMetodosPagoInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProductoId?: IntFieldUpdateOperationsInput | number
    Cantidad?: IntFieldUpdateOperationsInput | number
    ClienteId?: NullableIntFieldUpdateOperationsInput | number | null
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprasCreateManyProductosInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProveedorId: number
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
  }

  export type ImagenesProductosCreateManyProductosInput = {
    Id?: number
    URLImagen?: string | null
  }

  export type InventarioCreateManyProductosInput = {
    Id?: number
    CompraId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
    CreadoPor: number
  }

  export type ListasPreciosCreateManyProductosInput = {
    Id?: number
    UnidadMedidaId: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
  }

  export type VentasCreateManyProductosInput = {
    Id?: number
    Folio: string
    Cantidad: number
    ClienteId?: number | null
    MetodoPagoId: number
    Pagado?: boolean
    FechaPago?: Date | string | null
    Observaciones?: string | null
    CreadoFecha: Date | string
  }

  export type ComprasUpdateWithoutProductosInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    TiposCompra?: TiposCompraUpdateOneRequiredWithoutComprasNestedInput
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasNestedInput
    Insumos?: InsumosUpdateOneWithoutComprasNestedInput
    Inventario?: InventarioUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProveedorId?: IntFieldUpdateOperationsInput | number
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Inventario?: InventarioUncheckedUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateManyWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProveedorId?: IntFieldUpdateOperationsInput | number
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagenesProductosUpdateWithoutProductosInput = {
    URLImagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImagenesProductosUncheckedUpdateWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    URLImagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImagenesProductosUncheckedUpdateManyWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    URLImagen?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventarioUpdateWithoutProductosInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Compras?: ComprasUpdateOneRequiredWithoutInventarioNestedInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
    Usuarios?: UsuariosUpdateOneRequiredWithoutInventarioNestedInput
  }

  export type InventarioUncheckedUpdateWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type InventarioUncheckedUpdateManyWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoPor?: IntFieldUpdateOperationsInput | number
  }

  export type ListasPreciosUpdateWithoutProductosInput = {
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
    UnidadesMedida?: UnidadesMedidaUpdateOneRequiredWithoutListasPreciosNestedInput
  }

  export type ListasPreciosUncheckedUpdateWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UnidadMedidaId?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ListasPreciosUncheckedUpdateManyWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UnidadMedidaId?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VentasUpdateWithoutProductosInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Clientes?: ClientesUpdateOneWithoutVentasNestedInput
    MetodosPago?: MetodosPagoUpdateOneRequiredWithoutVentasNestedInput
  }

  export type VentasUncheckedUpdateWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    ClienteId?: NullableIntFieldUpdateOperationsInput | number | null
    MetodoPagoId?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentasUncheckedUpdateManyWithoutProductosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    ClienteId?: NullableIntFieldUpdateOperationsInput | number | null
    MetodoPagoId?: IntFieldUpdateOperationsInput | number
    Pagado?: BoolFieldUpdateOperationsInput | boolean
    FechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprasCreateManyProveedoresInput = {
    Id?: number
    Folio: string
    TipoCompraId: number
    ProductoId?: number | null
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
  }

  export type ComprasUpdateWithoutProveedoresInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    TiposCompra?: TiposCompraUpdateOneRequiredWithoutComprasNestedInput
    Productos?: ProductosUpdateOneWithoutComprasNestedInput
    Insumos?: InsumosUpdateOneWithoutComprasNestedInput
    Inventario?: InventarioUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateWithoutProveedoresInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Inventario?: InventarioUncheckedUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateManyWithoutProveedoresInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    TipoCompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosCreateManyRolesUSuarioInput = {
    Id?: number
    Nombre: string
    UsuariosLeier?: string | null
    Contrase_a?: string | null
    CreadoFecha: Date | string
  }

  export type UsuariosUpdateWithoutRolesUSuarioInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario?: InventarioUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutRolesUSuarioInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Almacenes_Almacenes_UsuarioIdToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosNestedInput
    Almacenes_Almacenes_ModificadoPorToUsuarios?: AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario?: InventarioUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type UsuariosUncheckedUpdateManyWithoutRolesUSuarioInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    UsuariosLeier?: NullableStringFieldUpdateOperationsInput | string | null
    Contrase_a?: NullableStringFieldUpdateOperationsInput | string | null
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprasCreateManyTiposCompraInput = {
    Id?: number
    Folio: string
    ProveedorId: number
    ProductoId?: number | null
    InsumoId?: number | null
    Cantidad: number
    CantidadRecibida: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    FechaRecepcion: Date | string
    CreadoFecha: Date | string
  }

  export type ComprasUpdateWithoutTiposCompraInput = {
    Folio?: StringFieldUpdateOperationsInput | string
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Proveedores?: ProveedoresUpdateOneRequiredWithoutComprasNestedInput
    Productos?: ProductosUpdateOneWithoutComprasNestedInput
    Insumos?: InsumosUpdateOneWithoutComprasNestedInput
    Inventario?: InventarioUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateWithoutTiposCompraInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProveedorId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Inventario?: InventarioUncheckedUpdateManyWithoutComprasNestedInput
  }

  export type ComprasUncheckedUpdateManyWithoutTiposCompraInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Folio?: StringFieldUpdateOperationsInput | string
    ProveedorId?: IntFieldUpdateOperationsInput | number
    ProductoId?: NullableIntFieldUpdateOperationsInput | number | null
    InsumoId?: NullableIntFieldUpdateOperationsInput | number | null
    Cantidad?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    FechaRecepcion?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListasPreciosCreateManyUnidadesMedidaInput = {
    Id?: number
    ProductoId: number
    CostoUnitario: Decimal | DecimalJsLike | number | string
    Utilidad: Decimal | DecimalJsLike | number | string
    PrecioUnitario: Decimal | DecimalJsLike | number | string
    CreadoFecha: Date | string
    Vigente?: boolean
  }

  export type ListasPreciosUpdateWithoutUnidadesMedidaInput = {
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
    Productos?: ProductosUpdateOneRequiredWithoutListasPreciosNestedInput
  }

  export type ListasPreciosUncheckedUpdateWithoutUnidadesMedidaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ListasPreciosUncheckedUpdateManyWithoutUnidadesMedidaInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CostoUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Utilidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PrecioUnitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Vigente?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlmacenesCreateManyUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    FechaModificacion?: Date | string | null
    ModificadoPor?: number | null
  }

  export type AlmacenesCreateManyUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    Id?: number
    Code: string
    Nombre: string
    Existencia_bolsas: number
    Existencia_kg: number
    CreadoFecha: Date | string
    UsuarioId: number
    FechaModificacion?: Date | string | null
  }

  export type InventarioCreateManyUsuariosInput = {
    Id?: number
    CompraId: number
    ProductoId: number
    CantidadRecibida: number
    AlmacenActualId: number
    FechaSurtido: Date | string
    SurtidoPorAlmacenId: number
    RecibidoPorAlmacenId: number
    CreadoFecha: Date | string
  }

  export type AlmacenesUpdateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios_Almacenes_ModificadoPorToUsuarios?: UsuariosUpdateOneWithoutAlmacenes_Almacenes_ModificadoPorToUsuariosNestedInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModificadoPor?: NullableIntFieldUpdateOperationsInput | number | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_UsuarioIdToUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModificadoPor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlmacenesUpdateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Usuarios_Almacenes_UsuarioIdToUsuarios?: UsuariosUpdateOneRequiredWithoutAlmacenes_Almacenes_UsuarioIdToUsuariosNestedInput
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    UsuarioId?: IntFieldUpdateOperationsInput | number
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventario_Inventario_AlmacenActualIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Inventario_Inventario_SurtidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Inventario_Inventario_RecibidoPorAlmacenIdToAlmacenes?: InventarioUncheckedUpdateManyWithoutAlmacenes_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type AlmacenesUncheckedUpdateManyWithoutUsuarios_Almacenes_ModificadoPorToUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Code?: StringFieldUpdateOperationsInput | string
    Nombre?: StringFieldUpdateOperationsInput | string
    Existencia_bolsas?: IntFieldUpdateOperationsInput | number
    Existencia_kg?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    UsuarioId?: IntFieldUpdateOperationsInput | number
    FechaModificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventarioUpdateWithoutUsuariosInput = {
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
    Compras?: ComprasUpdateOneRequiredWithoutInventarioNestedInput
    Productos?: ProductosUpdateOneRequiredWithoutInventarioNestedInput
    Almacenes_Inventario_AlmacenActualIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_AlmacenActualIdToAlmacenesNestedInput
    Almacenes_Inventario_SurtidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_SurtidoPorAlmacenIdToAlmacenesNestedInput
    Almacenes_Inventario_RecibidoPorAlmacenIdToAlmacenes?: AlmacenesUpdateOneRequiredWithoutInventario_Inventario_RecibidoPorAlmacenIdToAlmacenesNestedInput
  }

  export type InventarioUncheckedUpdateWithoutUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarioUncheckedUpdateManyWithoutUsuariosInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CompraId?: IntFieldUpdateOperationsInput | number
    ProductoId?: IntFieldUpdateOperationsInput | number
    CantidadRecibida?: IntFieldUpdateOperationsInput | number
    AlmacenActualId?: IntFieldUpdateOperationsInput | number
    FechaSurtido?: DateTimeFieldUpdateOperationsInput | Date | string
    SurtidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    RecibidoPorAlmacenId?: IntFieldUpdateOperationsInput | number
    CreadoFecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}